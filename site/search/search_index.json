{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Forside","text":"<p>This is your new vault.</p> <p>Make a note of something, [[create a link]], or try the Importer!</p> <p>When you're ready, delete this note and make the vault your own.</p>"},{"location":"AI-ML/","title":"AI &amp; ML \u2013 Oversigt","text":""},{"location":"AI-ML/L%C3%A6ringsm%C3%A5l%20Ai%20%26%20ML/","title":"L\u00e6ringsm\u00e5l","text":""},{"location":"AI-ML/L%C3%A6ringsm%C3%A5l%20Ai%20%26%20ML/#1-opna-forstaelse-for-fundamentale-begreber-inden-for-ai-og-ml","title":"1. Opn\u00e5 forst\u00e5else for fundamentale begreber inden for AI og ML","text":"<p>M\u00e5let er at kunne redeg\u00f8re for centrale principper i kunstig intelligens, machine learning og generativ AI, samt forst\u00e5 forskellen mellem ML-elementerne i projektet (embeddings, similarity scoring, tekstklassifikation) og AI-delen (RAG, prompting, sikkerhedslag, agent-flow).</p>"},{"location":"AI-ML/L%C3%A6ringsm%C3%A5l%20Ai%20%26%20ML/#2-opna-viden-om-forskellen-mellem-nlp-og-llm-baseret-sprogforstaelse","title":"2. Opn\u00e5 viden om forskellen mellem NLP og LLM-baseret sprogforst\u00e5else","text":"<p>M\u00e5let er at forst\u00e5, hvad klassisk NLP indeb\u00e6rer (tekstopdeling, tokenisering, simpel klassifikation og semantiske repr\u00e6sentationer), og hvordan det adskiller sig fra LLM\u2019er, der arbejder med reasoning, kontekstforst\u00e5else og generering af tekst. Der l\u00e6gges v\u00e6gt p\u00e5 at kunne forklare, at tokenisering indg\u00e5r i begge, men anvendes forskelligt.</p>"},{"location":"AI-ML/L%C3%A6ringsm%C3%A5l%20Ai%20%26%20ML/#3-opna-indsigt-i-hvordan-tekst-behandles-i-et-llm-og-rag-system","title":"3. Opn\u00e5 indsigt i, hvordan tekst behandles i et LLM- og RAG-system","text":"<p>M\u00e5let er at forst\u00e5, hvordan tekst konverteres til tokens og embeddings, hvordan dokumenter opdeles i mindre dele (chunking), og hvordan disse bruges i en vektordatabase til relevanshentning. Der l\u00e6gges v\u00e6gt p\u00e5 viden om kontekststyring, dvs. hvordan embeddings, metadata og relevansscoring tilsammen bestemmer, hvilken viden modellen f\u00e5r adgang til, og hvordan korrekt kontekstopbygning reducerer hallucinationer og \u00f8ger pr\u00e6cisionen i et RAG-system.</p>"},{"location":"AI-ML/L%C3%A6ringsm%C3%A5l%20Ai%20%26%20ML/#4-opna-grundlggende-viden-om-styrker-og-begrnsninger-ved-forskellige-llm-modeller","title":"4. Opn\u00e5 grundl\u00e6ggende viden om styrker og begr\u00e6nsninger ved forskellige LLM-modeller","text":"<p>M\u00e5let er at forst\u00e5 p\u00e5 et basalt niveau, at modeller varierer i pr\u00e6cision, hastighed og kvalitet, og have praktisk indsigt i hvordan modelvalg p\u00e5virker et RAG- eller agent-setup \u2013 uden behov for dyb teknisk viden om arkitekturer.</p>"},{"location":"AI-ML/L%C3%A6ringsm%C3%A5l%20Ai%20%26%20ML/#5-opna-forstaelse-for-prompt-engineering-og-strukturerede-prompt-strategier","title":"5. Opn\u00e5 forst\u00e5else for prompt engineering og strukturerede prompt-strategier","text":"<p>M\u00e5let er at l\u00e6re, hvordan systeminstrukser, roller, constraints og prompt-skabeloner p\u00e5virker en LLM\u2019s output, og hvorfor strukturerede prompts er n\u00f8dvendige for stabile og mere kontrollerede AI-svar.</p>"},{"location":"AI-ML/L%C3%A6ringsm%C3%A5l%20Ai%20%26%20ML/#6-opna-viden-om-ai-agenter-reasoning-og-sikkerhedslag","title":"6. Opn\u00e5 viden om AI-agenter, reasoning og sikkerhedslag","text":"<p>M\u00e5let er at forst\u00e5 forskellen mellem en simpel chatbot og et agent-baseret system, herunder de centrale trin i en agent-pipeline: klassificering, sikkerhedslag, dokumenthentning, modelgenerering og output-validering. Der l\u00e6gges v\u00e6gt p\u00e5 forst\u00e5elsen af nonsens-detektion, filtrering og fallback-logik.</p>"},{"location":"AI-ML/L%C3%A6ringsm%C3%A5l%20Ai%20%26%20ML/#7-opna-grundlggende-viden-om-python-til-brug-i-ai-integration-og-pipeline-styring","title":"7. Opn\u00e5 grundl\u00e6ggende viden om Python til brug i AI-integration og pipeline-styring","text":"<p>M\u00e5let er at kunne forst\u00e5, hvordan Python anvendes til at opbygge en RAG-pipeline, h\u00e5ndtere embedding-generering, udf\u00f8re async-kald, arbejde med en vektordatabase og styre agent-flowet.</p>"},{"location":"AI-ML/L%C3%A6ringsm%C3%A5l%20Ai%20%26%20ML/#konklusion-hvordan-lringsmalene-er-dkket","title":"Konklusion \u2013 hvordan l\u00e6ringsm\u00e5lene er d\u00e6kket","text":"<p>Mit AI-projekt d\u00e6kker alle l\u00e6ringsm\u00e5lene gennem den samlede RAG- og agent-arkitektur, jeg har bygget. Arbejdet med embeddings, similarity scoring og tekstklassifikation har givet praktisk forst\u00e5else for de ML-elementer, der indg\u00e5r i projektet, mens RAG, prompting, sikkerhedslag og agent-flowet giver indsigt i centrale AI-begreber.</p> <p>Forskellen mellem klassisk NLP og LLM-baseret sprogforst\u00e5else opleves direkte i systemet: NLP-delen h\u00e5ndterer tekstopdeling, tokenisering og semantiske repr\u00e6sentationer, mens LLM\u2019en st\u00e5r for reasoning, kontekstforst\u00e5else og generering af svar.</p> <p>Jeg har desuden arbejdet konkret med, hvordan tekst behandles i et RAG-system \u2014 fra chunking og embeddings til relevanshentning i vektordatabasen og opbygning af korrekt kontekst for at reducere hallucinationer. Modelvalg mellem Llama og Mistral har givet erfaring med forskelle i ydeevne og pr\u00e6cision.</p> <p>Derudover har udviklingen af prompt builder, roller og constraints givet praktisk erfaring med prompt engineering, og agent-flowet (klassificering \u2192 sikkerhedslag \u2192 RAG \u2192 generering \u2192 fallback) har givet indsigt i forskellen mellem en simpel chatbot og et fuldt agent-baseret system.</p> <p>Endelig har Python-delen givet hands-on erfaring med at opbygge en pipeline, h\u00e5ndtere embedding-generering, arbejde med en vektordatabase og strukturere hele agent-processen.</p>"},{"location":"AI-ML/Sikkerhed%20i%20forhold%20til%20projektet%20cahtbotten/","title":"1. Sikkerhed i botten (det vi allerede HAR t\u00e6nkt ind)","text":"<p>Der er tre typer sikkerhed i en RAG-chatbot:</p>"},{"location":"AI-ML/Sikkerhed%20i%20forhold%20til%20projektet%20cahtbotten/#a-indholds-sikkerhed-content-safety","title":"A) Indholds-sikkerhed (Content Safety)","text":"<p>\u2192 handler om at undg\u00e5 farlige svar</p> <p>Dette HAR vi lavet:</p> <p>\u2714 Medicinsk filter</p> <ul> <li> <p>botten m\u00e5 ikke svare p\u00e5 dosering, diagnoser, symptomer.</p> </li> <li> <p>automatisk \u201cvenligt afslag\u201d \u2192 sikrer compliance.</p> </li> </ul> <p>\u2714 Off-topic filter</p> <ul> <li>botten svarer ikke p\u00e5 politiske, farlige eller irrelevante emner.</li> </ul> <p>\u2714 Nonsense filter</p> <ul> <li>botten undg\u00e5r at svare med hallucinationer.</li> </ul> <p>\u2714 Prompt-restriktioner</p> <ul> <li> <p>\u201cbrug kun konteksten\u201d</p> </li> <li> <p>\u201csig \u00e6rligt hvis du ikke ved det\u201d</p> </li> <li> <p>\u201cingen skr\u00e6mmende formuleringer\u201d</p> </li> <li> <p>\u201cingen medicinske r\u00e5d\u201d</p> </li> </ul> <p>\u2192 Dette er indholdssikkerhed og det er 100% implementeret.</p>"},{"location":"AI-ML/Sikkerhed%20i%20forhold%20til%20projektet%20cahtbotten/#b-system-sikkerhed-model-kontrol","title":"B) System-sikkerhed (model-kontrol)","text":"<p>\u2192 beskytter mod at modellen l\u00f8ber udenfor rammerne</p> <p>\u2714 Tone &amp; adf\u00e6rd defineret i strict prompt \u2714 M\u00e5 ikke opfinde nyt \u2714 M\u00e5 ikke give r\u00e5d uden for hjemmesiden \u2714 Afgr\u00e6nset til websiteets tema (healingsprocesser, nervesystem, mildhed)</p> <p>\u2192 Denne sikkerhed er vigtig, og vi har fuldt styr p\u00e5 den.</p>"},{"location":"AI-ML/Sikkerhed%20i%20forhold%20til%20projektet%20cahtbotten/#c-rag-sikkerhed-retrieval-guardrails","title":"C) RAG-sikkerhed (Retrieval Guardrails)","text":"<p>\u2192 beskytter mod at modellen svarer uden valide dokumenter</p> <p>\u2714 Similarity check (distance-threshold)</p> <ul> <li> <p>hvis dokumenter er for irrelevante \u2192 botten SKIFTER til fallback</p> </li> <li> <p>dette er en af de vigtigste sikkerhedsforanstaltninger i RAG</p> </li> </ul> <p>\u2714 Ingen dokumenter = ingen frie svar</p> <ul> <li> <p>botten hallucinerer ikke</p> </li> <li> <p>den svarer venligt, men uden at finde p\u00e5 nyt</p> </li> </ul> <p>\u2192 Dette er kerne-sikkerhed i RAG og vi har implementeret det korrekt.</p>"},{"location":"AI-ML/Sikkerhed%20i%20forhold%20til%20projektet%20cahtbotten/#2-ratelimit-ogsa-en-form-for-sikkerhed","title":"\u2705 2. Ratelimit = ogs\u00e5 en form for sikkerhed","text":"<p>Yes \u2014 rate limit er system-sikkerhed.</p> <p>Det beskytter:</p> <ul> <li> <p>OpenAI API</p> </li> <li> <p>din konto (\u00f8konomi)</p> </li> <li> <p>beskytter serveren mod spam</p> </li> <li> <p>g\u00f8r systemet stabilt</p> </li> </ul> <p>Med rate-limiting forhindrer vi:</p> <p>\u274c 500 requests/sekund \u274c bot-angreb \u274c bots der spammer API\u2019et (dyrt!) \u274c fejl der k\u00f8rer loops</p> <p>Du beh\u00f8ver ikke implementere det nu, men du kan sige:</p> <p>\u201cVi har planlagt at tilf\u00f8je rate-limiting som ekstra sikkerhed, s\u00e5 API\u2019en ikke misbruges eller overskrides.\u201d</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/","title":"Oversigt","text":"<p>Dette er sektionen.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20Modeller/","title":"Blog \u2013 Etape: LLM-modeller og deres styrker, svagheder og anvendelse","text":""},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20Modeller/#mal-for-etapen","title":"\ud83c\udfaf M\u00e5l for etapen","text":"<p>Jeg ville i denne etape skabe et overblik over forskellige LLM-modeller og forst\u00e5, hvad de hver is\u00e6r er gode til. Det er vigtigt i forhold til projektet, fordi vores tre chatagenter kan have forskellige behov, b\u00e5de i forhold til sprog, dom\u00e6ne, pris og pr\u00e6cision.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20Modeller/#hvad-jeg-lrte","title":"\ud83d\udcda Hvad jeg l\u00e6rte","text":"<p>Jeg er st\u00f8dt p\u00e5 en del forskellige modeller efterh\u00e5nden, og det er blevet tydeligt for mig, at de ikke fungerer ens. B\u00e5de deres arkitektur, st\u00f8rrelse, tr\u00e6ningsdata og tokenisering g\u00f8r en forskel.</p> <p>Her er et samlet overblik over de modeller, jeg har arbejdet med eller l\u00e6rt om indtil nu:</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20Modeller/#openai-gpt-modellerne","title":"\ud83d\udd39 OpenAI (GPT-modellerne)","text":"<p>OpenAI-modellerne er meget st\u00e6rke generelle modeller. De er gode til:</p> <ul> <li> <p>formidling</p> </li> <li> <p>forklaringer</p> </li> <li> <p>logik</p> </li> <li> <p>generering af l\u00e6ngere svar</p> </li> </ul> <p>De h\u00e5ndterer det meste rigtig godt, men de er ogs\u00e5 de dyreste at bruge. Til geng\u00e6ld er de stabile og p\u00e5lidelige, og de fungerer rigtig godt til sprog som dansk og engelsk.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20Modeller/#claude-anthropic","title":"\ud83d\udd39 Claude (Anthropic)","text":"<p>Claude er is\u00e6r god til lange dokumenter og komplekse sammenh\u00e6nge. Den har et meget stort kontekstvindue og gode evner til at bevare struktur i l\u00e6ngere svar.</p> <p>Den virker ogs\u00e5 rigtig god til opsummering og at holde styr p\u00e5 detaljer. Den kan dog v\u00e6re lidt dyrere, og jeg er ikke sikker p\u00e5 hvor god den er p\u00e5 meget dom\u00e6nespecifik sundhedsdata.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20Modeller/#deepseek","title":"\ud83d\udd39 DeepSeek","text":"<p>DeepSeek-modellerne er open-source og gratis, og de overraskede mig positivt. De virker st\u00e6rke til logik, reasoning og is\u00e6r kodning. De kan godt v\u00e6re lidt mere ustabile i svarene, men til geng\u00e6ld er de \u00f8konomisk rigtig gode, og de kan k\u00f8re lokalt.</p> <p>Til projektet giver DeepSeek mest mening i udviklingsfasen og prototyper, men m\u00e5ske ikke som prim\u00e6r sundhedsagent.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20Modeller/#llama-mistral-gemma-open-source-modeller","title":"\ud83d\udd39 Llama / Mistral / Gemma (open-source modeller)","text":"<p>Disse modeller er gratis og kan k\u00f8re lokalt via fx Ollama. De er rigtig gode, hvis man vil have fuld kontrol, lave test, eller bygge noget der ikke skal koste penge i API-kald.</p> <p>De kan dog variere meget i kvalitet, is\u00e6r p\u00e5 dansk og sundhedsrelaterede emner. Men nogle af dem (fx Mistral) er blevet meget st\u00e6rke i almindelig generering.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20Modeller/#bert-og-lignende-encoder-modeller","title":"\ud83d\udd39 BERT og lignende encoder-modeller","text":"<p>BERT er en helt anden type model, som jeg har l\u00e6rt bruges prim\u00e6rt til:</p> <ul> <li> <p>klassifikation</p> </li> <li> <p>forst\u00e5else</p> </li> <li> <p>s\u00f8gning</p> </li> <li> <p>embeddings</p> </li> </ul> <p>Den genererer ikke svar og er ikke en chatbot. Men den er vigtig i RAG-systemer, fordi encoder-modeller bruges til at generere embeddings. Det g\u00f8r den indirekte relevant for mit Python-projekt.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20Modeller/#refleksion","title":"\ud83d\udca1 Refleksion","text":"<p>N\u00e5r jeg ser p\u00e5 alle modellerne samlet, giver det mere mening for mig, hvorfor man ikke bare kan \u201cv\u00e6lge en tilf\u00e6ldig LLM\u201d. Der er forskelle i:</p> <ul> <li> <p>hvor gode de er til dansk</p> </li> <li> <p>hvor dybe deres svar er</p> </li> <li> <p>om de er gode til sundhedsrelevante sp\u00f8rgsm\u00e5l</p> </li> <li> <p>hvor dyre de er at bruge</p> </li> <li> <p>om de kan k\u00f8re lokalt</p> </li> <li> <p>og hvor stabile de er</p> </li> </ul> <p>OpenAI og Claude virker som st\u00e6rke valg til en sundheds- eller informationsagent, fordi de har stabilitet, sprogforst\u00e5else og gode forklaringer. DeepSeek og open-source modellerne virker bedre som udviklingsv\u00e6rkt\u00f8jer eller billige alternativer, men m\u00e5ske ikke til det mest f\u00f8lsomme indhold.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20Modeller/#projekt-specifikt","title":"\ud83d\udca1 Projekt specifikt","text":"<p>Jeg kan allerede se, at vores tre chatagenter m\u00e5ske ender med at bruge forskellige modeller \u2013 eller i hvert fald have forskellige styrker.</p> <ul> <li> <p>Guider-agenten vil drage fordel af stabile modeller, der kan forklare ting klart.</p> </li> <li> <p>Sundhedsagenten kr\u00e6ver en model, der er god til at forst\u00e5 fagtermer og som giver mindre risiko for fejl.</p> </li> <li> <p>Tr\u00e6ningsplan-agenten skal nok bruge en model, der kan generere strukturerede svar, og her kan finetuning komme p\u00e5 tale.</p> </li> </ul> <p>Det er tydeligt for mig, at modelvalg h\u00e6nger sammen med b\u00e5de RAG, tokenisering, transformer-arkitekturen og den m\u00e5de jeg bygger Python-projektet p\u00e5. Det hele begynder at h\u00e6nge sammen nu, og jeg f\u00f8ler, at jeg har f\u00e5et en mere realistisk forst\u00e5else af forskellene mellem modellerne og deres styrker i praksis</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/","title":"Uddybning til Dagbog Etape 2 (LLM\u2019er &amp; Transformers)","text":"<p>(Dette er den version du kan linke til fra din dagbog.)</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#hvad-er-en-llm-egentlig","title":"\ud83e\udde0 Hvad er en LLM egentlig?","text":"<p>En Large Language Model (LLM) er en maskinl\u00e6ringsmodel, der er tr\u00e6net til at forst\u00e5 og generere menneskeligt sprog. Den arbejder ikke med \u201cord\u201d som mennesker, men bruger matematiske repr\u00e6sentationer, der g\u00f8r det muligt at:</p> <ul> <li> <p>forst\u00e5 mening</p> </li> <li> <p>finde sammenh\u00e6nge</p> </li> <li> <p>svare, opsummere, forklare, analysere</p> </li> <li> <p>forudsige n\u00e6ste token i en s\u00e6tning</p> </li> </ul> <p>LLM\u2019er er en slags \u201ctekstmotor\u201d bygget ovenp\u00e5 transformer-arkitekturen.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#transformers-den-underliggende-arkitektur","title":"\ud83e\udde9 Transformers \u2013 den underliggende arkitektur","text":"<p>Transformers er den teknologi som moderne LLM\u2019er (GPT, DeepSeek, Claude, Llama, Gemma osv.) bygger p\u00e5. Tre ting g\u00f8r transformers specielle:</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#1-attention-fokusmekanismen","title":"1) Attention (fokusmekanismen)","text":"<p>Attention g\u00f8r det muligt for modellen at:</p> <ul> <li> <p>l\u00e6se hele s\u00e6tningen p\u00e5 \u00e9n gang</p> </li> <li> <p>forst\u00e5 relationer mellem ord</p> </li> <li> <p>fokusere p\u00e5 vigtige detaljer</p> </li> <li> <p>holde styr p\u00e5 kontekst</p> </li> </ul> <p>Eksempel: I s\u00e6tningen \u201cpatienten tog medicinen fordi hun f\u00f8lte svimmelhed\u201d skal modellen forst\u00e5 at \u201chun\u201d refererer til \u201cpatienten\u201d og at \u201csvimmelhed\u201d er \u00e5rsagen.</p> <p>Det kr\u00e6ver attention.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#2-parallel-lsning","title":"2) Parallel l\u00e6sning","text":"<p>\u00c6ldre modeller (RNN, LSTM) l\u00e6ste tekst \u00e9t ord ad gangen. Transformers l\u00e6ser alt samtidigt, hvilket giver:</p> <ul> <li> <p>hurtigere modeller</p> </li> <li> <p>bedre forst\u00e5else af lange tekster</p> </li> <li> <p>bedre logiske svar</p> </li> </ul>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#3-lag-pa-lag-af-forstaelse","title":"3) Lag p\u00e5 lag af forst\u00e5else","text":"<p>Transformers best\u00e5r af mange lag, og hvert lag l\u00e6rer noget forskelligt:</p> <ul> <li> <p>nogle lag l\u00e6rer grammatik</p> </li> <li> <p>nogle l\u00e6rer fakta</p> </li> <li> <p>nogle l\u00e6rer logik</p> </li> <li> <p>nogle l\u00e6rer sammenh\u00e6nge mellem begreber</p> </li> </ul> <p>Det g\u00f8r dem fleksible og anvendelige p\u00e5 mange omr\u00e5der \u2014 ogs\u00e5 sundhedsdata.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#tre-vigtige-arkitekturer-encoder-decoder-og-encoderdecoder","title":"\ud83e\uddf1 Tre vigtige arkitekturer: Encoder, Decoder og Encoder\u2013Decoder","text":""},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#encoder-only-modeller-feks-bert","title":"\ud83d\udd39 Encoder-only modeller (f.eks. BERT)","text":"<p>Disse modeller er rigtig gode til:</p> <ul> <li> <p>at forst\u00e5 tekst</p> </li> <li> <p>klassifikation</p> </li> <li> <p>sentiment</p> </li> <li> <p>s\u00f8gning</p> </li> <li> <p>embeddings til RAG</p> </li> </ul> <p>De genererer ikke tekst.</p> <p>\u2192 I dit projekt bruges encoder-lignende funktionalitet indirekte gennem embeddings i RAG.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#decoder-only-modeller-feks-gpt-claude-deepseek","title":"\ud83d\udd39 Decoder-only modeller (f.eks. GPT, Claude, DeepSeek)","text":"<p>De kan:</p> <ul> <li> <p>generere tekst</p> </li> <li> <p>f\u00f8re samtaler</p> </li> <li> <p>svare p\u00e5 sp\u00f8rgsm\u00e5l</p> </li> <li> <p>l\u00f8se opgaver</p> </li> <li> <p>forklare komplekse ting</p> </li> </ul> <p>De er de klassiske chatbot-modeller.</p> <p>\u2192 I dit projekt er dette den type du bruger til din guider-agent og sundhedsagent.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#encoderdecoder-modeller-feks-t5-flan-t5","title":"\ud83d\udd39 Encoder\u2013decoder modeller (f.eks. T5, FLAN-T5)","text":"<p>De er bedst til:</p> <ul> <li> <p>overs\u00e6ttelse</p> </li> <li> <p>opsummering</p> </li> <li> <p>konvertering af tekst fra \u00e9n form til en anden</p> </li> </ul> <p>\u2192 Ikke lige s\u00e5 relevante for selve chatbotdelen, men nyttige til databehandling.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#hvorfor-modellernes-forskelle-betyder-noget-i-praksis","title":"\ud83c\udf10 Hvorfor modellernes forskelle betyder noget i praksis","text":"<p>Du n\u00e6vner i din dagbog, at modeller opf\u00f8rer sig forskelligt.</p> <p>Her er hvorfor:</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#de-er-trnet-pa-forskellige-datast","title":"\ud83d\udd38 De er tr\u00e6net p\u00e5 forskellige datas\u00e6t","text":"<p>Nogle har meget sundhedsdata. Nogle har n\u00e6sten intet. Nogle modeller \u201cforst\u00e5r\u201d bedre dansk eller engelsk end andre.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#de-bruger-forskellige-tokenizere","title":"\ud83d\udd38 De bruger forskellige tokenizere","text":"<p>Danske eller medicinske ord kan v\u00e6re \u201csv\u00e6re\u201d for visse modeller.</p> <p>Eksempel: \u201ckronisk sygdom\u201d kan blive 3 tokens i \u00e9n model og 6 tokens i en anden.</p> <p>\u2192 P\u00e5virker pris og kvalitet.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#de-har-forskellige-styrker","title":"\ud83d\udd38 De har forskellige styrker","text":"<ul> <li> <p>OpenAI \u2192 st\u00e6rk til reasoning, forklaringer</p> </li> <li> <p>Claude \u2192 st\u00e6rk til lange dokumenter</p> </li> <li> <p>DeepSeek \u2192 st\u00e6rk til logik og kode</p> </li> <li> <p>Mistral/Llama \u2192 st\u00e6rke lokale modeller</p> </li> <li> <p>BERT \u2192 st\u00e6rk til forst\u00e5else, ikke generering</p> </li> </ul> <p>\u2192 Derfor skal du v\u00e6lge model efter agentens opgave.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#relevans-for-dit-sundhedsprojekt","title":"\ud83c\udfe5 Relevans for dit sundhedsprojekt","text":"<p>Du n\u00e6vner i blog 2, at dine chatagenter skal forst\u00e5 sundhedsdata.</p> <p>Det stiller krav:</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#modellen-skal-forsta-fagtermer","title":"\u2714\ufe0f Modellen skal forst\u00e5 fagtermer","text":"<p>Som \u201cakut svimmelhed\u201d, \u201cbeta-histidin\u201d, \u201cblodtryk\u201d, \u201cmigraine aura\u201d, osv.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#modellen-skal-vre-god-til-kontekstforstaelse","title":"\u2714\ufe0f Modellen skal v\u00e6re god til kontekstforst\u00e5else","text":"<p>F.eks. n\u00e5r brugerens s\u00e6tning indeholder symptomer, \u00e5rsager og kontekst.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#modellen-ma-ikke-hallucinere-for-meget","title":"\u2714\ufe0f Modellen m\u00e5 ikke \u201challucinere\u201d for meget","text":"<p>Derfor er modelforst\u00e5else og transformer-kendskab vigtigt.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/LLM%20og%20transformers/#derfor-skal-du-teste-forskellige-llmer","title":"\u2714\ufe0f Derfor skal du teste forskellige LLM\u2019er","text":"<p>\u2014 is\u00e6r dem med god tr\u00e6ning p\u00e5 sundhedsrelateret indhold.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/RAG%20VS.%20Finetuning/","title":"L\u00e6ringsside \u2013 Uddybning til Etape \u201cRAG vs. Fine-tuning\u201d","text":"<p>(skrevet som om det er dig, i samme tone som dine \u00f8vrige blogs)</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/RAG%20VS.%20Finetuning/#min-uddybede-forstaelse-af-rag-og-fine-tuning","title":"\ud83d\udd0e Min uddybede forst\u00e5else af RAG og Fine-tuning","text":"<p>I denne etape begyndte jeg at arbejde mere konkret med forskellen mellem RAG og fine-tuning, og hvad der faktisk giver mening i forhold til de tre forskellige agenter vi skal bygge i projektet. Det blev hurtigt tydeligt for mig, at selvom begge begreber ofte n\u00e6vnes sammen, s\u00e5 l\u00f8ser de to ting meget forskellige problemer \u2013 og har meget forskellige fordele.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/RAG%20VS.%20Finetuning/#rag-det-jeg-arbejder-mest-med","title":"\ud83e\udde0 RAG \u2013 det jeg arbejder mest med","text":"<p>RAG (Retrieval Augmented Generation) er i bund og grund en tilgang hvor modellen ikke kun baserer sit svar p\u00e5 det, den allerede er tr\u00e6net p\u00e5, men ogs\u00e5 p\u00e5 ny information, som jeg giver den via lokale dokumenter.</p> <p>Processen i RAG har jeg efterh\u00e5nden f\u00e5et godt styr p\u00e5:</p> <ol> <li> <p>Brugeren sp\u00f8rger om noget</p> </li> <li> <p>Der hentes relevante tekststykker fra mine egne dokumenter (via embeddings og vector-database)</p> </li> <li> <p>Disse tekststykker bliver sendt ind som kontekst</p> </li> <li> <p>Modellen svarer ud fra b\u00e5de prompten og de dokumenter jeg har valgt</p> </li> </ol> <p>Det er ogs\u00e5 denne tilgang, jeg arbejder med i mit Python-projekt lige nu \u2013 hvor jeg bruger Chroma som vektor-database og embeddings til at finde relevant viden. Jeg bruger ogs\u00e5 few-shot prompting til at styre tonen og formen p\u00e5 svarene.</p> <p>Det er en fleksibel l\u00f8sning, fordi jeg kan opdatere alt indholdet n\u00e5r som helst, uden at skulle tr\u00e6ne en model om.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/RAG%20VS.%20Finetuning/#fine-tuning-forstaet-i-forhold-til-mit-projekt","title":"\ud83e\uddea Fine-tuning \u2013 forst\u00e5et i forhold til mit projekt","text":"<p>Fine-tuning er en anden tilgang, hvor man tager en eksisterende model og tr\u00e6ner den videre p\u00e5 specifik data. Modellen \u00e6ndrer sig alts\u00e5 reelt, n\u00e5r man fine-tuner den.</p> <p>Det giver fordele ved:</p> <ul> <li> <p>meget faste opgaver</p> </li> <li> <p>specifik skrivestil</p> </li> <li> <p>gentagne formater</p> </li> <li> <p>klassifikationsopgaver</p> </li> </ul> <p>Men i mit projekt er behovet noget andet. Jeg har mange tekster, der \u00e6ndrer sig over tid, og tre forskellige chatagenter, der hver is\u00e6r skal kunne h\u00e5ndtere b\u00e5de generelle og dom\u00e6nespecifikke sp\u00f8rgsm\u00e5l. Hvis jeg skulle fine-tune, skulle jeg gentage processen hver gang jeg opdaterer viden, og det giver ikke mening i mit setup.</p> <p>Det blev derfor tydeligere for mig, at fine-tuning ikke rigtig l\u00f8ser det behov jeg har. Til geng\u00e6ld kan jeg godt bruge few-shot prompting til at styre stil og svar uden at skulle tr\u00e6ne modellen.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/RAG%20VS.%20Finetuning/#relevans-for-de-tre-agenter-i-projektet","title":"\ud83e\ude7a Relevans for de tre agenter i projektet","text":"<p>N\u00e5r jeg kobler RAG og fine-tuning sammen med mine konkrete scenarier, giver det her billede:</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/RAG%20VS.%20Finetuning/#1-sundhedsagenten","title":"1) Sundhedsagenten","text":"<p>Skal kunne tr\u00e6kke korrekt viden fra mange tekster. Det er helt oplagt at bruge RAG her, s\u00e5 svarene bygger p\u00e5 dokumenterne og ikke p\u00e5 modellens egne g\u00e6t.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/RAG%20VS.%20Finetuning/#2-den-halvspecialiserede-agent","title":"2) Den halvspecialiserede agent","text":"<p>Fx til velv\u00e6re, coaching eller lignende. Her kan jeg genbruge RAG-modellen og bare tilf\u00f8je nye dokumenter.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/RAG%20VS.%20Finetuning/#3-navigationsagenten-den-jeg-selv-har-ansvar-for","title":"3) Navigationsagenten (den jeg selv har ansvar for)","text":"<p>Denne agent skal kunne pege brugeren rundt p\u00e5 siden og forklare indholdet. Teksterne vil \u00e6ndre sig l\u00f8bende, og derfor er RAG langt mere fleksibel end fine-tuning.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/RAG%20VS.%20Finetuning/#min-egen-konklusion","title":"\ud83c\udfaf Min egen konklusion","text":"<p>Efter at have arbejdet med begge metoder \u2013 og is\u00e6r efter at have implementeret dele af RAG selv \u2013 giver det mest mening at forts\u00e6tte p\u00e5 den vej. Fine-tuning virker som en st\u00f8rre og tungere proces, og den l\u00f8ser ikke noget, jeg ikke allerede kan g\u00f8re med:</p> <ul> <li> <p>RAG</p> </li> <li> <p>f\u00e5-shot prompts</p> </li> <li> <p>god kontekst</p> </li> <li> <p>embeddings</p> </li> <li> <p>og opdaterbare dokumenter</p> </li> </ul> <p>Derfor giver RAG mest mening til alle tre agenttyper i projektet, og det er ogs\u00e5 den tilgang jeg forts\u00e6tter med i mit Python-projekt.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/Tokenisering%20og%20tr%C3%A6ning/","title":"L\u00e6ringsside \u2013 Uddybning til Etape 3 (Tokenisering &amp; Modeltr\u00e6ning)","text":"<p>Denne side uddyber de begreber du kort n\u00e6vner i blogindl\u00e6gget. Den kan bruges som \u201cekstra forklaring\u201d til dig selv eller som bilag, hvis nogen skal forst\u00e5 l\u00e6ringen bag.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/Tokenisering%20og%20tr%C3%A6ning/#hvad-er-tokenisering-og-hvorfor-er-det-vigtigt","title":"\ud83e\udde9 Hvad er tokenisering \u2013 og hvorfor er det vigtigt?","text":"<p>Tokenisering er processen hvor tekst bliver opdelt i mindre enheder, der kaldes tokens. Modellerne arbejder ikke med ord som vi kender dem, men med talr\u00e6kker som repr\u00e6senterer tokens.</p> <p>Eksempel: Ordet \u201dsunhedstilstand\u201d kan blive delt i flere tokens:</p> <ul> <li> <p>sund</p> </li> <li> <p>hed</p> </li> <li> <p>stil</p> </li> <li> <p>stand</p> </li> </ul> <p>Dette afh\u00e6nger af den algoritme modellen bruger.</p> <p>Tokenisering er vigtig fordi:</p> <ul> <li> <p>den bestemmer hvordan modellen forst\u00e5r tekst</p> </li> <li> <p>den p\u00e5virker pris (flere tokens = dyrere)</p> </li> <li> <p>den p\u00e5virker kvalitet (fagtermer \u2192 bedre eller d\u00e5rligere delt)</p> </li> <li> <p>den p\u00e5virker pr\u00e6cision, is\u00e6r i sundhedsdata</p> </li> </ul>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/Tokenisering%20og%20tr%C3%A6ning/#byte-pair-encoding-bpe","title":"\ud83d\udd27 Byte Pair Encoding (BPE)","text":"<p>En af de mest brugte algoritmer.</p> <p>Princip: Start med helt sm\u00e5 enheder (bogstaver), og sl\u00e5 de kombinationer sammen der forekommer oftest.</p> <p>Fordele:</p> <ul> <li> <p>effektiv til mange sprog</p> </li> <li> <p>h\u00e5ndterer nye ord godt</p> </li> <li> <p>bruges i GPT, Claude, DeepSeek, Llama</p> </li> </ul> <p>Ulemper:</p> <ul> <li>faglige ord kan blive delt meget, hvilket g\u00f8r dem sv\u00e6rere for modellen</li> </ul>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/Tokenisering%20og%20tr%C3%A6ning/#wordpiece","title":"\ud83d\udd27 WordPiece","text":"<p>Anvendes bl.a. af BERT.</p> <p>Princip: Finder subwords baseret p\u00e5 sandsynlighed i tr\u00e6ningsdata.</p> <p>Fordele:</p> <ul> <li> <p>godt til generelle dom\u00e6ner</p> </li> <li> <p>stabil struktur</p> </li> </ul> <p>Ulemper:</p> <ul> <li>medicinske eller sj\u00e6ldne ord splittes ofte ekstremt meget</li> </ul>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/Tokenisering%20og%20tr%C3%A6ning/#sentencepiece","title":"\ud83d\udd27 SentencePiece","text":"<p>En anden tokeniseringsmetode, ofte brugt i open-source modeller.</p> <p>Fordele:</p> <ul> <li> <p>kan arbejde uden mellemrum (\u201cwhitespace-agnostic\u201d)</p> </li> <li> <p>god til ikke-engelske sprog</p> </li> </ul>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/Tokenisering%20og%20tr%C3%A6ning/#hvorfor-bruger-llmer-subwords","title":"\ud83e\udde0 Hvorfor bruger LLM\u2019er subwords?","text":"<p>Modellerne kan ikke l\u00e6re alle ord i alle sprog. Subwords er en l\u00f8sning:</p> <ul> <li> <p>modellen l\u00e6rer stykker af ord</p> </li> <li> <p>kan kombinere dem til nye ord</p> </li> <li> <p>bedre generalisering</p> </li> <li> <p>f\u00e6rre tokens end bogstav-for-bogstav modeller</p> </li> </ul> <p>For sundhedsdom\u00e6net betyder det:</p> <ul> <li> <p>nogle modeller forst\u00e5r medicinske ord bedre end andre</p> </li> <li> <p>ord som \u201cbetahistine\u201d eller \u201clabyrintitis\u201d kan v\u00e6re \u00e9t token eller fem</p> </li> <li> <p>dette p\u00e5virker forst\u00e5elsen i en chatbot</p> </li> </ul>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/Tokenisering%20og%20tr%C3%A6ning/#hvordan-pavirker-tokenisering-modeltrning","title":"\ud83d\udd2c Hvordan p\u00e5virker tokenisering modeltr\u00e6ning?","text":"<p>N\u00e5r en model tr\u00e6nes, l\u00e6rer den m\u00f8nstre baseret p\u00e5 tokens, ikke ord.</p> <p>Hvis et vigtigt ord bliver delt op i mange subwords, s\u00e5 skal modellen:</p> <ul> <li> <p>l\u00e6re m\u00f8nstre mellem flere tokens</p> </li> <li> <p>bruge mere kontekst</p> </li> <li> <p>bruge flere ressourcer</p> </li> <li> <p>har st\u00f8rre risiko for at misforst\u00e5 sammenh\u00e6nge</p> </li> </ul> <p>\u2192 Derfor er nogle modeller bedre til sundhedsdata end andre.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/Tokenisering%20og%20tr%C3%A6ning/#tokenisering-og-pris","title":"\ud83d\udcb8 Tokenisering og pris","text":"<p>Hvis du bruger API-modeller (OpenAI, Claude osv.):</p> <ul> <li> <p>pris beregnes per token</p> </li> <li> <p>flere subwords = dyrere</p> </li> <li> <p>lange ord \u2192 dyre forkerte modeller</p> </li> </ul> <p>OpenAI og Claude kan v\u00e6re dyrere, fordi deres tokenizers splitter dansk + medicinsk tekst mere aggressivt.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/Tokenisering%20og%20tr%C3%A6ning/#hvorfor-forskellige-modeller-giver-forskellige-resultater","title":"\ud83c\udd9a Hvorfor forskellige modeller giver forskellige resultater","text":"<p>Din blog n\u00e6vner forskelle mellem modeller.</p> <p>Tokenisering spiller en rolle fordi:</p> <ul> <li> <p>modeller er tr\u00e6net p\u00e5 forskellige typer data</p> </li> <li> <p>deres tokenizere er optimeret til forskellige sprog</p> </li> <li> <p>subword-logikken p\u00e5virker hvordan de \u201cforst\u00e5r\u201d fagtermer</p> </li> <li> <p>encoder-modeller og decoder-modeller bruger nogle gange forskellige tokenizers</p> </li> </ul> <p>Dette forklarer hvorfor:</p> <ul> <li> <p>nogle modeller er bedre til dansk</p> </li> <li> <p>nogle er bedre til medicinske termer</p> </li> <li> <p>nogle er bedre til komplekse brugerbeskeder</p> </li> <li> <p>prisen \u00e6ndrer sig fra model til model</p> </li> </ul>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/Tokenisering%20og%20tr%C3%A6ning/#relevans-for-dit-sundhedsprojekt","title":"\ud83e\ude7a Relevans for dit sundhedsprojekt","text":"<p>N\u00e5r du bygger chatagenter der skal h\u00e5ndtere sundhedsindhold, skal du v\u00e6re opm\u00e6rksom p\u00e5:</p> <ol> <li> <p>Hvilken tokenizer modellen bruger     \u2192 p\u00e5virker forst\u00e5else af medicinske ord.</p> </li> <li> <p>Hvor mange tokens der bruges     \u2192 p\u00e5virker pris og begr\u00e6nsninger i kontekst.</p> </li> <li> <p>Modeltr\u00e6ningen     \u2192 nogle modeller har set mere sundhedsdata end andre.</p> </li> <li> <p>Dokumenternes l\u00e6ngde     \u2192 vigtig ved RAG, hvor tekst chunkes efter tokens.</p> </li> </ol> <p>Alt dette har betydning for pr\u00e6cision og kvalitet i dine chatagenter.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/Tokenisering%20og%20tr%C3%A6ning/#denne-lringsside-matcher-direkte-til","title":"\u2714\ufe0f Denne l\u00e6ringsside matcher direkte til:","text":"<p>\u201cM\u00e5l for etapen\u201d \u2192 du \u00f8nskede at g\u00e5 dybere i forst\u00e5elsen af tokenisering og modeltr\u00e6ning.</p> <p>\u201cHvad jeg l\u00e6rte\u201d \u2192 du n\u00e6vnte BPE, WordPiece og subwords \u2014 her er uddybningen af det.</p> <p>\u201cRefleksioner\u201d \u2192 forskelle mellem modeller, forst\u00e5else af sundhedsdata, og hvad det betyder i praksis.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/Tokenisering%20og%20tr%C3%A6ning/#hvordan-laver-den-chunks-kort-svar","title":"\ud83e\udde9 Hvordan laver den chunks? (kort svar)","text":"<p>Den tager lange tekster og deler dem op i mindre stykker, typisk:</p> <ul> <li> <p>300\u2013500 ord</p> </li> <li> <p>klippet ved punktummer</p> </li> <li> <p>aldrig tilf\u00e6ldigt</p> </li> <li> <p>men det er simpel splitting</p> </li> </ul> <p>Form\u00e5let: \u2714 g\u00f8re teksterne nemmere at embedde \u2714 g\u00f8re s\u00f8gning mere pr\u00e6cis \u2714 undg\u00e5 for store embeddings</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/Tokenisering%20og%20tr%C3%A6ning/#hvad-er-en-embedding-super-kort","title":"\ud83e\udde9 Hvad er en embedding? (super kort)","text":"<p>En embedding er:</p> <p>\u27a1\ufe0f en liste af tal som repr\u00e6senterer meningen i teksten fx:</p> <p><code>[0.12, -0.55, 0.87, ...]  (384 tal)</code></p> <p>Det er IKKE ord Det er IKKE tokens Det er betydning.</p>"},{"location":"AI-ML/AI-ML-forst%C3%A5else/Tokenisering%20og%20tr%C3%A6ning/#hvad-er-en-vektor-endnu-kortere","title":"\ud83e\udde9 Hvad er en vektor? (endnu kortere)","text":"<p>En embedding er en vektor.</p> <p>S\u00e5:</p> <ul> <li> <p>Embedding = betydningsvector</p> </li> <li> <p>Vector = talr\u00e6kke der kan bruges i matematisk s\u00f8gning</p> </li> </ul> <p>FAISS bruger disse vektorer til:</p> <p>\u27a1\ufe0f finde de tekststykker som ligner mest din query.</p>"},{"location":"AI-ML/projekter/","title":"Oversigt","text":"<p>Dette er sektionen.</p>"},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/","title":"**Beskrivelse af agent","text":"<p>M\u00e5let med projektet er at udvikle en intelligent guide-agent til websitet The Way of Coherence. Botten skal ikke v\u00e6re en generel chatbot, men en fokuseret assistent**, der kun bruger indholdet fra hjemmesiden til at hj\u00e6lpe brugeren med at navigere, finde artikler og forst\u00e5 centrale temaer omkring heling og nervesystemet.</p> <p>Projektet bygger p\u00e5 en kombination af og er en videreudvikling af [[Chatbot test 5 Fra chatbot p\u00e5 vej mod agent - Foundation spikeprojekt med RAG &amp; Ekstern LLM]]:</p> <ul> <li>RAG (Retrieval-Augmented Generation)</li> <li>OpenAI\u2019s GPT-model</li> <li>egen vektordatabase baseret p\u00e5 FAISS</li> <li>embedding-model til tekstforst\u00e5else</li> <li>stramme regler for tone, adf\u00e6rd og begr\u00e6nsninger</li> </ul> <p>Planen er:</p> <ol> <li> <p>At hente sidens tekster, splitte dem op i mindre chunks og lagre dem som embeddings.</p> </li> <li> <p>At lade et Python-backend API hente relevante tekststykker baseret p\u00e5 brugerens sp\u00f8rgsm\u00e5l.</p> </li> <li> <p>At give AI-modellen pr\u00e6cise instruktioner om tone, stil og begr\u00e6nsninger, s\u00e5 svarene passer til hjemmesidens budskab.</p> </li> <li> <p>At sikre, at botten ikke hallucinerer, men i stedet svarer venligt og guider brugeren, hvis noget ikke findes i dokumentationen.</p> <ol> <li> <p>At implementere fallback-logik:</p> </li> <li> <p>Off-topic</p> </li> <li> <p>For brede sp\u00f8rgsm\u00e5l</p> </li> <li> <p>Medicinske sp\u00f8rgsm\u00e5l</p> </li> <li> <p>Sm\u00e5snak</p> </li> <li> <p>Ukendt indhold</p> </li> </ol> </li> <li> <p>At g\u00f8re l\u00f8sningen klar til senere at kunne kobles p\u00e5 en UI-widget p\u00e5 hjemmesiden.</p> </li> </ol> <p>Vi har lavet vores chunks og embeddings i det forrige projekt og Vi havde vores rag_engine.py fil i [[Chatbot test 5 Fra chatbot p\u00e5 vej mod agent - Foundation spikeprojekt med RAG &amp; Ekstern LLM]] som jeg her vil \u00e6ndre til at passe til den endelige version af prototype chatbotten.  ![[Pasted image 20251127003344.png]] \u201d**</p>"},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/#1-prompt-builder-hvordan-botten-taler","title":"1. PROMPT BUILDER \u2014 \u201cHvordan botten taler\u201d","text":"<p>Dette handler om TONEN, ROLLERNE, HVAD den m\u00e5 og ikke m\u00e5, og hvordan hele prompten bygges.</p> <p>H\u00f8rer til build_prompt():</p>"},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/#indeholder","title":"Indeholder:","text":"<ul> <li> <p>tone: rolig, empatisk, menneskelig</p> </li> <li> <p>rolle: \u201cdu er en guide p\u00e5 The Way of Coherence\u201d</p> </li> <li> <p>regler:</p> <ul> <li> <p>ingen medicinske diagnoser/dosering</p> </li> <li> <p>brug KUN konteksten</p> </li> <li> <p>sig \u00e6rligt hvis noget mangler</p> </li> <li> <p>hold dig til nervesystem, mildhed, heling, selvomsorg</p> </li> </ul> </li> <li> <p>brug context_text</p> </li> <li> <p>gener\u00e9r et venligt, kort svar</p> </li> </ul>"},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/#formal","title":"Form\u00e5l:","text":"<p>Styre botten sprogligt og adf\u00e6rdsm\u00e6ssigt  g\u00f8re den \u201cThe Way of Coherence\u201d-agtig  sikre at botten ikke hallucinerer</p> <p>\u201cPrompt builderen bestemmer hvordan botten taler og m\u00e5den hvorp\u00e5 svaret bliver givet,men ikke hvad den svarer pr\u00e6cist.\u201d</p>"},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/#2-klassifikation-hvilken-type-sprgsmal-er-dette","title":"2. KLASSIFIKATION \u2014 \u201cHvilken type sp\u00f8rgsm\u00e5l er dette?\u201d","text":"<p>Dette er funktionen classify_query(query).</p> <p>Den analyserer kun sp\u00f8rgsm\u00e5let. Ingen AI. Kun simple if-regler.</p> <p>![[Pasted image 20251128121251.png]]</p>"},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/#indeholder_1","title":"Indeholder:","text":"<ul> <li>nonsense \u2192 for korte sp\u00f8rgsm\u00e5l (\u201c??\u201d eller 1 tegn)</li> <li>smalltalk \u2192 \u201chej\u201d, \u201chvem er du\u201d, \u201chvad kan du\u201d</li> <li>medical \u2192 diagnose, dosering, medicinord</li> <li>off_topic \u2192 ikke relatere til site</li> <li>normal \u2192 alt andet</li> </ul> <p>![[Pasted image 20251128121515.png]]</p> <p>i ovenst\u00e5ende billede bliver de hvert topic defineret udfra hvad der vil falde i den kategori og udl\u00f8se at agenten opfatter det som v\u00e6rende fx. smalltalk eller medicinsk indhold. Hvilket afleder dens reaktions m\u00f8nster og svar generering.</p>"},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/#formal_1","title":"Form\u00e5l:","text":"<p>Bestemme hvilken kategori sp\u00f8rgsm\u00e5let tilh\u00f8rer Stoppe farlige eller irrelevante sp\u00f8rgsm\u00e5l tidligt  Beslutte om vi skal bruge fallback eller sende videre til RAG</p> <p>\u201cKlassifikationen beslutter om botten m\u00e5 besvare sp\u00f8rgsm\u00e5let, og hvilken type svar der er passende.\u201d</p>"},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/#3-fallback-system-hvad-svarer-vi-hvis-vi-ikke-kan-bruge-rag","title":"3. FALLBACK SYSTEM \u2014 \u201cHvad svarer vi, hvis vi ikke kan bruge RAG?\u201d","text":"<p>Dette er funktionen handle_fallback(query, category).</p> <p>Den bruges n\u00e5r:</p> <ul> <li>sp\u00f8rgsm\u00e5let er nonsens</li> <li>smalltalk</li> <li>medicinsk</li> <li>off-topic</li> <li>eller hvis RAG ingen relevante dokumenter fandt</li> </ul>"},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/#indeholder_2","title":"Indeholder:","text":"<ul> <li>standard-svar til nonsense</li> <li>venlig hilsen til smalltalk</li> <li>medicinsk afvisning</li> <li>off-topic svar (send brugeren tilbage til sidens tema)</li> <li> </li> </ul> <p>![[Pasted image 20251128121814.png]]</p>"},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/#fallbackfallback-hvis-noget-helt-uventet-sker","title":"fallback\u2192fallback hvis noget helt uventet sker","text":""},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/#formal_2","title":"Form\u00e5l:","text":"<p>At give sikre, venlige, afgr\u00e6nsede svar  ERSTATTER RAG/LLM n\u00e5r sp\u00f8rgsm\u00e5let ikke er relevant  Giver botten \u201ckundeservice\u201d-opf\u00f8rsel</p>"},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/#kort-forklaring","title":"Kort forklaring:","text":"<p>\u201cFallback-systemet bestemmer hvilket standardsvar brugeren f\u00e5r, n\u00e5r botten ikke m\u00e5 bruge indholdet.\u201d</p> <p>Under \"Fallback systemet\" har jeg ogs\u00e5 implmenteret et \"safety layer\" ![[Pasted image 20251128142320.png]] Denne del af koden er et \u2019safety layer\u2019. Hvis RAG ikke finder nogen relevante dokumenter, springer vi AI\u2019en over og returnerer et sikkert, manuelt fallback-svar. Det forhindrer hallucinationer og g\u00f8r oplevelsen mere stabil. Det h\u00f8rer derfor ikke under prompt-builderen eller rolle-instrukserne, men under systemets overordnede sikkerheds- og fallback-logik</p>"},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/#sikkerhedslag","title":"sikkerhedslag","text":"<p>Systemet bruger to sikkerhedslag f\u00f8r AI\u2019en f\u00e5r lov at svare. F\u00f8rst klassificerer vi sp\u00f8rgsm\u00e5let (smalltalk, medicinsk, nonsense eller normal). Hvis det ikke er \u201cnormal\u201d, stopper vi og giver et special-fallback. Hvis det er normalt, men RAG ikke finder dokumenter, giver vi et sikkert fallback-svar. Kun n\u00e5r begge tests er best\u00e5et, bygger vi prompten og sender sp\u00f8rgsm\u00e5let til AI\u2019en.</p> <p>Her g\u00f8r funktionen det helt grundl\u00e6ggende arbejde med at styre, hvordan der skal svares. F\u00f8rst bliver sp\u00f8rgsm\u00e5let vurderet for at se, om det er smalltalk, medicinsk, off-topic eller bare nonsens. Hvis det falder i en af de kategorier, g\u00e5r funktionen straks i fallback-mode og returnerer et sikkert, manuelt skrevet svar i stedet for at bruge AI. Derfor bliver OpenAI-delen helt sprunget over, og dokumenterne bliver heller ikke brugt.</p> <p>Hvis sp\u00f8rgsm\u00e5let er normalt, forts\u00e6tter funktionen til n\u00e6ste trin, hvor systemet filtrerer dokumenterne efter relevans. Her bruges en threshold-v\u00e6rdi, som betyder at kun dokumenter med en lav afstand (alts\u00e5 god match) bliver beholdt. De r\u00e5 FAISS-resultater bliver gemt i docs_before, og de filtrerede i docs_after. Hvis der ikke er nogen dokumenter tilbage efter filteret, v\u00e6lges fallback-svaret igen, s\u00e5 brugeren f\u00e5r en venlig besked om at der ikke findes noget pr\u00e6cist match.</p> <p>Kun hvis sp\u00f8rgsm\u00e5let er normalt og der findes relevante dokumenter efter filteret, bliver der bygget en prompt og sendt et kald til OpenAI. Resultatet bliver derefter returneret som AI-svar. P\u00e5 den m\u00e5de styrer funktionen om der skal faldes tilbage til et sikkert standardsvar, eller om AI\u2019en skal bruges, og den s\u00f8rger for at kun dokumenter med reel relevans bliver sendt videre.</p>"},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/#rate-limit","title":"Rate-limit","text":"<p>Denne funktion st\u00e5r for selve kaldet til OpenAI-modellen, og den indeholder en lille indbygget beskyttelse mod rate-limit fejl. F\u00f8rst fors\u00f8ger den at sende foresp\u00f8rgslen normalt. Hvis OpenAI svarer med en rate-limit fejl, betyder det, at der er sendt for mange kald p\u00e5 kort tid. I stedet for at lade systemet crashe, venter funktionen et \u00f8jeblik og pr\u00f8ver automatisk igen. Det g\u00f8r integrationen mere stabil og sikrer, at brugeren stadig f\u00e5r et svar, selv n\u00e5r OpenAI er presset.</p> <p>Video gennemgang af agenten.</p>"},{"location":"AI-ML/projekter/Chatbot%206%20-%20Implementation%20af%20Agent%20prototype%20i%20swagger/#hvorfor-vi-nu-har-en-agent-og-ikke-lngere-en-chatbot","title":"Hvorfor vi nu har en agent (og ikke l\u00e6ngere en chatbot)","text":"<p>I de tidligere versioner af systemet fungerede l\u00f8sningen som en klassisk chatbot. Modellen reagerede direkte p\u00e5 brugerens input, og svaret blev alene styret af rolle-prompting og kontekst. Systemet tog ingen selvst\u00e6ndige beslutninger \u2013 det genererede blot tekst baseret p\u00e5 det prompt, vi sendte. Det er kendetegnende for en almindelig chatbot: \u00e9n pipeline, ingen valg, ingen kontrol.</p> <p>I det sidste projekt \u00e6ndrede vi arkitekturen fundamentalt. Vi indf\u00f8rte et beslutningslag, hvor systemet selv tager stilling til, hvordan et sp\u00f8rgsm\u00e5l skal behandles. Sp\u00f8rgsm\u00e5let bliver f\u00f8rst klassificeret (normal, smalltalk, medicinsk, off-topic eller nonsense). Denne vurdering styrer straks, om AI\u2019en overhovedet m\u00e5 bruges. Hvis henvendelsen ikke er \u201cnormal\u201d, stopper systemet automatisk den generative model og returnerer et sikkert fallback-svar. Dermed har systemet nu autonom logik, der beskytter mod hallucinationer, misforst\u00e5elser og forkerte svar.</p> <p>Dern\u00e6st kontrollerer systemet, om RAG-delen faktisk har fundet relevante dokumenter. Finder vi ingen dokumenter under en bestemt relevanst\u00e6rskel, v\u00e6lger systemet igen et fallback-svar og undlader helt at bruge OpenAI. Det betyder, at modellen ikke l\u00e6ngere styrer outputtet alene; systemet v\u00e6lger selv strategi og beslutter, om AI\u2019en overhovedet m\u00e5 aktiveres.</p> <p>F\u00f8rst n\u00e5r begge kontroller er best\u00e5et \u2013 korrekt kategori og reelt relevant kontekst \u2013 f\u00e5r agenten lov til at bygge en prompt og kalde OpenAI. Det er alts\u00e5 systemet, der styrer hvorn\u00e5r, hvordan og om modellen m\u00e5 bruges. Den generative model er kun \u00e9t v\u00e6rkt\u00f8j, der f\u00f8rst aktiveres efter en r\u00e6kke autonome valg.</p> <p>Det er netop denne evne til at analysere input, v\u00e6lge mellem flere mulige handlingsstrategier og udf\u00f8re forskellige flows, der definerer en AI-agent. Systemet svarer ikke l\u00e6ngere bare \u2013 det tr\u00e6ffer beslutninger.</p>"},{"location":"AI-ML/projekter/Chatbot%20i%20Python%20test%201.%20%28%20Setup%20%26%20in%20memory%20vector%20s%C3%B8gning%29/","title":"Chatbot test 1","text":""},{"location":"AI-ML/projekter/Chatbot%20i%20Python%20test%201.%20%28%20Setup%20%26%20in%20memory%20vector%20s%C3%B8gning%29/#1-mini-projekt-embedding-generator","title":"1) Mini-projekt: Embedding Generator","text":"<p>Form\u00e5l</p> <p>At l\u00e6re hvordan tekst \u2192 embeddings fungerer i praksis.</p> <p>projektet I dette projekt s\u00e6tter jeg et isoleret Python-milj\u00f8 op og anvender SentenceTransformer-modellen all-MiniLM-L6-v2 til at generere embeddings af tekst. En embedding er en talbaseret repr\u00e6sentation af tekst, som modellen bruger til at forst\u00e5 betydning og kontekst. Jeg tester pipeline-ops\u00e6tningen ved at indl\u00e6se modellen, encodere en dansk tekst og udskrive embedding-dimensionen (384) samt de f\u00f8rste v\u00e6rdier. Dette bekr\u00e6fter, at AI-milj\u00f8et fungerer korrekt og er klar til at blive brugt i en vector-database og i et senere RAG-baseret chatbot-system.</p> <p>For at k\u00f8re projektet s\u00e5 laver vi et virtuelt python milj\u00f8 i powershell for at have et arbejdsmilj\u00f8 hvor vi kan afpr\u00f8ve vores projekt. ![[Pasted image 20251124162153.png]]</p> <p>N\u00e5r .venv vises s\u00e5 er milj\u00f8et klart og oppe og k\u00f8re. Her kan vi arbejde med pakker, scripts og konfigurere milj\u00f8et alt efter behov.</p> <p>For at arbejde med huggingface bibliotekkerne sentecetransformer og k\u00f8re det i vores python milj\u00f8, s\u00e5 har jeg opsat et script i vscode, hvor jeg importerer model fra biblioteket og afpr\u00f8ver modellen. Her henter vi modellen \"MiniML-L6-v2\"</p> <p>![[Pasted image 20251124162834.png]]</p> <p>ved at k\u00f8re script filen \"embeddings_setup.py\" s\u00e5 kan vi teste og se modellen der aktivt laver en embedding af en tekst via RAG.  Den omdanner her den korte \"text\" til matematiske vektorer, der vil agere som modellens forst\u00e5else.  ![[Pasted image 20251124163409.png]] f\u00f8rst vises l\u00e6ngden som er en vektor med 384 tal. De f\u00f8rste 10 v\u00e6rdier er et udsnit af de f\u00f8rste 10 v\u00e6rdier, der ligger til grund for modellens forst\u00e5else af teksten..</p> <p>L\u00e6rer dig:</p> <ul> <li>Hvad embeddings er</li> <li>Hvordan SentenceTransformer virker</li> <li>Hvordan Python-moduller importeres</li> <li>Hvordan tekst \u2192 vektor fungerer</li> </ul>"},{"location":"AI-ML/projekter/Chatbot%20i%20Python%20test%201.%20%28%20Setup%20%26%20in%20memory%20vector%20s%C3%B8gning%29/#2-afprvning-af-lokal-model-mini-mini-mini-projekt","title":"**2) afpr\u00f8vning af lokal model (mini, mini, mini projekt)","text":"<p>Jeg startede med at hente en Ollama model til dette projekt for at afpr\u00f8ve en af de lidt st\u00f8rre og meget brugte modeller til offline projekter. ![[Pasted image 20251124164653.png]] Planen her er at teste modellen lokalt.</p> <p>![[Pasted image 20251124164955.png]] F\u00f8rst hentede jeg modellen llama3 og fik den til at k\u00f8re og stillede den et sp\u00f8rgsm\u00e5l og modtog et svar fra modellen. Det er her Ollama, men det kunne liges\u00e5 godt v\u00e6re mistral, eller andre modeller. Der p\u00e5 samme vis kan fungere</p>"},{"location":"AI-ML/projekter/Chatbot%20i%20Python%20test%201.%20%28%20Setup%20%26%20in%20memory%20vector%20s%C3%B8gning%29/#3-mini-projekt-in-memory-vector-search","title":"3) Mini-projekt: In-Memory Vector Search","text":"<p>I f\u00f8rste fors\u00f8g \u00f8nskede jeg at bruge ChromaDB til at indeksere mine embeddings. Under installationen opstod en r\u00e6kke fejl, fordi Chroma kr\u00e6ver C++ build tools og hnswlib-kompilering, hvilket ikke underst\u00f8ttes stabilt p\u00e5 Windows uden avanceret build-milj\u00f8. Derfor valgte jeg at skifte til FAISS, som er en in-memory vektor-s\u00f8gemaskine udviklet af Meta. FAISS kr\u00e6ver ingen kompilering p\u00e5 Windows og fungerer perfekt til l\u00e6ringsform\u00e5l. Dette gjorde det muligt at gennemf\u00f8re projektet og udf\u00f8re semantic search uden problemer. Chroma skulle v\u00e6re mest stabilt over docker og det er derfor relevant at se om det ikke vil fungere fint til den tid n\u00e5r AI delen til projektet skal op og k\u00f8re i en docker container.</p> <p>![[Pasted image 20251124170046.png]] Planen var ellers at importere en model fra \"sentencetransformers\" og via en embedding model gemme i chromaDB.</p> <p>Istedet valgte jeg en anden aproach hvor jeg via FAISS, der fungerer p\u00e5 windows og kan s\u00f8ge og vise en in-memory-search bare uden chromaDB.</p> <p>![[Pasted image 20251124170647.png]] Her importerer vi fra huggingface biblioteket og faiss. Laver noget tekst der skal s\u00f8ges i via \"documents\". Henter transformer model. Laver embeddings af teksterne. Laver et index via FAISS i Ram.  Leder i rammet efter en tekst t\u00e6t p\u00e5 vores foresp\u00f8rgsel. Og faiss returnerer: ![[Pasted image 20251124171213.png]] Her kan vi igens se de 384 dimensioner/tal som modellen omdanner teksten til. Her g\u00f8r den det samme med alle 4 tekster i forhold til de 384 tal i en vektor pr. tal.</p> <p>L\u00e6rer dig:</p> <ul> <li>at oprette en collection</li> <li>tilf\u00f8je tekster</li> <li>s\u00f8ge i embeddings</li> <li>hvad en vektor database g\u00f8r</li> </ul>"},{"location":"AI-ML/projekter/Chatbot%20i%20Python%20test%201.%20%28%20Setup%20%26%20in%20memory%20vector%20s%C3%B8gning%29/#afsluttende-gennemgang-af-mini-projekt-faiss-vector-search","title":"Afsluttende gennemgang af Mini-Projekt: FAISS Vector Search","text":"<p>I dette mini-projekt byggede vi en helt enkel, men fuldt fungerende semantisk s\u00f8gemaskine, der k\u00f8rer lokalt i RAM uden database eller cloud. Form\u00e5let var at forst\u00e5 de grundl\u00e6ggende elementer i vector search, som senere skal bruges i et st\u00f8rre RAG-system.</p>"},{"location":"AI-ML/projekter/Chatbot%20i%20Python%20test%201.%20%28%20Setup%20%26%20in%20memory%20vector%20s%C3%B8gning%29/#1-vi-omdannede-almindelige-stninger-til-embeddings","title":"1. Vi omdannede almindelige s\u00e6tninger til embeddings","text":"<p>Ved hj\u00e6lp af modellen SentenceTransformer (\u201call-MiniLM-L6-v2\u201d) konverterede vi fire korte tekster til vektorer med 384 dimensioner.</p> <p>Det betyder, at hver tekst nu lever som et s\u00e6t tal, der repr\u00e6senterer betydningen af teksten \u2014 ikke ordene.</p> <p>\u2192 Derfor s\u00e5 du output som:</p> <p><code>Embedding shape: (4, 384)</code></p> <p>Dette betyder simpelthen: 4 tekster \u00d7 384 tal hver.</p>"},{"location":"AI-ML/projekter/Chatbot%20i%20Python%20test%201.%20%28%20Setup%20%26%20in%20memory%20vector%20s%C3%B8gning%29/#2-vi-lagde-dem-ind-i-et-faiss-index","title":"2. Vi lagde dem ind i et FAISS-index","text":"<p>FAISS er Meta\u2019s bibliotek til hurtig vector search.</p> <p>Vi byggede et L2-baseret index:</p> <p><code>index = faiss.IndexFlatL2(384) index.add(embeddings)</code></p> <p>Dette index fungerer som et \u201ckartotek\u201d over teksternes betydninger.</p>"},{"location":"AI-ML/projekter/Chatbot%20i%20Python%20test%201.%20%28%20Setup%20%26%20in%20memory%20vector%20s%C3%B8gning%29/#3-vi-sgte-efter-et-sprgsmal","title":"3. Vi s\u00f8gte efter et sp\u00f8rgsm\u00e5l","text":"<p>Du gav prompten:</p> <p>\u201cHow do computers learn?\u201d</p> <p>Det blev ogs\u00e5 omdannet til en embedding og sammenlignet med de 4, vi havde lagret.</p> <p>FAISS fandt de to bedste matches:</p> <p><code>1. Machine learning helps computers learn patterns. (distance: 0.72) 2. AI is transforming the world. (distance: 1.44)</code></p> <p>En lavere distance betyder st\u00f8rre semantisk lighed, derfor blev maskinl\u00e6rings-s\u00e6tningen nummer 1.</p>"},{"location":"AI-ML/projekter/Chatbot%20i%20Python%20test%201.%20%28%20Setup%20%26%20in%20memory%20vector%20s%C3%B8gning%29/#4-hvad-vi-har-lrt-i-dette-projekt","title":"4. Hvad vi har l\u00e6rt i dette projekt","text":"<p>Dette mini-projekt demonstrerer:</p> <ul> <li> <p>hvordan tekst \u2192 embedding fungerer</p> </li> <li> <p>hvordan embeddings kan sammenlignes matematisk</p> </li> <li> <p>hvordan vector search finder relevante tekster ud fra betydning</p> </li> <li> <p>hvordan man bygger en simpel RAG-lignende funktion uden database</p> </li> <li> <p>at alt kan k\u00f8re lokalt uden OpenAI, API-n\u00f8gler eller cloud</p> </li> </ul>"},{"location":"AI-ML/projekter/Chatbot%20i%20Python%20test%201.%20%28%20Setup%20%26%20in%20memory%20vector%20s%C3%B8gning%29/#5-hvorfor-er-dette-vigtigt","title":"5. Hvorfor er dette vigtigt?","text":"<p>FAISS-projektet udg\u00f8r fundamentet for dit kommende:</p> <ul> <li> <p>lokale AI-system</p> </li> <li> <p>dokument-assistent</p> </li> <li> <p>s\u00f8gefunktion til sundhedsplatformen</p> </li> <li> <p>agent-baserede features</p> </li> <li> <p>integration med Llama3 p\u00e5 Ollama</p> </li> <li> <p>(senere) RAG med persistente vektor-databaser</p> </li> </ul> <p>Det er her, du g\u00e5r fra \u201cembedding-demo\u201d \u2192 \u201crigtig AI-arkitektur\u201d.</p> <p>I en kommende docker implementering af cahtbotten, s\u00e5 vil der v\u00e6re et milj\u00f8, der bliver sat op med samme versioner og uden konflikter \"regner jeg med\" s\u00e5 vi der undg\u00e5r de problemer der var under dette projekt med chroma</p>"},{"location":"AI-ML/projekter/Chatbot%20i%20python%20test%202.%20%28Persitens%29/","title":"Persistent Vector Store","text":"<p>Form\u00e5l: At g\u00f8re dine embeddings permanente, s\u00e5 de ikke forsvinder n\u00e5r programmet stopper \u2014 i mods\u00e6tning til Projekt 2, som k\u00f8rte \u201cin-memory\u201d.</p> <p>her vil vi: - FAISS index i RAM - Gemmer index p\u00e5 disk (<code>faiss_index.idx</code>) - Gemmer metadata (teksterne) i JSON (<code>metadata.json</code>) - Loader index igen og kan s\u00f8ge i det</p> <p>Her har jeg valgt efter valg af model. opsat \"faiss_index.idx\" til at v\u00e6re stedet hvor vektor-indexet bliver gemt og \"metadata.json\" til at indeholde tekst-dokumenter.</p> <p>![[Pasted image 20251125001146.png]] Bagefter bliver hvert dokument embedded  til en 384-dimensionel vektor. via modellens encoder. Herefter  bliver filen oprettet eller indl\u00e6st og dokumenter gemmes permanent som i en DB. Herefter er der en test query.</p> <p>![[Pasted image 20251125001204.png]] Efter k\u00f8rsel af scriptet i mit python milj\u00f8, s\u00e5 svarer modellen tilbage p\u00e5 queryen i scriptet.</p> <p>Her f\u00e5r vi et svar ved at modellen opretter en embedding af teksten og g\u00e5r igennem den for at kunne sammenligne dens vektorer fra teksten vi oprettede i scriptet. Den query der bliver embedded og gemt samt brugt i RAM s\u00e5 l\u00e6nge programmet k\u00f8rer. ![[Pasted image 20251125001348.png]] I svaret f\u00e5r vi angivet en afstand, der viser hvor relevant tekst svaret er vurderet til at v\u00e6re. 0.425... som f\u00f8rste svar gengiver er den korteste af de to tekster, men tekst nummer to er stadigv\u00e6k t\u00e6t nok p\u00e5 til at v\u00e6re vurderet af relevans i forhold til min query.</p>"},{"location":"AI-ML/projekter/Chatbot%20i%20python%20test%202.%20%28Persitens%29/#en-rigtig-vector-database-workflow","title":"En rigtig Vector Database Workflow**","text":"<p>Du har i dette projekt vist alle n\u00f8gleelementer i en fuld \u201cretrieval system\u201d-pipeline:</p>"},{"location":"AI-ML/projekter/Chatbot%20i%20python%20test%202.%20%28Persitens%29/#embedding-af-dokumenter","title":"\u2714 Embedding af dokumenter","text":"<p>\u2192 Ved hj\u00e6lp af SentenceTransformer (MiniLM).</p>"},{"location":"AI-ML/projekter/Chatbot%20i%20python%20test%202.%20%28Persitens%29/#gemning-af-embeddings-permanent-pa-disk","title":"\u2714 Gemning af embeddings permanent p\u00e5 disk","text":"<p>\u2192 <code>faiss_index.idx</code> \u2192 <code>metadata.json</code></p>"},{"location":"AI-ML/projekter/Chatbot%20i%20python%20test%202.%20%28Persitens%29/#query-embedding-brugerens-sprgsmal","title":"\u2714 Query-embedding (brugerens sp\u00f8rgsm\u00e5l)","text":"<p>\u2192 Samme embedding-model \u2192 vektor i samme rum.</p>"},{"location":"AI-ML/projekter/Chatbot%20i%20python%20test%202.%20%28Persitens%29/#semantisk-similarity-search-med-faiss","title":"\u2714 Semantisk similarity search med FAISS","text":"<p>\u2192 Finder meningsm\u00e6ssigt relaterede dokumenter.</p>"},{"location":"AI-ML/projekter/Chatbot%20i%20python%20test%202.%20%28Persitens%29/#returnering-af-top-matches-med-distance","title":"\u2714 Returnering af top-matches med distance","text":"<p>\u2192 Afstand fort\u00e6ller relevans.</p> <p>Dette er hele fundamentet for RAG (Retrieval-Augmented Generation).</p>"},{"location":"AI-ML/projekter/Chatbot%20i%20python%20test%202.%20%28Persitens%29/#hvad-du-har-vist-i-dette-mini-projekt","title":"\ud83e\udde9 Hvad du har vist i dette mini-projekt","text":"<p>Du kan nu dokumentere, at du har bygget:</p>"},{"location":"AI-ML/projekter/Chatbot%20i%20python%20test%202.%20%28Persitens%29/#en-fuld-funktionel-persistent-vector-store-med-faiss-inkl-opslag-og-similarity-search","title":"\ud83c\udf93 En fuld funktionel persistent vector store med FAISS, inkl. opslag og similarity search.","text":"<p>Og ikke kun in-memory \u2014 du har:</p> <ul> <li> <p>persistence</p> </li> <li> <p>metadata-mapping</p> </li> <li> <p>query-pipeline</p> </li> <li> <p>semantisk rangerede resultater</p> </li> <li> <p>genindl\u00e6sning mellem sessions</p> </li> <li> <p>en Python-kodebase der ligner en \u201crigtig\u201d RAG back-end</p> </li> </ul>"},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/","title":"Chatbot test 3","text":"<p>M\u00e5let: \u27a1\ufe0f Vi tager de dokument-matches du finder via FAISS \u27a1\ufe0f Vi sender dem ind som kontekst til Llama 3 (via Ollama) \u27a1\ufe0f Modellen genererer et svar baseret p\u00e5 din egen videnbase</p> <p>Dette er f\u00f8rste gang du kobler:</p> <ul> <li> <p>embeddings</p> </li> <li> <p>similarity search</p> </li> <li> <p>RAG prompt</p> </li> <li> <p>en rigtig LLM</p> </li> <li> <p>og returnerer et AI-svar</p> </li> </ul>"},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/#hvad-vi-bygger-nu-super-enkelt-som-trin-1","title":"Hvad vi bygger nu (super enkelt som trin 1):","text":"<p>1\ufe0f\u20e3 Du skriver et sp\u00f8rgsm\u00e5l i terminalen 2\ufe0f\u20e3 Python embedder dit sp\u00f8rgsm\u00e5l 3\ufe0f\u20e3 Python sp\u00f8rger FAISS \u2192 finder top-matches 4\ufe0f\u20e3 Vi bygger en RAG-prompt:</p> <p>\u201cHer er noget relevant kontekst: \u2026 Brug det til at svare p\u00e5 sp\u00f8rgsm\u00e5let \u2026\u201d 5\ufe0f\u20e3 Python kalder Llama 3 via Ollama 6\ufe0f\u20e3 Terminalen viser et rigtigt AI-svar baseret p\u00e5 dine data</p> <p>Til dette projekt har jeg oprettet et nyt script. ![[Pasted image 20251124235219.png]]</p>"},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/#hvad-sker-der-her","title":"Hvad sker der her?","text":"<p>Kort forklaring:</p> <ul> <li> <p>Du loader dit gemte FAISS-index</p> </li> <li> <p>Du loader metadata (dine dokumenter)</p> </li> <li> <p>Du loader embedding-modellen</p> </li> <li> <p>Du opretter en Ollama-client (for at tale med Llama 3)</p> </li> </ul> <p>Vi s\u00f8rger bare for grundstrukturen \u2014 ingen query eller LLM endnu</p> <p>![[Pasted image 20251124235316.png]]# Hvad sker der i Trin 2? (kort forklaret)</p> Trin Hvad sker der? 5 Du skriver et sp\u00f8rgsm\u00e5l i terminalen 6 Query embeddes til en vektor 7 FAISS laver similarity search 8 Systemet sl\u00e5r tekster op i metadata og viser dem <p>Du f\u00e5r nu det samme output som i Projekt 3 \u2014 men denne gang skal vi bruge det videre til RAG.</p> <p>![[Pasted image 20251124235427.png]]</p> <p>Perfekt \u2014 s\u00e5 laver vi Trin 3: Selve RAG-prompten.</p> <p>Dette er den del der forvandler dit retrieval-system til en rigtig AI-assistent, fordi vi nu kombinerer:</p>"},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/#vi-bygger-en-robust-rag-prompt","title":"Vi bygger en robust RAG-prompt","text":"<p>Prompten fort\u00e6ller modellen:</p> <ul> <li> <p>brug kun konteksten</p> </li> <li> <p>v\u00e6r \u00e6rlig hvis konteksten ikke har svaret</p> </li> <li> <p>her er dokumenterne</p> </li> <li> <p>her er sp\u00f8rgsm\u00e5let</p> </li> </ul>"},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/#vi-gr-klar-til-at-sende-prompten-til-llama-3","title":"\u2714 Vi g\u00f8r klar til at sende prompten til Llama 3","text":"<p>![[Pasted image 20251124235545.png]]# Hvad sker der her? (kort og teknisk)</p>"},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/#clientgenerate","title":"\u2714 client.generate(...)","text":"<p>Dette kalder Ollama-serveren p\u00e5:</p> <p><code>http://localhost:11434</code></p> <p>Og sender din RAG-prompt ind i modellen:</p> <ul> <li> <p>Prompten indeholder dine retrieved documents</p> </li> <li> <p>og dit sp\u00f8rgsm\u00e5l</p> </li> </ul>"},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/#modellen-genererer-et-svar","title":"\u2714 Modellen genererer et svar","text":"<p>Llama 3 bruger:</p> <ul> <li> <p>din kontekst (dine dokumenter)</p> </li> <li> <p>og selve sp\u00f8rgsm\u00e5let</p> </li> </ul> <p>til at lave et nyt, kontekstbaseret svar.</p>"},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/#vi-udtrkker-svaret","title":"\u2714 Vi udtr\u00e6kker svaret","text":"<p><code>ai_answer = response['response']</code></p>"},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/#og-printer-det","title":"\u2714 Og printer det","text":"<p>Terminalen viser nu dit f\u00f8rste rigtige RAG-svar.</p> <p>![[Pasted image 20251125001729.png]] Her ses tydeligt at der tages udgangspunkt i vores dokumenter fra [[Chatbot i python test 2. (Persitens)]] Modellen kan nemt besvare sp\u00f8rgsm\u00e5let via teksterne, da det er pr\u00e6cis samme kontekst og vidensomr\u00e5de det omhandler.</p> <p>Jeg testede ogs\u00e5 modellen med et sp\u00f8rgsm\u00e5l der ikke helt giver mening i forhold til de tekster den henter via RAG. og her blev svaret tydeligt p\u00e5virket af modellens egen viden. Her bliver dokumenterne taget med som kontekst, men her er der en langt st\u00f8rre p\u00e5virkning fra anden viden, da det tr\u00e6der lidt ud over de simple teksters kontekst. ![[Pasted image 20251125124725.png]] Denne model fungerer via RAG stadigv\u00e6k med egen fantasi</p>"},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/#teknisk-resume-af-dit-rag-system-projekt-4","title":"Teknisk resume af dit RAG-system (Projekt 4)","text":""},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/#1-dokumenterne-omdannes-til-embeddings","title":"1) Dokumenterne omdannes til embeddings","text":"<ul> <li> <p>Du har nogle sm\u00e5 tekststykker (dine dokumenter).</p> </li> <li> <p>De sendes gennem en embedding-model (MiniLM).</p> </li> <li> <p>Resultatet er vektorer (fx l\u00e6ngde 384), som placeres i en FAISS-database.</p> </li> </ul> <p>Dette g\u00f8r det muligt at sammenligne betydning, ikke ord.</p>"},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/#2-faiss-bruges-til-at-finde-de-mest-relevante-dokumenter","title":"2) FAISS bruges til at finde de mest relevante dokumenter","text":"<p>N\u00e5r du stiller et sp\u00f8rgsm\u00e5l:</p> <p>\u2192 Sp\u00f8rgsm\u00e5let embeddes til en vektor \u2192 FAISS laver vektor-sammenligning (L2 distance) \u2192 De n\u00e6rmeste dokumenter findes (Top-K resultater)</p> <p>Det er dine \"fundne relevante dokumenter\".</p>"},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/#3-disse-dokumenter-sendes-som-kontekst-til-llama3","title":"3) Disse dokumenter sendes som kontekst til Llama3","text":"<p>Dine dokumenter kommer ind f\u00f8r sp\u00f8rgsm\u00e5let:</p> <p>\u201cHer er nogle dokumenter. Brug dem til at svare s\u00e5 godt som muligt.\u201d</p> <p>Det betyder at modellen forst\u00e5r, hvad dit projekt handler om, f\u00f8r den svarer.</p>"},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/#4-modellen-bruger-bade","title":"4) Modellen bruger b\u00e5de:","text":"<ul> <li> <p>Dine dokumenter (RAG-kontekst)</p> </li> <li> <p>Sin egen tr\u00e6ningsviden</p> </li> </ul> <p>RAG p\u00e5virker svaret kraftigt, men modellen supplerer med sin almindelige viden.</p> <p>Derfor f\u00e5r du:</p> <ul> <li> <p>Relevante pointer fra dine dokumenter</p> </li> <li> <p>Ekstra detaljer fra modellens generelle viden</p> </li> </ul>"},{"location":"AI-ML/projekter/Chatbot%20test%203.%20%28RAG%20i%20terminal%29/#5-output-er-et-ai-svar-der-er-forankret-i-dine-dokumenter-men-ikke-begrnset-til-dem","title":"5) Output er et AI-svar, der er forankret i dine dokumenter \u2013 men ikke begr\u00e6nset til dem","text":"<p>Derfor gav dit sp\u00f8rgsm\u00e5l \u201ckan maskinl\u00e6ring hj\u00e6lpe p\u00e5 sundhed?\u201d et langt, rigtigt sundhedssvar:</p> <ul> <li> <p>Dokumenterne gjorde svaret relevant</p> </li> <li> <p>Modellen fyldte selv p\u00e5 med detaljer</p> </li> </ul>"},{"location":"AI-ML/projekter/Chatbot%20test%204%20%28Rest%20API%28Fast%20API%29%20Gateway./","title":"Chatbot test 4","text":""},{"location":"AI-ML/projekter/Chatbot%20test%204%20%28Rest%20API%28Fast%20API%29%20Gateway./#mal-for-projektet","title":"M\u00e5l for projektet","text":"<p>I dette projekt ville jeg bygge et simpelt API-lag (FastAPI) oven p\u00e5 det RAG-system, jeg tidligere lavede i terminalen. Form\u00e5let er at:</p> <ul> <li> <p>lave en rigtig API-gateway</p> </li> <li> <p>afpr\u00f8ve RAG-endpoints</p> </li> <li> <p>bruge testdata</p> </li> <li> <p>bygge en MVP, som klienten (frontend) senere kan kalde</p> </li> <li> <p>forst\u00e5, hvordan embeddings, FAISS og Python API spiller sammen</p> </li> </ul> <p>Dette er endnu et skridt mod den chatbot, der senere skal integreres p\u00e5 hjemmesiden.</p>"},{"location":"AI-ML/projekter/Chatbot%20test%204%20%28Rest%20API%28Fast%20API%29%20Gateway./#1-fastapi-server-mainpy","title":"1. FastAPI-server (main.py)","text":"<p>![[Pasted image 20251125130641.png]] Her opretter jeg f\u00f8rst en main.py fil, der er vores API. (FastAPI-server)</p> <p>ved at k\u00f8re filen i mit python milj\u00f8 i terminalen i VSCode, s\u00e5 kan jeg se at den fungerer og returnerer et svar.. ![[Pasted image 20251125131744.png]] Og den k\u00f8rer live p\u00e5 htttp-adressen ![[Pasted image 20251125131835.png]]</p> <p>Jeg oprettede en lille server, der kan:</p> <ul> <li>k\u00f8re </li> <li>returnere \u201cAPI k\u00f8rer\u201d</li> <li>tage imod queries</li> </ul> <p>Eksempel:</p> <p><code>@app.get(\"/ask\") def ask(query: str):     results = search_docs(query)     return {\"query\": query, \"results\": results}</code></p>"},{"location":"AI-ML/projekter/Chatbot%20test%204%20%28Rest%20API%28Fast%20API%29%20Gateway./#2-rag-motoren-rag_enginepy-kun-retrieval-pa-dette-tidspunkt","title":"2. RAG-motoren (rag_engine.py) \u2013 kun retrieval p\u00e5 dette tidspunkt","text":"<p>I dette projekt returnerer RAG-motoren kun tekstchunks, ikke AI-svar.</p> <p>Flowet:</p> <ol> <li>embed sp\u00f8rgsm\u00e5let</li> <li>find relevante tekststykker i FAISS</li> <li>returner:<ul> <li>tekst</li> <li>kategori</li> <li>titel</li> <li>distance-score</li> </ul> </li> </ol> <p>Dette var en ren \u201cretriever\u201d \u2013 den genererer ikke endnu svar med AI.</p> <p>bagefter laver jeg en ny fil, der skal v\u00e6re chat-endpoint, hvor sp\u00f8rgsm\u00e5l kan stilles til vores model. rag_engine.py.</p> <p>![[Pasted image 20251125140812.png]]</p> <p>derefter udvider jeg main.py med et chat endpoint og importer RAG s\u00f8gning til at gennemg\u00e5 dokumenterne fra [[Chatbot i python test 2. (Persitens)]]  modellen laver similarity search og retrieval via FAISS og returnerer relevante dokumenter den finder via embeddings vi tidligere har lavet. ![[Pasted image 20251125141312.png]]</p> <p>Den kan nu modtage en query og svarer i forhold til dokumenterne ![[Pasted image 20251125141703.png]]</p> <p>Derefter installerer vi Ollama-klienten i milj\u00f8et, der kan kalde Llama-3 modellen. S\u00e5 der kan genereres rigtige ai svar baseret p\u00e5 vores dokumenter. Det bliver oprettet i en ny fil kaldet llm_engine.py ![[Pasted image 20251125144748.png]] Denne del af projektet opretter en ny fil, <code>llm_engine.py</code>, som st\u00e5r for selve AI-genereringen. Her forbinder vi Python-koden med den lokale Llama-3-model via Ollama-klienten.</p> <p>Funktionen <code>generate_answer</code> g\u00f8r tre ting:</p> <ol> <li> <p>Bygger en prompt     \u2013 den samlede prompt bliver sat sammen af:</p> <ul> <li>konteksten (de tekstbidder RAG fandt)</li> <li>brugerens sp\u00f8rgsm\u00e5l</li> <li>en klar rollebeskrivelse (\"du er en hj\u00e6lpsom guide\u2026\")</li> <li>en instruks om kun at bruge den givne kontekst.</li> <li>Sender prompten til Llama-3 \u2013 modellen k\u00f8rer lokalt via Ollama (<code>client.chat</code>) \u2013 prompten sendes som en \u201cuser\u201d-besked \u2013 Llama genererer et svar baseret p\u00e5 vores regler + konteksten.</li> </ul> </li> <li> <p>Returnerer kun selve svaret     \u2013 vi tr\u00e6kker AI-modellens svar ud af JSON-responsen     (<code>response[\"message\"][\"content\"]</code>).</p> </li> </ol> <p>Det betyder, at denne fil for f\u00f8rste gang g\u00f8r systemet i stand til at levere et f\u00e6rdigt, sprogligt formuleret AI-svar baseret p\u00e5 vores egen tekstkontekst.</p> <p>vi \u00e6ndrer nu vores main fil. ![[Pasted image 20251125145612.png]]</p>"},{"location":"AI-ML/projekter/Chatbot%20test%204%20%28Rest%20API%28Fast%20API%29%20Gateway./#hvad-der-sker-her","title":"Hvad der sker her","text":"<p>I <code>main.py</code> binder vi hele RAG-flowet sammen i \u00e9t API-endpoint:</p> <ol> <li> <p>FastAPI modtager brugerens sp\u00f8rgsm\u00e5l     \u2192 <code>query</code> sendes ind i systemet.</p> </li> <li> <p>RAG finder relevante dokumenter <code>search_docs(query)</code> laver embedding-s\u00f8gning i FAISS og returnerer de tekster, der matcher bedst.</p> </li> <li> <p>Vi bygger kontekst til modellen     Alle fundne tekststumper samles til \u00e9n kontekststreng, som vi kan sende til Llama-3.</p> </li> <li> <p>AI\u2019en genererer et svar <code>generate_answer()</code> bruger konteksten + sp\u00f8rgsm\u00e5let til at f\u00e5 Llama-3 (via Ollama) til at lave et f\u00e6rdigt svar.</p> </li> <li> <p>Vi returnerer samlet resultat     \u2013 sp\u00f8rgsm\u00e5let     \u2013 AI-svaret     \u2013 og de dokumenter, der blev brugt som kilder.</p> </li> </ol> <p>![[Pasted image 20251125145541.png]]</p>"},{"location":"AI-ML/projekter/Chatbot%20test%204%20%28Rest%20API%28Fast%20API%29%20Gateway./#hvad-man-ser-i-outputtet","title":"Hvad man ser i outputtet","text":"<p>Her kan vi se det f\u00e6rdige resultat af hele chat-flowet:</p> <ol> <li><code>query</code> \u2192 det sp\u00f8rgsm\u00e5l brugeren stillede.</li> <li><code>answer</code> \u2192 det svar som Llama-modellen genererede, baseret udelukkende p\u00e5 konteksten fra vores tekster.</li> <li><code>sources</code> \u2192 de tekststykker fra FAISS, som systemet fandt mest relevante.<ul> <li>hver kilde har b\u00e5de tekst og en distance-score</li> <li>en lav distance betyder, at teksten minder meget om brugerens sp\u00f8rgsm\u00e5l.</li> </ul> </li> </ol> <p>Det viser, at systemet laver en fuld RAG-proces: retrieval af tekster \u2192 byggede kontekst \u2192 AI-svar \u2192 returner kildeteksterne.</p>"},{"location":"AI-ML/projekter/Chatbot%20test%204%20%28Rest%20API%28Fast%20API%29%20Gateway./#hvad-projekt-4-lrte-mig","title":"Hvad projekt 4 l\u00e6rte mig","text":"<p>(teknisk, pr\u00e6cist og baseret p\u00e5 det du faktisk lavede)</p> <p>I dette projekt arbejdede jeg videre p\u00e5 de tidlige tests, men nu med fokus p\u00e5 at bygge det f\u00f8rste rigtige chat-endpoint, der kombinerer:</p> <ul> <li> <p>simpel RAG-s\u00f8gning</p> </li> <li> <p>FastAPI</p> </li> <li> <p>FAISS</p> </li> <li> <p>og for f\u00f8rste gang: integration med en generativ AI-model (Llama via Ollama)</p> </li> <li>En simpel systemprompt og let rollebeskrivelse og prompt-template</li> </ul> <p>Selvom jeg stadig brugte sm\u00e5 testdata, l\u00e6rte jeg flere vigtige ting teknisk</p>"},{"location":"AI-ML/projekter/Chatbot%20test%205%20Fra%20chatbot%20p%C3%A5%20vej%20mod%20agent%20-%20Foundation%20spikeprojekt%20med%20RAG%20%26%20Ekstern%20LLM/","title":"Chatbot test 5 Fra chatbot p\u00e5 vej mod agent   Foundation spikeprojekt med RAG & Ekstern LLM","text":"<p>Her bygges videre p\u00e5 det der er l\u00e6rt i de tidligere projekter og henimod den endelige bot til hjemmesiden.</p> <p>Jeg vil arbejde videre med nogen af de skabeloner jeg lavede i tidligere projekter, is\u00e6r i [[Chatbot test 4 (Rest API(Fast API) Gateway.]]  og bruge dette som kontekst og inspiration og f\u00f8lge min l\u00e6ring fra disse projekter.</p> <p>Derudover skifter jeg for f\u00f8rste gang fra testdata \u2192 rigtige tekster fra The Way of Coherence.</p>"},{"location":"AI-ML/projekter/Chatbot%20test%205%20Fra%20chatbot%20p%C3%A5%20vej%20mod%20agent%20-%20Foundation%20spikeprojekt%20med%20RAG%20%26%20Ekstern%20LLM/#1-relevant-data-hentning-chunking-og-embedding","title":"1. relevant data hentning, chunking og embedding.","text":"<p>Jeg startede med at hente html indholdet fra den originale side www.thewayofcoherence.com og ekstrahere teksten fra siderne og renset det via AI. Jeg har hentet en r\u00e6kke blog indl\u00e6g og informationer som about, consultation, contact mv. De er hentet i HTML format og det er derefter blevet struktureret i et json-objekt p\u00e5 f\u00f8lgende m\u00e5de.</p> <p>![[Pasted image 20251125174337.png]]</p> <p>bagefter sakl vi lave vores embeddings og vector index via:</p> <ul> <li> <p>Chunking     \u2013 lange tekster deles i mindre bidder (fx 200\u2013300 ord).     \u2192 det g\u00f8r s\u00f8gningen mere pr\u00e6cis.</p> </li> <li> <p>Embeddings     \u2013 hver chunk bliver til et tal-vektor-aftryk (384 tal).     \u2192 modellen kan beregne, hvad der ligner hinanden.</p> </li> <li> <p>FAISS index     \u2013 en lokal database, der kan finde de mest relevante stykker tekst     \u2192 bruges til RAG f\u00f8r vi sp\u00f8rger modellen.</p> </li> </ul> <p>Jeg oprettede derfor en ny python fil kaldet build_vector_store.py</p> <p>![[Pasted image 20251126000552.png]] Modellen laver her chunks af teksten og laver dem derefter om til vektor og laver embeddings ud af chunks delene af teksten.</p> <p>Der bliver herefter oprettet et FAISS-Index hvor alle embeddings bliver lagt ind og der kan s\u00f8ges i dem ved queries. Det bliver herefter gemt lokalt.</p>"},{"location":"AI-ML/projekter/Chatbot%20test%205%20Fra%20chatbot%20p%C3%A5%20vej%20mod%20agent%20-%20Foundation%20spikeprojekt%20med%20RAG%20%26%20Ekstern%20LLM/#vector_storebin","title":"<code>vector_store.bin</code>","text":"<p>\u2192 selve embeddings-s\u00f8gemaskinen</p>"},{"location":"AI-ML/projekter/Chatbot%20test%205%20Fra%20chatbot%20p%C3%A5%20vej%20mod%20agent%20-%20Foundation%20spikeprojekt%20med%20RAG%20%26%20Ekstern%20LLM/#vector_store_docsnpy","title":"<code>vector_store_docs.npy</code>","text":"<p>\u2192 metadata (title, kategori, selve chunket)</p> <p>Dette g\u00f8r, at:</p> <p>\u2714 Serveren kan genstarte uden at miste data \u2714 Du kan loade indexet direkte i FastAPI \u2714 Du beh\u00f8ver ikke lave embeddings hver gang</p> <p>Ved k\u00f8rsel af filen build_vector_store.py s\u00e5 bliver datas\u00e6ttet lavet til 28 chunks. ![[Pasted image 20251127155330.png]]</p> <p>Der er nu bygget en fuld RAG-motor med chunking, embeddings og FAISS. N\u00e6ste skridt er at forbinde denne motor til OpenAI og bygge den faktiske chatbot-adf\u00e6rd (guiding, forslag, svar, handlinger).\u201d</p> <p>Den nuv\u00e6rende rag_engine.py st\u00e5r p\u00e5 nuv\u00e6rende tidspunkt for at h\u00e5ndtere RAG med lokalt AI genereret svar, dog uden prompt builder og derfor skal vi have tilf\u00f8jet rolle til at styre dens agering og svar til brugeren.</p> <p>![[Pasted image 20251126115026.png]]</p> <p>Her har vi nu en skabelonen til en mere relevant chatbot, der kan l\u00e6se de relevante chunks, forst\u00e5 dem, formulere et kort svar ud fra disse og guide p\u00e5 siden. Det bliver til Retriever \u2192 Prompt Builder \u2192 Generator. Det er ren RAG-arkitektur.</p> <p><code>rag_engine.py</code> blev udvidet, s\u00e5 den ikke kun h\u00e5ndterer vektors\u00f8gning (FAISS), men ogs\u00e5 selve AI-svaret. Den oprindelige version fungerede som en ren \u201cretriever\u201d, der ud fra embeddings og FAISS-index kun returnerede relevante tekst-chunks fra hjemmesiden. For at g\u00f8re systemet til en egentlig chatbot blev der tilf\u00f8jet:</p> <ul> <li>en promptsamler (<code>build_prompt</code>)</li> <li>en kald-funktion til Llama via Ollama (<code>generate_ai_answer</code>)</li> </ul> <p>Disse to komponenter bygger den n\u00f8dvendige sammenh\u00e6ng mellem RAG-s\u00f8geresultaterne og den generative model. Search-funktionen er u\u00e6ndret og st\u00e5r fortsat kun for retrieval.</p> <p>Vi \u00e6ndrer main.py, s\u00e5:</p> <ol> <li> <p>Brugeren sender et sp\u00f8rgsm\u00e5l</p> </li> <li> <p>API\u2019en s\u00f8ger i FAISS</p> </li> <li> <p>Llama f\u00e5r kontekst</p> </li> <li> <p>Llama returnerer et kort guidesvar</p> </li> <li> <p>API\u2019en returnerer b\u00e5de AI-svar og kontekstdokumenter</p> </li> </ol> <p>Vi tager det stille og roligt</p> <p>![[Pasted image 20251126115608.png]]</p>"},{"location":"AI-ML/projekter/Chatbot%20test%205%20Fra%20chatbot%20p%C3%A5%20vej%20mod%20agent%20-%20Foundation%20spikeprojekt%20med%20RAG%20%26%20Ekstern%20LLM/#hvad-denne-version-nu-gr","title":"Hvad denne version nu g\u00f8r","text":"<p>\u26a1 Brugeren sp\u00f8rger \u2192 http://localhost:8000/ask?query=noget</p> <p>API\u2019en g\u00f8r:</p>"},{"location":"AI-ML/projekter/Chatbot%20test%205%20Fra%20chatbot%20p%C3%A5%20vej%20mod%20agent%20-%20Foundation%20spikeprojekt%20med%20RAG%20%26%20Ekstern%20LLM/#1-search_docsquery","title":"1\ufe0f\u20e3 <code>search_docs(query)</code>","text":"<p>\u2192 Finder relevante tekstbider fra The Way of Coherence-siden.</p>"},{"location":"AI-ML/projekter/Chatbot%20test%205%20Fra%20chatbot%20p%C3%A5%20vej%20mod%20agent%20-%20Foundation%20spikeprojekt%20med%20RAG%20%26%20Ekstern%20LLM/#2-generate_ai_answerquery-docs","title":"2\ufe0f\u20e3 <code>generate_ai_answer(query, docs)</code>","text":"<p>\u2192 Bygger prompt \u2192 Sender til Llama3 (via Ollama)</p> <p>![[Pasted image 20251126130533.png]]</p> <p>Efter at have arbejdet med den lokale version af chatbotten fra ollama, s\u00e5 g\u00e5r jeg nu over til implmentation af OpenAI API inegration.  F\u00f8rst henter jeg en key fra openAI og ligger i en .env fil. Det er fra denne fil vores rag_engine.py fil skal kunne l\u00e6se API n\u00f8glen og bruge den aktivt.</p> <p>![[Pasted image 20251126135849.png]] Den er nu blevet \u00e6ndret til at importere OpenAI modellen og loade klienten.</p> <p>S\u00e5 \u00e6ndrer jeg koden til  funktionen til at generere AI svar. og \u00e6ndrer det fra at bruge ollama til openAI.</p> <p>F\u00e5 \u201chelpful assistant mode\u201d sat op**</p> <p>Efter skiftet til OpenAI lavede vi en helt ny prompt-struktur, s\u00e5 modellen ikke bare \u201ctaler\u201d, men opf\u00f8rer sig som en guide-bot.</p> <p>Vi lagde en systembesked ind: ![[Pasted image 20251126140122.png]] generate_ai_answer = sender beskeden til modellen og henter svaret.</p> <p>System-beskeden er den vigtigste besked i hele prompt-strukturen.</p> <p>Den fort\u00e6ller modellen:</p> <ul> <li>hvem den skal v\u00e6re</li> <li>hvordan den skal opf\u00f8re sig</li> <li>hvilken adf\u00e6rd den skal f\u00f8lge</li> <li>hvilke regler der g\u00e6lder</li> </ul> <p>System-beskeden er \u00f8verst i hierarkiet. Modellen prioriterer den over alt andet.</p> <p>Derfor virker det som \u201chelpful assistant mode\u201d \u2014 du aktiverer en bestemt personlighed og funktion i modellen.</p> <p>User-beskeden indeholder:</p> <ul> <li>den prompt-tekst, du (eller din code) har bygget</li> <li>kontekst fra RAG</li> <li>sp\u00f8rgsm\u00e5let</li> <li>alt det dynamiske indhold</li> </ul> <p>Det er alts\u00e5 den del, modellen skal svare p\u00e5.</p> <p>System = regler og rolle User = sp\u00f8rgsm\u00e5let + konteksten</p>"},{"location":"AI-ML/projekter/Chatbot%20test%205%20Fra%20chatbot%20p%C3%A5%20vej%20mod%20agent%20-%20Foundation%20spikeprojekt%20med%20RAG%20%26%20Ekstern%20LLM/#det-nye-i-projekt-5","title":"** Det nye i projekt 5**","text":""},{"location":"AI-ML/projekter/Chatbot%20test%205%20Fra%20chatbot%20p%C3%A5%20vej%20mod%20agent%20-%20Foundation%20spikeprojekt%20med%20RAG%20%26%20Ekstern%20LLM/#1-ny-data-ny-chunking-nye-embeddings","title":"1\ufe0f Ny data \u2192 ny chunking \u2192 nye embeddings","text":"<p>I dette projekt hentede jeg:</p> <ul> <li>HTML og tekst fra den rigtige hjemmeside</li> <li>about, services, consultations</li> <li>blog posts</li> <li>kontaktinfo</li> <li>generelle helingstekster</li> </ul> <p>Jeg rensede dem via AI, strukturerede dem til JSON og chunkede dem i 200\u2013300 ord.</p> <p>Fordi dataset er helt nyt, skulle jeg:</p> <ul> <li>lave ny chunking</li> <li>lave nye embeddings</li> <li>bygge nyt FAISS-index</li> </ul> <p>Derfor findes der nye persistensfiler:</p> <ul> <li><code>vector_store.bin</code></li> <li><code>vector_store_docs.npy</code></li> </ul>"},{"location":"AI-ML/projekter/Chatbot%20test%205%20Fra%20chatbot%20p%C3%A5%20vej%20mod%20agent%20-%20Foundation%20spikeprojekt%20med%20RAG%20%26%20Ekstern%20LLM/#2-rag-prompt-builder-generator-ai-svar","title":"2\ufe0f\u20e3 RAG + Prompt Builder + Generator (AI-svar)","text":"<p><code>Retriever \u2192 Prompt Builder \u2192 Generator</code></p>"},{"location":"AI-ML/projekter/Chatbot%20test%205%20Fra%20chatbot%20p%C3%A5%20vej%20mod%20agent%20-%20Foundation%20spikeprojekt%20med%20RAG%20%26%20Ekstern%20LLM/#retriever","title":"Retriever","text":"<p>Bruger FAISS og mine embeddings til at finde relevante tekststykker.</p>"},{"location":"AI-ML/projekter/Chatbot%20test%205%20Fra%20chatbot%20p%C3%A5%20vej%20mod%20agent%20-%20Foundation%20spikeprojekt%20med%20RAG%20%26%20Ekstern%20LLM/#prompt-builder","title":"Prompt Builder","text":"<p>Her instruerer jeg modellen:</p> <ul> <li>rolle</li> <li>tone</li> <li>regler</li> <li>hvad den m\u00e5 / ikke m\u00e5</li> <li>kontekst (fra RAG)</li> <li>brugerens sp\u00f8rgsm\u00e5l</li> </ul> <p>Eksempel fra build_prompt:</p> <p>\u201cDu er en rolig og empatisk guide p\u00e5 The Way of Coherence. Du skal bruge konteksten der findes via RAG, ellers generer et svar udfra egen viden.</p>"},{"location":"AI-ML/projekter/Chatbot%20test%205%20Fra%20chatbot%20p%C3%A5%20vej%20mod%20agent%20-%20Foundation%20spikeprojekt%20med%20RAG%20%26%20Ekstern%20LLM/#generator","title":"Generator","text":"<p>Modellen (Llama eller OpenAI) f\u00e5r prompten og genererer et svar.</p> <p>Dette giver:</p> <ul> <li>korte, venlige, kundeservice-agtige svar</li> <li>ud fra de rigtige tekster f\u00f8rst, ellers fra egen kontekst</li> </ul>"},{"location":"AI-ML/projekter/Chatbot%20test%205%20Fra%20chatbot%20p%C3%A5%20vej%20mod%20agent%20-%20Foundation%20spikeprojekt%20med%20RAG%20%26%20Ekstern%20LLM/#integration-med-openai-gpt-4o-mini","title":"Integration med OpenAI (GPT-4o mini)**","text":"<p>Dern\u00e6st testede jeg OpenAI:</p> <ul> <li>hentede API-n\u00f8gle</li> <li>lagde den i .env</li> <li>importerede OpenAI klient</li> <li>skrev generate_answer s\u00e5 den kunne bruge OpenAI</li> </ul> <p>Det gav mulighed for at sammenligne lokal vs. cloud-model.</p>"},{"location":"Blog/AI-ML-blog/","title":"AI &amp; ML Blog \u2013 Oversigt","text":"<p>Her finder du alle mine AI &amp; ML relaterede blogindl\u00e6g.</p>"},{"location":"Blog/AI-ML-blog/1.%20AI%20%26%20ML%20-%20L%C3%A6ringsm%C3%A5l%20og%20opstart/","title":"L\u00e6ringsm\u00e5l og opstart.","text":""},{"location":"Blog/AI-ML-blog/1.%20AI%20%26%20ML%20-%20L%C3%A6ringsm%C3%A5l%20og%20opstart/#mal-for-opstarten","title":"M\u00e5l for Opstarten","text":"<p>Her var fokus prim\u00e6rt p\u00e5 opstart af emner og f\u00e5 defineret l\u00e6ringsm\u00e5l samt ops\u00e6tning af portef\u00f8ljen. Samtidigt at danne et overblik over emner i AI &amp; ML omr\u00e5det jeg skal kigge p\u00e5. Det er meget store komplekse omr\u00e5der, der skal minimeres i scope. Jeg skal have fundet ud af om ML bliver meget relevant for os eller om det er prim\u00e6rt AI.</p>"},{"location":"Blog/AI-ML-blog/1.%20AI%20%26%20ML%20-%20L%C3%A6ringsm%C3%A5l%20og%20opstart/#hvad-jeg-arbejdede-med","title":"Hvad jeg arbejdede med.","text":"<p>Jeg fik opsat en r\u00e6kke [[L\u00e6ringsm\u00e5l Ai &amp; ML]]] der senere kan blive revideret og gennemg\u00e5et samt forbedret alt efter hvad der bliver vurderet relevant i forhold til projektet i projektet scope og udvikling over tid. </p> <p>jeg fandt en r\u00e6kke kilder jeg vil kigge n\u00e6rmere p\u00e5 og kan bruge til at opn\u00e5 l\u00e6ring og kendskab til omr\u00e5det, men meget af detaljerne vil komme henad vejen, da det er et forholdsvist nyt emne p\u00e5 mange omr\u00e5der og mange af de ting jeg skal besk\u00e6ftige mig med er noget der er kommet til de sidste par \u00e5r og som bliver udviklet eller \u00e6ndret ugentligt.</p>"},{"location":"Blog/AI-ML-blog/1.%20AI%20%26%20ML%20-%20L%C3%A6ringsm%C3%A5l%20og%20opstart/#refleksion","title":"Refleksion","text":"<p>Der er ikke behov for at g\u00e5 helt ind i detaljerne omkring ML p\u00e5 videnskabelig basis og da AI omr\u00e5det er ret stort ogs\u00e5 er det vigtigt at holde fokus der hvor det giver bedst mening i forhold til projektet og hvad jeg i sidste ende skal arbejde med, da vi er 3 der skal arbejde med AI p\u00e5 samme projekt, s\u00e5 vil det blive opdelt imellem os med specifikke opgaver. Jeg vil dog sikre mig at jeg opn\u00e5r relevant nok viden til at forst\u00e5 mekanismerne og detaljerne omkring AI og ML s\u00e5 jeg ved hvad der foreg\u00e5r bag linjen.</p>"},{"location":"Blog/AI-ML-blog/2.%20AI%20%26%20ML%20-%20Basis%20viden%20NLP%2C%20ML%20%26%20AI./","title":"2. Basis viden NLP, ML & AI","text":""},{"location":"Blog/AI-ML-blog/2.%20AI%20%26%20ML%20-%20Basis%20viden%20NLP%2C%20ML%20%26%20AI./#mal-for-2-etape","title":"M\u00e5l for 2. etape","text":"<p>At starte med lidt baggrund. Jeg vil f\u00e5 en basal forst\u00e5else for AI &amp; ML for bedre at se i hvilken retning jeg skal g\u00e5 og f\u00e5 klargjort hvilke emner indenfor AI &amp; ML jeg skal g\u00e5 i dybden med og hvilke der ikke bliver vigtige for mit fremadrettede forl\u00f8b.  NLP, ML og AI som begreber er et vigtigt sted at starte og f\u00e5 lidt basalt viden omkring.</p>"},{"location":"Blog/AI-ML-blog/2.%20AI%20%26%20ML%20-%20Basis%20viden%20NLP%2C%20ML%20%26%20AI./#hvad-jeg-lrte","title":"Hvad jeg l\u00e6rte","text":"<p>AI (Artificial Intelligence) er det bredeste begreb - det omfatter alle systemer der kan udf\u00f8re opgaver som normalt kr\u00e6ver menneskelig intelligens. Dette inkluderer alt fra simple regelbaserede systemer til avancerede neurale netv\u00e6rk.</p> <p>ML (Machine Learning) er en delm\u00e6ngde af AI, hvor systemer l\u00e6rer m\u00f8nstre fra data i stedet for at f\u00f8lge eksplicitte programmerede regler. Algoritmen forbedrer sig gennem erfaring og kan lave forudsigelser eller beslutninger baseret p\u00e5 nye data.</p> <p>NLP (Natural Language Processing) er et specialiseret omr\u00e5de der fokuserer p\u00e5 at f\u00e5 computere til at forst\u00e5, fortolke og generere menneskelig sprog. NLP kan bruge b\u00e5de regelbaserede metoder og ML-teknikker.</p>"},{"location":"Blog/AI-ML-blog/2.%20AI%20%26%20ML%20-%20Basis%20viden%20NLP%2C%20ML%20%26%20AI./#refleksion","title":"\ud83d\udca1 Refleksion","text":"<p>At det er brede emner og med mange facetter man kan g\u00e5 i dybden med alt efter hvor specialiseret man skal arbejde med dette emne.  Jeg t\u00e6nker at den brede forst\u00e5else omkring de her emner er nok i mit tilf\u00e6lde, da jeg ikke skal v\u00e6re AI specialist, og ikke skal kende for meget til de komplekse detaljer der f\u00f8lger med. Dog skal jeg have det koblet sammen med LLM og se om jeg kan danne en forst\u00e5else for emnet som helhed og i sin sammensatte form. </p>"},{"location":"Blog/AI-ML-blog/3.%20AI%20%26%20ML%20-%20LLM%20modeller%20og%20transformers/","title":"3. LLM modeller & transformers","text":""},{"location":"Blog/AI-ML-blog/3.%20AI%20%26%20ML%20-%20LLM%20modeller%20og%20transformers/#mal-for-etapen","title":"\ud83c\udfaf M\u00e5l for etapen","text":"<p>At f\u00e5 et indledende kendskab til LLM modeller og transformers. Samt lidt om RAG</p>"},{"location":"Blog/AI-ML-blog/3.%20AI%20%26%20ML%20-%20LLM%20modeller%20og%20transformers/#hvad-jeg-lrte","title":"\ud83d\udcda Hvad jeg l\u00e6rte","text":"<p>Der er en bred vifte af modeller man kan bruge og afpr\u00f8ve og jeg er st\u00f8dt p\u00e5 en lang r\u00e6kke der ikke tilg\u00e5s p\u00e5 samme m\u00e5de som fx. openai, claude og deepseek, men som fx. kan bruges igennem huggingface biblioteket, som kan tilg\u00e5es via fx Python.</p> <p>Jeg fik en meget simpel forst\u00e5else for RAG, men det er noget jeg skal videre med senere, da det virker til at v\u00e6re det jeg skal bruge til min chatbot.</p> <p>Jeg l\u00e6rte at transformers er motoren der sidder i modellerne og disse er forskellige og har betydning for LLM modellens endelige egenskaber, hvad den kan og hvordan den agerer. </p> <p>Jeg fik et indblik i de to slags de to forskellige transformer arkitekturer, decoder og encoder og at de begge har en attention baseret tilgang. Jeg l\u00e6rte lidt omkring attention og hvorp\u00e5 LLM modeller udskiller sig ved at v\u00e6re i stand til at have \"attention\" til flere lag i konteksten.</p> <p>Jeg har lavet yderlige analyser samt opn\u00e5et en relevant forst\u00e5else af modellerne og LLM og transformers ved g\u00e5 i dybden med dem begge.</p> <p>Disse refleksioner vil l\u00f8bende blive opdateret over tid alt efter hvad jeg l\u00e6rer overtid: [[LLM og transformers]] [[LLM Modeller]]</p>"},{"location":"Blog/AI-ML-blog/3.%20AI%20%26%20ML%20-%20LLM%20modeller%20og%20transformers/#refleksion","title":"\ud83d\udca1 Refleksion","text":"<p>Der er forskel p\u00e5 modellernes evner og hvor de kan bruges bedst. fx. er der alt efter materialet forskel p\u00e5 hvor gode de til sundhedsrelevant data alt efter algoritmer de er bygget op omkring, hvilket ogs\u00e5 har relevans i forhold til visse sprog. </p> <p>\ud83d\udca1 Projekt specifikt.  Her er der kommet flere detaljer p\u00e5 omkring scope og der er blevet \u00e6ndret lidt i kravene. S\u00e5 scope er noget mindre, og der bliver ikke brug for flere databaser samt microservice opdeling, i dette projekt.</p> <p>Det er relevant at f\u00e5 fulgt op p\u00e5 hvilke modeller der bedst muligt d\u00e6kker behovene for vores projekt og forst\u00e5elsen af sundhedsdata der skal indhentes og tages hensyn til i svarene.  Vi har dog 3 forskellige chatagenter i vores projekt, hvor af 1-2 af dem skal v\u00e6re lidt specialiseret i nogle sundhedsdata og den sidste er en agent der m\u00f8der brugeren p\u00e5 siden og guider rundt i informationen p\u00e5 siden-og denne model bliver mit ansvarsomr\u00e5de. Det er for min omr\u00e5de mindre relevant hvad der g\u00f8res brug af, da den skal kunne henvise til artikler eller andet p\u00e5 siden og guide helt simpelt i indholdet. Der bliver brug for RAG s\u00e5 vidt jeg kan se, men det er noget jeg vil g\u00e5 mere ind i senere.</p>"},{"location":"Blog/AI-ML-blog/4.%20AI%20%26%20ML%20-%20LLM%2C%20tokenisering%20og%20algoritmer/","title":"4. Tokenisering & algoritmer","text":""},{"location":"Blog/AI-ML-blog/4.%20AI%20%26%20ML%20-%20LLM%2C%20tokenisering%20og%20algoritmer/#mal-for-etapen","title":"M\u00e5l for etapen.","text":"<p>At g\u00e5 i lidt i dybden med tokenisering og opn\u00e5 noget forst\u00e5else omrking LLM modellers tr\u00e6ning og forst\u00e5else af materiale og hvilke forskelle </p>"},{"location":"Blog/AI-ML-blog/4.%20AI%20%26%20ML%20-%20LLM%2C%20tokenisering%20og%20algoritmer/#hvad-jeg-lrte","title":"Hvad jeg l\u00e6rte","text":"<p>Jeg kiggede p\u00e5 tokenisering og tokeniserings algoritmer og fik et indblik i Byte pr side og wordpiece samt lidt om subword tokenisering.  og hvordan det bruges af AI modellerne til at opdele tekster i tokens p\u00e5 forskellige m\u00e5der alt efter modeller. Det er stadigv\u00e6k kun et indblik i algoritmerne og jeg er lidt i tvivl om jeg har behov for at g\u00e5 meget mere i dybden. Jeg vil dog arbejde med emner i min gennemgang og tilegne mig en forst\u00e5else da jeg t\u00e6nker det giver et godt fundament for mit arbejde med AI og forst\u00e5elsen af modellerne og deres forskelle :</p> <p>[[Tokenisering og tr\u00e6ning]]</p>"},{"location":"Blog/AI-ML-blog/4.%20AI%20%26%20ML%20-%20LLM%2C%20tokenisering%20og%20algoritmer/#refleksion","title":"Refleksion","text":"<p>Der er forskel p\u00e5 modellernes evner og hvor de kan bruges bedst. fx. er der alt efter materialet forskel p\u00e5 hvor gode de til sundhedsrelevant data alt efter algoritmer de er bygget op omkring, hvilket ogs\u00e5 har relevans i forhold til visse sprog. </p>"},{"location":"Blog/AI-ML-blog/4.%20AI%20%26%20ML%20-%20LLM%2C%20tokenisering%20og%20algoritmer/#projekt-specifikt","title":"Projekt specifikt.","text":"<p>Her er der kommet flere detaljer p\u00e5 omkring scope og der er blevet \u00e6ndret lidt i kravene. S\u00e5 scope er noget mindre, og der bliver ikke brug for flere databaser samt microservices i dette projekt.</p> <p>Det er relevant at f\u00e5 fulgt op p\u00e5 hvilke modeller der bedst muligt d\u00e6kker behovene for vores projekt og forst\u00e5elsen af sundhedsdata der skal indhentes og tages hensyn til i svarene.  Det vil jeg kigge yderligere p\u00e5 over tid. Det er dog vigtigt for min chatbot at den fungerer p\u00e5 et acceptabelt niveau og at det foreg\u00e5r forholdvist hurtigt. Det er tit meget lavt niveau og til tider er der meget latenc p\u00e5 modellernes svar p\u00e5 div. virksomhedessider der har en lille mini chatbot guide.</p>"},{"location":"Blog/AI-ML-blog/5.%20AI%20%26%20ML%20-%20Transformer%20og%20specifikke%20modeller/","title":"5. Transformer & modeller","text":""},{"location":"Blog/AI-ML-blog/5.%20AI%20%26%20ML%20-%20Transformer%20og%20specifikke%20modeller/#mal-for-ugen","title":"M\u00e5l for ugen","text":"<p>Yderligere forst\u00e5else af transformer modeller og deres egenskaber, samt lidt l\u00e6ring om de specifikke modeller.  Derudover lidt forst\u00e5else af termerne chatbot og agent.  Opstart af lille projekt i python for at afpr\u00f8ve huggingface og python i det hele taget.</p>"},{"location":"Blog/AI-ML-blog/5.%20AI%20%26%20ML%20-%20Transformer%20og%20specifikke%20modeller/#hvad-jeg-lrte","title":"Hvad jeg l\u00e6rte","text":"<p>Det gik op for mig i denne uge at der er 3 typer af transformer-modeller. Da der udover encoder og decoder er en sammensat version, der hedder Encoder-decoder. At BERT-modellen er en oplagt model at bruge til sundhedsdata i forhold til forst\u00e5else og nedbrydning af tekster af den slags karakter [[LLM og transformers]] [[Chatbot i Python test 1. ( Setup &amp; in memory vector s\u00f8gning)]]</p>"},{"location":"Blog/AI-ML-blog/5.%20AI%20%26%20ML%20-%20Transformer%20og%20specifikke%20modeller/#refleksion","title":"Refleksion","text":"<p>Der er en del nyt at vende sig til i python. Men da det ikke er mit emne i dette semester og da der er begr\u00e6nset tid, s\u00e5 m\u00e5 det blive en hurtig forst\u00e5lse af python, samt en \"Learning by doing\" og ved hj\u00e6lp af AI vibe-coding jeg vil indlede mine python fors\u00f8g.</p> <p>Projekt specifikt. Ang\u00e5ende behandling af sundhedsdata, s\u00e5 Er BERT-Encoder modellen interessant til vores dom\u00e6ne som den prim\u00e6re model der vil st\u00e5 for behnadling af sundhedsdata og tekster.  Dette er dog ikke mit omr\u00e5de. Til min opgave at lave en \"side chatbot\" der er det vigtigere med en nem og simpel model der kan k\u00f8re gnidningsfrit p\u00e5 siden og mange modeller skulle kunne l\u00f8se denne opgave helt fint. Det vil dog v\u00e6re et oplagt valg til de to andre chatbots i vores projekt.</p>"},{"location":"Blog/AI-ML-blog/6.%20AI%20%26%20ML%20%20-%20RAG%20VS.%20Finetuning/","title":"6. AI & ML    RAG VS. Finetuning","text":""},{"location":"Blog/AI-ML-blog/6.%20AI%20%26%20ML%20%20-%20RAG%20VS.%20Finetuning/#mal-for-etapen","title":"M\u00e5l for etapen","text":"<p>At starte op p\u00e5 l\u00e6ring omkring RAG VS. Fine tuning for at fors\u00e5 hvad der specifikt g\u00f8r sig bedst g\u00e6ldende for vores 3 brug scenarier af LLM modeller.  Lave videre p\u00e5 projekter i python og opn\u00e5 st\u00f8rre praktisk forst\u00e5else for hvad en AI-chatbot skal indeholde og kunne og hvordan det fungerer. Hvordan den g\u00f8r brug af vector og persistens. Det er en forts\u00e6ttelse af f\u00f8rste projekt.</p>"},{"location":"Blog/AI-ML-blog/6.%20AI%20%26%20ML%20%20-%20RAG%20VS.%20Finetuning/#hvad-jeg-lrte","title":"\ud83d\udcda Hvad jeg l\u00e6rte","text":"<p>Retrieval Argumented Generation (RAG) er en metode hvor der gennemg\u00e5s lokale data for informationer og oplysninger, inden der genereres et svar p\u00e5 en foresp\u00f8rgsel af LLM modellen. Her kan der fx. bruges Few Shot Prompting, hvor der er gennemg\u00e5es en r\u00e6kke svarmuligheder for at generere det bedst mulige svar. At fine tuning ligesom RAG giver en god mulighed for at p\u00e5virke LLM modellens output til en specifik foresp\u00f8rgsel. Her skal den dog tr\u00e6nes. [[RAG VS. Finetuning]] Jeg har arbejdet med projektet og lavet f\u00f8rste simple del via huggingface biblioteket. [[Chatbot i Python test 1. ( Setup &amp; in memory vector s\u00f8gning)]]</p> <p>Derudover har jeg arbejdet med et andet projekt: [[Chatbot i python test 2. (Persitens)]]</p> <p>Samtidig begyndte jeg at arbejde videre med RAG i Python-projektet. Her er forskellen tydelig: i stedet for at tr\u00e6ne modellen om, s\u00e5 henter RAG relevante tekststykker fra mine dokumenter og bruger dem som kontekst.</p> <p>Jeg pr\u00f8vede f\u00f8rst at s\u00e6tte persistens op med Chroma, men det gik ikke s\u00e5 nemt, s\u00e5 skiftede jeg til FAISS, som fungerede med det samme.</p> <p>FAISS virker hurtigere og mere stabilt i denne ops\u00e6tning, og det g\u00f8r egentlig ikke s\u00e5 meget, at det ikke har \u201cindbygget\u201d persistens p\u00e5 samme m\u00e5de. Jeg kan stadig gemme embeddings manuelt og loade dem igen og f\u00e5 noget praktisk \"hands on\" erfarring med persistens</p>"},{"location":"Blog/AI-ML-blog/6.%20AI%20%26%20ML%20%20-%20RAG%20VS.%20Finetuning/#refleksion","title":"\ud83d\udca1 Refleksion","text":"<p>Det vil give god mening at g\u00f8re brug af RAG i de tilf\u00e6lde hvor der er en stor m\u00e6ngde dom\u00e6ne specifikke data der skal gennemg\u00e5es og danne grundlag for et svar til brugeren. Hvis der skal tages ekstra hensyn til en specifik vinkel og modellen skal ledes i en given retning f\u00f8r den genererer sit svar. At fine tuning virker til at v\u00e6re en lidt mere kompleks process i forhold til RAG og det kan kr\u00e6ve lidt mere arbejde at tilpasse modellen.</p> <p>\ud83d\udca1 Projekt specifikt.  Her er det oplagt mulighed at bruge RAG til at opstille en r\u00e6kke relevante data, som der kan danne grundlag for svaret. Da det er en helt speciel vinkel og specifikke hensyn vores PO \u00f8nsker tr\u00e6der i kraft n\u00e5r svaret genereres til brugeren. Der skal dog bruges flere modeller/agenter i vores projekt og det kan derfor v\u00e6re relevant med andre metoder istedet.</p>"},{"location":"Blog/AI-ML-blog/7.%20AI%20%26%20ML-%20Fine-tuning%2C%20RAG%20og%20videre%20arbejde%20i%20Python-projekter./","title":"7. AI & ML  Fine tuning, RAG og videre arbejde i Python projekter.","text":""},{"location":"Blog/AI-ML-blog/7.%20AI%20%26%20ML-%20Fine-tuning%2C%20RAG%20og%20videre%20arbejde%20i%20Python-projekter./#mal-for-etapen","title":"M\u00e5l for etapen","text":"<p>I denne etape ville jeg g\u00e5 mere i dybden med fine-tuning og samtidig f\u00e5 et samlet overblik over forskellene mellem RAG og fine-tuning. Derudover begyndte jeg at arbejde mere praktisk i mit Python-projekt, hvor jeg fik sat persistens op.</p>"},{"location":"Blog/AI-ML-blog/7.%20AI%20%26%20ML-%20Fine-tuning%2C%20RAG%20og%20videre%20arbejde%20i%20Python-projekter./#hvad-jeg-lrte","title":"Hvad jeg l\u00e6rte","text":"<p>Fine-tuning er en m\u00e5de at tr\u00e6ne en eksisterende base-model videre p\u00e5 med specifikt materiale. Det betyder, at modellen ikke kun l\u00e6rer selve indholdet, men ogs\u00e5 den m\u00e5de svarene skal struktureres p\u00e5 inden for det p\u00e5g\u00e6ldende omr\u00e5de.</p> <p>Jeg forst\u00e5r det som en slags undervisningsproces:</p> <ul> <li>Modellen bliver pr\u00e6senteret for sp\u00f8rgsm\u00e5l og svar</li> <li>Gode svar bliver \u201cbel\u00f8nnet\u201d og D\u00e5rlige svar bliver \u201cstraffet\u201d</li> <li>Og over tid l\u00e6rer den at ramme den stil og retning, man \u00f8nsker</li> </ul> <p>Det er en omfattende proces, is\u00e6r hvis der er meget materiale, eller hvis modellen ofte skal opdateres. Til geng\u00e6ld kan det give en meget stabil og ensartet m\u00e5de at svare p\u00e5, is\u00e6r hvis man har en agent med faste m\u00f8nstre.</p>"},{"location":"Blog/AI-ML-blog/7.%20AI%20%26%20ML-%20Fine-tuning%2C%20RAG%20og%20videre%20arbejde%20i%20Python-projekter./#rag-i-praksis-chroma-til-faiss","title":"RAG i praksis \u2013 Chroma til FAISS","text":"<p>Samtidig begyndte jeg at arbejde videre med RAG i Python-projektet. Her er forskellen tydelig: i stedet for at tr\u00e6ne modellen om, s\u00e5 henter RAG relevante tekststykker fra mine dokumenter og bruger dem som kontekst.</p> <p>Jeg pr\u00f8vede f\u00f8rst at s\u00e6tte persistens op med Chroma, men det gik ikke s\u00e5 nemt, s\u00e5 skiftede jeg til FAISS, som fungerede med det samme.</p> <p>FAISS virker hurtigere og mere stabilt i denne ops\u00e6tning, og det g\u00f8r egentlig ikke s\u00e5 meget, at det ikke har \u201cindbygget\u201d persistens p\u00e5 samme m\u00e5de. Jeg kan stadig gemme embeddings manuelt og loade dem igen og f\u00e5 noget praktisk \"hands on\" erfarring med persistens</p>"},{"location":"Blog/AI-ML-blog/7.%20AI%20%26%20ML-%20Fine-tuning%2C%20RAG%20og%20videre%20arbejde%20i%20Python-projekter./#chatbot-i-python-test-2-persistens","title":"[[Chatbot i python test 2. (Persistens)]]","text":""},{"location":"Blog/AI-ML-blog/7.%20AI%20%26%20ML-%20Fine-tuning%2C%20RAG%20og%20videre%20arbejde%20i%20Python-projekter./#refleksion","title":"Refleksion","text":"<p>Det st\u00e5r klart for mig, at finetuning er en tungere proces end RAG, og at det kr\u00e6ver mere at holde ved lige. Derfor giver det ikke mening at bruge det alle steder i projektet. Men jeg kan ogs\u00e5 se, at finetuning kan v\u00e6re en fordel, n\u00e5r man har meget faste typer svar eller en bestemt struktur, der skal gentages hver gang.</p> <p>Det er her vores  agent kunne begynde at give mening via finetuning. Research agenten til PO kunnne g\u00f8re brug af finetuning.  Hvis den skal generere faste typer planer, ugestrukturer eller regler, kunne den p\u00e5 sigt have gavn af en lille finetuning, fordi den s\u00e5 l\u00e6rer, hvordan en \u201crigtig\u201d plan skal se ud \u2014 og ikke kun hvilke informationer den skal bruge.</p> <p>Omvendt giver det stadig mest mening at forts\u00e6tte med RAG i min cahtbot implmentering. Den ene chatbot der guider brugeren rundt p\u00e5 siden, og den anden chatbot der svarer ud fra sundhedsrelateret indhold. Her \u00e6ndrer vores tekster sig ofte, og modellen skal kunne hente den nyeste viden direkte fra dokumenterne, hvilket RAG er perfekt til.</p>"},{"location":"Blog/AI-ML-blog/8.%20AI%20%26%20ML%20-%20Chatbots%20test%20projekter./","title":"8. Chatbots test projekter","text":""},{"location":"Blog/AI-ML-blog/8.%20AI%20%26%20ML%20-%20Chatbots%20test%20projekter./#mal-for-etapen","title":"M\u00e5l for etapen","text":"<p>Form\u00e5let med denne etape var at lave nogle mindre tests i Python for at forst\u00e5 RAG i praksis, og derefter pr\u00f8ve at opbygge en simpel API-l\u00f8sning, som senere kan bruges som grundlag for en chatbot i et st\u00f8rre system. Jeg ville samtidig bruge tiden p\u00e5 at kigge lidt bredere p\u00e5 andre modeller og teknikker, der er relevante at kende til, inden det endelige chatbotprojekt g\u00e5r i gang.</p>"},{"location":"Blog/AI-ML-blog/8.%20AI%20%26%20ML%20-%20Chatbots%20test%20projekter./#hvad-jeg-lrte","title":"Hvad jeg l\u00e6rte","text":"<p>Jeg arbejdede kort med to sm\u00e5 testprojekter:</p>"},{"location":"Blog/AI-ML-blog/8.%20AI%20%26%20ML%20-%20Chatbots%20test%20projekter./#chatbot-test-3-rag-i-terminalen","title":"Chatbot test 3 \u2013 RAG i terminalen","text":"<p>Her fik jeg RAG til at fungere direkte i terminalen. Jeg brugte:</p> <ul> <li>mine egne dokumenter</li> <li>embeddings</li> <li>Chroma som vector store</li> <li>retrieval \u2192 kontekst \u2192 svar</li> </ul> <p>Denne test hjalp mig med at forst\u00e5 hele den tekniske pipeline i praksis. Det er f\u00f8rste gang, hvor tingene begyndte at h\u00e6nge sammen: tokens, chunks, embeddings, retrieval og modellen. [[Chatbot test 3. (RAG i terminal)]]</p>"},{"location":"Blog/AI-ML-blog/8.%20AI%20%26%20ML%20-%20Chatbots%20test%20projekter./#chatbot-test-4-rest-api-fastapi","title":"Chatbot test 4 \u2013 REST API (FastAPI)","text":"<p>I dette projekt testede jeg at g\u00f8re chatbotten til en API. Her l\u00e6rte jeg:</p> <ul> <li>hvordan man eksponerer en chatbot som endpoint</li> <li>hvordan man sender foresp\u00f8rgsler og modtager svar via JSON</li> <li>hvordan man kan forbinde RAG-delen med et web-API</li> <li>hvordan jeg i fremtiden kan koble en Blazor-frontend eller anden UI p\u00e5</li> </ul> <p>Denne del er vigtig for projektet, fordi vores rigtige chatbot skal integreres i en st\u00f8rre platform \u2014 og ikke kun k\u00f8re lokalt.</p>"},{"location":"Blog/AI-ML-blog/8.%20AI%20%26%20ML%20-%20Chatbots%20test%20projekter./#chatbot-test-4-rest-apifast-api-gateway","title":"[[Chatbot test 4 (Rest API(Fast API) Gateway.]]","text":""},{"location":"Blog/AI-ML-blog/8.%20AI%20%26%20ML%20-%20Chatbots%20test%20projekter./#anden-relevant-lring-jeg-kiggede-pa","title":"Anden relevant l\u00e6ring jeg kiggede p\u00e5","text":"<p>I forbindelse med disse tests st\u00f8dte jeg ogs\u00e5 ind i nogle ekstra emner:</p>"},{"location":"Blog/AI-ML-blog/8.%20AI%20%26%20ML%20-%20Chatbots%20test%20projekter./#slm-modeller-small-language-models","title":"SLM-modeller (Small Language Models)","text":"<p>Jeg l\u00e6rte kort om SLM\u2019er, som i bund og grund er mindre modeller, der kan k\u00f8re hurtigt og billigt p\u00e5 almindelig hardware. De er ikke lige s\u00e5 st\u00e6rke som store LLM\u2019er, men de kan v\u00e6re relevante til simple hj\u00e6lpefunktioner eller til at spare ressourcer.</p>"},{"location":"Blog/AI-ML-blog/8.%20AI%20%26%20ML%20-%20Chatbots%20test%20projekter./#prompt-struktur-og-sma-forbedringer","title":"Prompt-struktur og sm\u00e5 forbedringer","text":"<p>Jeg har ogs\u00e5 f\u00e5et en bedre forst\u00e5else for:</p> <ul> <li>hvordan systemprompten p\u00e5virker svarene</li> <li>hvordan f\u00e5-shot prompts kan styre tonen</li> <li>hvorfor kontekststyring er vigtigt</li> <li>og hvor f\u00f8lsom retrieval er overfor d\u00e5rlige chunks</li> </ul> <p>Alt sammen noget der er vigtigt, f\u00f8r jeg bygger en chatbot til et rigtigt projekt.</p> <p>Jeg skal i n\u00e6ste etape arbejde videre med [[Chatbot test 4 (Rest API(Fast API) Gateway.]] og koble ai genereret svar p\u00e5 projektet for at afpr\u00f8ve et AI genereret svar udfra brugerens query.</p>"},{"location":"Blog/AI-ML-blog/8.%20AI%20%26%20ML%20-%20Chatbots%20test%20projekter./#refleksion","title":"\ud83d\udca1 Refleksion","text":"<p>Det f\u00f8les som om brikkerne falder mere og mere p\u00e5 plads nu. F\u00f8rst l\u00e6rte jeg om tokenisering, transformer-struktur og RAG p\u00e5 et teoretisk niveau \u2014 og nu begynder jeg at kunne bygge det i praksis.</p> <p>Disse to sm\u00e5 Python-tests var en god m\u00e5de at:</p> <ul> <li>forst\u00e5 RAG-flowet</li> <li>f\u00e5 styr p\u00e5 vector stores og persistens</li> <li>se hvordan en REST API til en chatbot kan fungere</li> <li>og f\u00e5 en fornemmelse af, hvad der skal til, f\u00f8r projektets chatbot kan s\u00e6ttes sammen</li> </ul> <p>Jeg kan ogs\u00e5 m\u00e6rke, at den n\u00e6ste store del bliver at kombinere alt dette med vores faktiske projekt, hvor vi har tre forskellige chatagenter med forskellige behov. Indtil nu giver det stadig mest mening at bygge projektet videre p\u00e5 RAG, og senere se om andre teknikker som SLM\u2019er eller evt. finetuning kan bruges til nogle af de mere strukturerede opgaver (fx tr\u00e6ningsplan-agenten).</p>"},{"location":"Blog/AI-ML-blog/9.%20AI%20%26%20ML%20-%20Chatbot%20udvikling./","title":"Projekt 4-5 \u2013 Fra ren RAG til en agent.","text":""},{"location":"Blog/AI-ML-blog/9.%20AI%20%26%20ML%20-%20Chatbot%20udvikling./#mal-for-etapen","title":"M\u00e5l for etapen","text":"<p>Her er planen at opn\u00e5 generative AI via agentens svar til brugeren. Derefter skal der startes et nyt projekt op der skal v\u00e6re grundlaget for min implmenattion af en chatagent til projektet.  Her vil jeg g\u00e5 fra lokal AI model til OpenaAI som den tilkoblede AI model. </p> <ul> <li>At bruge data fra Thewayofcoherenceprojektets oprindelige side og lave (FAISS + embeddings) p\u00e5 den data der skal bruges til det endelige projekt</li> <li>Lade RAG finde de rigtige dokumenter.</li> <li>sende de fundne dokumenter videre til en LLM.</li> <li>Og f\u00e5 modellen til at skrive selve svaret, baseret p\u00e5 pr\u00e6cis den kontekst jeg giver den.</li> <li>Derudover skal AI modellen svare ud fra dens rolle og med specificeret instrukser.</li> </ul> <p>RAG + generativ AI = en rigtig agent, ikke bare en s\u00f8gerobot.</p>"},{"location":"Blog/AI-ML-blog/9.%20AI%20%26%20ML%20-%20Chatbot%20udvikling./#hvad-jeg-lrte","title":"Hvad jeg l\u00e6rte","text":"<p>Det sjove ved den her etape var, hvor tydeligt det pludselig blev, hvor forskelligt systemet arbejder:</p> <p>Og jeg fik ogs\u00e5 en vigtig erfaring: En LLM svarer ikke n\u00f8dvendigvis ud fra dine dokumenter, medmindre du styrer prompten meget pr\u00e6cist. Derfor byggede jeg en structured prompt, hvor jeg:</p> <ul> <li>indsatte de fundne tekster</li> <li>gav en rolle (\u201crolig, hj\u00e6lpsom guide\u201d)</li> <li>satte regler (\u201cbrug kun denne kontekst, ingen medicinske r\u00e5d, ingen faktaopfindelser\u201d) Det gjorde en verden til forskel, s\u00e5 nu holdt modellen sig til min videnbase \u2013 ikke intern viden eller g\u00e6t. Det g\u00f8r en stor forskel at modellen f\u00e5r \"instruction-tuning\" og regler for dens rolle. se [[Chatbot test 5 Fra chatbot p\u00e5 vej mod agent - Foundation spikeprojekt med RAG &amp; Ekstern LLM]]</li> </ul>"},{"location":"Blog/AI-ML-blog/9.%20AI%20%26%20ML%20-%20Chatbot%20udvikling./#refleksion","title":"Refleksion","text":"<p>Jeg har nu en klar praktisk ide om, hvordan den endelige prototype vil se ud, med regler og instrukser, der kan styre dens ageren og opf\u00f8rsel som guide p\u00e5 hjemmesiden og jeg ser frem til at lave det sidste f\u00e6rdigt og f\u00e5 arbejdet med den endelige model og dens detaljer.</p>"},{"location":"Blog/Software-arkitektur-blog/","title":"Software Arkitektur Blog \u2013 Oversigt","text":"<p>Her finder du alle mine blogindl\u00e6g om software arkitektur.</p>"},{"location":"Blog/Software-arkitektur-blog/1.%20Software%20arkitektur%20%26%20Design%20patterns/","title":"L\u00e6ringsm\u00e5l og opstart.","text":""},{"location":"Blog/Software-arkitektur-blog/1.%20Software%20arkitektur%20%26%20Design%20patterns/#mal-for-opstarten","title":"M\u00e5l for Opstarten","text":"<p>Her var fokus prim\u00e6rt p\u00e5 opstart af emner og f\u00e5 defineret l\u00e6ringsm\u00e5l samt ops\u00e6tning af portef\u00f8ljen. Samtidigt at danne et overblik over arkitekturer jeg vil l\u00e6re mere om for at kunne v\u00e6lge en arkitektur til projektet senere Her var fokus prim\u00e6rt p\u00e5 opstart af emner og f\u00e5 defineret l\u00e6ringsm\u00e5l og emner og termer der skal kigge p\u00e5, samt ops\u00e6tning af portef\u00f8ljen, s\u00e5 den er oppe og k\u00f8re.</p>"},{"location":"Blog/Software-arkitektur-blog/1.%20Software%20arkitektur%20%26%20Design%20patterns/#hvad-jeg-arbejdede-med","title":"Hvad jeg arbejdede med.","text":"<p>Jeg fik opsat en r\u00e6kke [[L\u00e6ringsm\u00e5l Software arkitektur]] der senere kan blive revideret og gennemg\u00e5et samt forbedret alt efter hvad der bliver vurderet relevant i forhold til projektet i projektet scope og udvikling over tid. </p> <p>jeg fandt en r\u00e6kke kilder jeg vil kigge n\u00e6rmere p\u00e5 til at udv\u00e6lge arkitekturer i fremtiden. Jeg regner med at kigge en del arkitekturer igennem hurtigt og l\u00f8st for at f\u00e5 en ide om de har nogen relevans i forhold til vores projekt, men regner med at g\u00e5 i dybden med et par stykker der giver bedre mening til vores projekt ved f\u00f8rste \u00f8jekast.</p>"},{"location":"Blog/Software-arkitektur-blog/1.%20Software%20arkitektur%20%26%20Design%20patterns/#refleksion","title":"Refleksion","text":"<p>Der er mange arkitekturer man kan g\u00f8re brug af og de har tit flere ligheder og kan bruges til at supplere hinanden.  Det er sv\u00e6rt at spore sig ind p\u00e5 det helt rigtige og korrekte, da der kan argumenteres for at man bruger flere forskellige arkitekturer til projektet. Jeg har dog en ide om at det ikke bliver hexagonal eller microservices arkitekturen, da det vil blive for voldsomt til vores lille projekt og dets indhold. Det skal kunne h\u00e5ndteres forholdsvist billigt og nemt og v\u00e6re af en begr\u00e6nset st\u00f8rrelse som udgangspunkt.</p>"},{"location":"Blog/Software-arkitektur-blog/10.%20Afslutning/","title":"10. Afslutning","text":""},{"location":"Blog/Software-arkitektur-blog/10.%20Afslutning/#mal-for-etapen","title":"M\u00e5l for etapen","text":"<p>At danne mig et overblik over hvad jeg har l\u00e6rt og opn\u00e5et i forhold til emnet software arkitektur og design principper.</p>"},{"location":"Blog/Software-arkitektur-blog/10.%20Afslutning/#hvad-jeg-lrte","title":"Hvad jeg l\u00e6rte","text":"<p>Efter at have v\u00e6ret igennem valg af arkitektur, test af patterns, vertical slice, domain events og mine f\u00f8rste skridt ind i DDD, er jeg n\u00e5et til et punkt hvor tingene begynder at h\u00e6nge sammen p\u00e5 en m\u00e5de, jeg ikke helt forstod tidligere.</p>"},{"location":"Blog/Software-arkitektur-blog/10.%20Afslutning/#1-clean-architecture-blev-fundamentet","title":"1. Clean Architecture blev fundamentet.","text":"<p>I starten var Clean Architecture \u201cbare en lagdeling\u201d, men efterh\u00e5nden som jeg:</p> <ul> <li>isolerede domain</li> <li>flyttede logik v\u00e6k fra UI</li> <li>arbejdede med interfaces</li> <li>fik Infrastructure gjort til et rent \u201cteknologiplugin\u201d</li> </ul> <p>s\u00e5 opdagede jeg, hvor meget enklere det gjorde projektet.</p> <p>Det vigtigste jeg l\u00e6rte her er:</p> <p>N\u00e5r dom\u00e6net er rent, bliver alle valg ovenp\u00e5 lettere.</p> <p>Vertical Slice, DDD, CQRS \u2014 alle de ting fungerer bedre n\u00e5r domain-laget ikke er rodet.</p>"},{"location":"Blog/Software-arkitektur-blog/10.%20Afslutning/#2-vertical-slice-fik-use-cases-til-at-falde-naturligt-i-mini-features","title":"2. Vertical Slice fik use cases til at falde naturligt i \u201cmini-features\u201d","text":"<p>Vertical Slice var det punkt hvor det hele blev mere praktisk.</p> <p>Jeg l\u00e6rte is\u00e6r:</p> <ul> <li>at hver feature kan v\u00e6re sin egen lille enhed</li> <li>at en mappe som <code>/Content/Create</code> er langt mere intuitiv end et gigantisk <code>ContentService</code></li> <li>at Blazor faktisk passer perfekt til denne tankegang</li> <li>at CQRS (Commands/Queries) falder naturligt ind i vertical slice</li> <li>at UI og Application begynder at spejle hinanden logisk</li> </ul> <p>Det gjorde projektet overskueligt p\u00e5 en m\u00e5de, som layered architecture aldrig kunne.</p>"},{"location":"Blog/Software-arkitektur-blog/10.%20Afslutning/#3-domain-events-gav-gjorde-ddd-muligt","title":"3. Domain Events gav gjorde DDD muligt","text":"<p>Domain events var et vendepunkt, fordi jeg l\u00e6rte:</p> <ul> <li>hvordan dom\u00e6net kan reagere p\u00e5 \u00e6ndringer uden at UI eller services blandes ind</li> <li>at sideeffekter kan ligge i Application eller Infrastructure</li> <li>at event-h\u00e5ndtering giver en f\u00f8lelse af \u201crealistisk systemadf\u00e6rd\u201d</li> </ul> <p>Det var ogs\u00e5 her jeg forstod:</p> <p>Domain Events er ikke et pattern man bare \u201cv\u00e6lger\u201d. De dukker op, n\u00e5r dom\u00e6net begynder at f\u00e5 regler og betydning og bliver mere komplekst.</p> <p>Og det var faktisk i Content-bounded context (publicering af posts) at det gav mening at starte.</p>"},{"location":"Blog/Software-arkitektur-blog/10.%20Afslutning/#4-jeg-begyndte-at-se-tydelige-bounded-contexts-i-projektet","title":"4. Jeg begyndte at se tydelige bounded contexts i projektet","text":"<p>F\u00f8r Vertical Slice + Domain Events var projektet mest \u201cet system\u201d.</p> <p>Nu kunne jeg pludselig se:</p> <ul> <li>Content har sine egne regler</li> <li>Membership har helt andre regler</li> <li>Notifikationer passer ikke ind i nogle af de andre</li> <li>AI er sit eget dom\u00e6ne - n\u00e6sten sin egen applikation</li> </ul> <p>Denne opdeling er i virkeligheden DDD\u2019s grundtanke, uden at man n\u00f8dvendigvis laver alt det tunge domain-modelling arbejde.</p>"},{"location":"Blog/Software-arkitektur-blog/10.%20Afslutning/#5-patterns-fik-en-mere-naturlig-plads-i-projektet","title":"5. Patterns fik en mere naturlig plads i projektet","text":"<p>Jeg fik en ret vigtig erkendelse:</p> <p>Mange patterns er ikke noget man \u201cskal implementere\u201d  de dukker op n\u00e5r problemet kalder p\u00e5 dem.</p> <p>Eksempler:</p> <ul> <li> <p>Observer Pattern \u2192 for simpelt, men gav mig forst\u00e5elsen for Domain Events</p> </li> <li> <p>Domain Events \u2192 det rigtige valg til vores bounded contexts</p> </li> <li> <p>Factory \u2192 relevant d\u00e9r hvor vi har flere typer af content</p> </li> <li> <p>Strategy \u2192 kun brugbart der hvor regler varierer</p> </li> <li> <p>CQRS \u2192 h\u00e6nger n\u00e6sten naturligt sammen med vertical slice</p> </li> </ul> <p>Arkitektur og patterns er v\u00e6rkt\u00f8jer, ikke et m\u00e5l.</p>"},{"location":"Blog/Software-arkitektur-blog/10.%20Afslutning/#refleksion","title":"Refleksion","text":""},{"location":"Blog/Software-arkitektur-blog/10.%20Afslutning/#clean-architecture-gjorde-det-muligt-at-lave-de-rigtige-ting-senere","title":"Clean Architecture gjorde det muligt at lave \u201cde rigtige ting\u201d senere","text":"<p>Vertical Slice, DDD, Domain Events \u2014 alt det f\u00f8les kun naturligt, fordi Clean Architecture gav en st\u00e6rk struktur.</p>"},{"location":"Blog/Software-arkitektur-blog/10.%20Afslutning/#vertical-slice-gjorde-min-featurestruktur-ekstremt-overskuelig","title":"Vertical Slice gjorde min featurestruktur ekstremt overskuelig","text":"<p>Det er en meget nem og ren tilgang, der dog ogs\u00e5 kr\u00e6ver en del klasser i sin \"rene\" form.</p>"},{"location":"Blog/Software-arkitektur-blog/10.%20Afslutning/#domain-events-som-starten-pa-vigtige-hndelser","title":"Domain Events som starten p\u00e5 vigtige h\u00e6ndelser","text":"<p>Det giver et godt flow imellem domain og application laget</p>"},{"location":"Blog/Software-arkitektur-blog/10.%20Afslutning/#ddd-gav-mig-et-nyt-blik-pa-projektet","title":"DDD gav mig et nyt blik p\u00e5 projektet","text":"<ul> <li>dom\u00e6ner</li> <li>regler</li> <li>kontekster</li> <li>handlinger</li> <li>reaktioner</li> </ul> <p>Det er m\u00e5ske den st\u00f8rste l\u00e6ring indtil videre.</p> <p>At t\u00e6nke dom\u00e6ne er ikke \u201ckompliceret\u201d, det er bare en anden m\u00e5de at se systemet p\u00e5.</p>"},{"location":"Blog/Software-arkitektur-blog/10.%20Afslutning/#projekt-specifikt","title":"Projekt specifikt","text":"<p>I vores konkrete projekt har alt dette resulteret i:</p> <ul> <li>en ren domain-kerne</li> <li>vertical slice i features igennem lagene.</li> <li>CQRS som naturligt m\u00f8nster</li> <li>Domain Events i Content</li> <li>klar opdeling i bounded contexts</li> <li>AI som eksternt modul, helt uafh\u00e6ngigt af domain</li> <li>en modul\u00e6r monolith der kan udvides p\u00e5 lang sigt</li> <li>en arkitektur der passer til vores ambitionsniveau</li> <li>et system der kan vokse uden at implodere</li> </ul>"},{"location":"Blog/Software-arkitektur-blog/2.%20Software%20arkitektur%20%26%20Design%20patterns./","title":"Mine f\u00f8rste tanker om arkitekturer","text":""},{"location":"Blog/Software-arkitektur-blog/2.%20Software%20arkitektur%20%26%20Design%20patterns./#mal-for-etapen","title":"M\u00e5l for etapen","text":"<p>At begynde at forst\u00e5, hvilken arkitektur der kunne mening for projektet \u2013 uden at l\u00e5se mig fast, men at have d\u00f8ren \u00e5ben for et par muligheder.</p>"},{"location":"Blog/Software-arkitektur-blog/2.%20Software%20arkitektur%20%26%20Design%20patterns./#_hvad-jeg-arbejdede-med","title":"_Hvad jeg arbejdede med.","text":"<p>I denne tidlige fase af projektet handlede det om at f\u00e5 en ide om at kunne f\u00e5 gjort brug af den rigtige arkitektur i forhold til lagdeling og ogs\u00e5 en ide om mappestrukturen i selve kode projektet.</p> <p>Jeg startede bredt og Jeg l\u00e6ste og sammenlignede forskellige arkitekturer:</p> <p>klassisk Layered Architecture, Clean Architecture, Modul\u00e6r Monolith, Microservices, Hexagonal, hvor jeg har lavet lidt foranalyse af dem for at danne mig en ide om hvad jeg skal bruge til projektet over tid. [[1. Arkitektur gennemgang og korte analyser.]]</p> <p>Min tanke var p\u00e5 at f\u00e5 en \"f\u00f8lelse\" af hvad der kunne give mening i forhold til dette projekt og dets st\u00f8rrelse og hvad jeg antager er en begr\u00e6nset kompleksitet. Men det er stadigv\u00e6k et relevant tidspunkt at begynde at stille lidt sp\u00f8rgsm\u00e5l til projektet og dets endelige form:</p>"},{"location":"Blog/Software-arkitektur-blog/2.%20Software%20arkitektur%20%26%20Design%20patterns./#hvor-stort-forventer-jeg-at-domnet-bliver","title":"Hvor stort forventer jeg, at dom\u00e6net bliver?","text":"<p>Dom\u00e6net har potentiale til at vokse betydeligt.  Derfor vil projektet sandsynligvis f\u00e5 behov for opskalering \u2014 b\u00e5de teknisk og strukturelt \u2014 over tid. Det skal kunne h\u00e5ndtere at vokse over tid og hvis det i fremtiden blev st\u00f8rre.  Dog skal vi ikke arbejde og bygge ud fra en ide om at det er et k\u00e6mpe endeligt projekt med mange forskellige services der skal integreres. Da det er en meget minimalt bes\u00f8gt side pt og det er det vi bygger efter pt.</p>"},{"location":"Blog/Software-arkitektur-blog/2.%20Software%20arkitektur%20%26%20Design%20patterns./#hvor-stor-en-rolle-kommer-ai-til-at-spille-nu-og-i-fremtiden","title":"Hvor stor en rolle kommer AI til at spille \u2014 nu og i fremtiden?","text":"<p>AI bliver en gennemg\u00e5ende del af projektet:</p> <ul> <li>chatfunktioner</li> <li>analyse</li> <li>embeddings</li> <li>generering af forslag</li> <li>modul\u00e6re pipelines</li> <li>potentielt flere modeller senere</li> </ul> <p>Derfor b\u00f8r AI behandles som sit eget modul/bounded context, og ikke som en del af business-laget i en layered architecture. En adskillelse ville v\u00e6re et godt approach.</p>"},{"location":"Blog/Software-arkitektur-blog/2.%20Software%20arkitektur%20%26%20Design%20patterns./#hvor-mange-moduler-kommer-projektet-til-at-besta-af-og-hvordan-br-vi-gribe-separation-og-principper-an","title":"Hvor mange moduler kommer projektet til at best\u00e5 af? Og hvordan b\u00f8r vi gribe separation og principper an?","text":"<p>Der er behov for en klar modul\u00e6r opdeling:</p> <ul> <li>Content (posts, regler, publicering)</li> <li>Membership</li> <li>Notifications</li> <li>AI (ekstern eller intern service)</li> </ul> <p>Derfor giver det mening at bruge en arkitektur der g\u00f8r det muligt at modulerne allerede nu bliver adskilt via gr\u00e6nser, interfaces og Domain-koncepter. En arkitektur der underst\u00f8tter projektet p\u00e5 den bedst t\u00e6nkelige m\u00e5de og giver decoupling.</p>"},{"location":"Blog/Software-arkitektur-blog/2.%20Software%20arkitektur%20%26%20Design%20patterns./#hvor-meget-skal-domnet-isoleres","title":"Hvor meget skal dom\u00e6net isoleres?","text":"<p>Dom\u00e6net skal isoleres grundigt.</p> <ul> <li>for at sikre SRP og SOLID</li> <li>for at undg\u00e5 afh\u00e6ngigheder</li> <li>for at undg\u00e5 at UI/Infrastructure p\u00e5virker kerne-logik</li> <li>for sikkerhed</li> <li>for fremtidig fleksibilitet</li> <li>for at g\u00f8re AI, Identity og repos udskiftelige Domain isolation er derfor n\u00f8dvendigt \u2014 ikke et \u201cnice to have\u201d.</li> </ul>"},{"location":"Blog/Software-arkitektur-blog/2.%20Software%20arkitektur%20%26%20Design%20patterns./#_hvad-hvis-projektet-senere-skal-deployes-i-containere","title":"_Hvad hvis projektet senere skal deployes i containere?","text":"<p>Containere. Docker. Eksterne services.</p> <p>Det kr\u00e6ver, at projektet allerede er bygget med:</p> <ul> <li>klare gr\u00e6nser</li> <li>uafh\u00e6ngige moduler</li> <li>rene interfaces</li> <li>minimal coupling</li> <li>domain isolation</li> </ul> <p>Dette taler imod at g\u00f8re brug af en arkitektur der underst\u00f8tter denne adskillelse og med klare gr\u00e6nser.</p>"},{"location":"Blog/Software-arkitektur-blog/2.%20Software%20arkitektur%20%26%20Design%20patterns./#refleksion","title":"Refleksion","text":"<p>At v\u00e6lge arkitektur til et givent projekt handler ikke om det er \"rigtigt eller forkert\" Det handler mere om hvad man pr\u00f8ver at l\u00f8se af problemer \"b\u00e5de nu og i fremtiden\" og det vil projektets karakter, krav og fremtidige prospekter v\u00e6re med til at afg\u00f8re.</p> <p>Det \"nemme\" og hurtige valg her ville v\u00e6re Layered arkitektur, MVC eller MVVM da de virker overskuelige og nemme at g\u00e5 til, og de giver alle en klar struktur til mindre komplicerede projekter. Derudover har vi stiftet bekendtskab til dem f\u00f8r i tidligere semestre.</p> <p>Men ved at gennemg\u00e5 de ovenst\u00e5ende dilemmaer i denne etape, der giver det mening at afpr\u00f8ve en anden arkitektur for at underst\u00f8tte projektet Jeg t\u00e6nker at komme lidt v\u00e6k fra de afpr\u00f8vede arkitekturer og implementere en af de andre muligheder jeg har gennemg\u00e5et.</p>"},{"location":"Blog/Software-arkitektur-blog/2.%20Software%20arkitektur%20%26%20Design%20patterns./#projekt-specifikt","title":"Projekt specifikt","text":"<p>Her er nogle ting, der virkede s\u00e6rligt vigtige for mit projekt:</p> <ul> <li>AI kommer til at leve sit eget liv</li> <li>Domain bliver st\u00f8rre end forventet og end den nuv\u00e6rende version af projektet vi st\u00e5r for at udvide.</li> <li>Der bliver mange features i UI</li> <li>Skalerbarhed er vigtigt</li> <li>Jeg kommer til at have mere end \u00e9t bounded context</li> </ul> <p>Derfor:</p> <ul> <li>Hvilken arkitektur underst\u00f8tter bedst et voksende dom\u00e6ne?</li> <li>Hvilken g\u00f8r AI-integration let og sikker?</li> <li>Hvilken g\u00f8r UI nemt at arbejde med i Blazor?</li> <li>Hvilken holder kode ren og testbar, selv n\u00e5r projektet vokser?</li> </ul> <p>Jeg besluttede mig for, at n\u00e6ste skridt m\u00e5tte v\u00e6re at unders\u00f8ge Clean Architecture lidt mere dybdeg\u00e5ende.</p>"},{"location":"Blog/Software-arkitektur-blog/3.%20Software%20arkitektur%20%26%20Design%20Patterns/","title":"**Jeg valgte Clean Architecture og modul\u00e6r monolith","text":""},{"location":"Blog/Software-arkitektur-blog/3.%20Software%20arkitektur%20%26%20Design%20Patterns/#mal-for-etapen","title":"M\u00e5l for etapen","text":"<p>I denne fase handlede det om at v\u00e6lge en retning for projektets arkitektur. Ikke som et stort akademisk valg, men som noget helt lavpraktisk: Hvordan skal vi strukturere projektet, s\u00e5 det b\u00e5de giver mening nu og ikke s\u00e6tter begr\u00e6nsninger senere?</p> <p>Jeg havde allerede f\u00e5et en fornemmelse af, at projektet ville vokse \u2014 b\u00e5de i forhold til dom\u00e6ner, brugerflows, AI og det hele generelt. Derfor skulle arkitekturen v\u00e6re et valg, jeg kunne arbejde videre p\u00e5 i mange uger uden at starte forfra hele tiden. Gennemg\u00e5 Clean architecture yderligere.</p>"},{"location":"Blog/Software-arkitektur-blog/3.%20Software%20arkitektur%20%26%20Design%20Patterns/#hvad-jeg-lrte","title":"Hvad jeg l\u00e6rte","text":"<p>Efter at have unders\u00f8gt forskellige arkitekturer \u2014 layered, clean, modul\u00e6r monolith, microservices og hexagonal \u2014 begyndte jeg at forst\u00e5, at forskellen ikke kun handler om teknik, men om hvordan systemet skal t\u00e6nkes og udvikles dog med mulighed for at integrere flere forskellige arkitekturer uden det er et problem eller en hindring, men mere en styrke for arkitekturen</p> <p>Clean Architecture blev hurtigt det, der gav mest mening for os. Ikke kun fordi det er \u201cp\u00e6nt\u201d eller moderne, men fordi det har en meget klar regel, der l\u00f8ser flere af vores kommende problemer: afh\u00e6ngigheder m\u00e5 kun pege ind mod dom\u00e6net.</p> <p>Det betyder, at vi kan bygge et dom\u00e6ne, der st\u00e5r helt rent og kan udvikles og testes uden st\u00f8j fra databaser, identity, AI eller UI. Og n\u00e5r projektet allerede nu har flere dom\u00e6ner (content, membership, reviews osv.), s\u00e5 giver det mening at dom\u00e6net kan st\u00e5 alene og h\u00e5ndtere sine dom\u00e6neopgaver uden indblanding fra andre lag.</p> <p>Samtidig gik det op for mig, at vi faktisk t\u00e6nkte mere modul\u00e6rt end jeg f\u00f8rst troede. Vi begyndte at se systemet som \u00e9n samlet applikation \u2014 men med klare interne moduler, fx:</p> <ul> <li>content-modulet</li> <li>membership-modulet</li> <li>review-modulet</li> <li>AI-modulet</li> </ul> <p>Derfor har jeg ogs\u00e5 f\u00e5et \u00f8je for modul\u00e6r monolith, som kunne v\u00e6re medvirkende til at give den adskillelse og modul\u00e6re opdeling. Sammenlagt bet\u00f8d det, at Clean Architecture kunne give lagdelingen, mens modul\u00e6r monolith kunne give formen og strukturen.</p> <p>[[2. Clean architecture og modul\u00e6r monolith.]]</p>"},{"location":"Blog/Software-arkitektur-blog/3.%20Software%20arkitektur%20%26%20Design%20Patterns/#refleksion","title":"Refleksion","text":"<p>Jeg overvejede stadig at starte projektet i en klassisk layered arkitektur, is\u00e6r fordi det er s\u00e5dan man typisk starter sm\u00e5 projekter. Men jeg kunne ogs\u00e5 se, at hvis vi alligevel skulle endte i Clean Architecture, s\u00e5 gav det ikke mening at begynde et andet sted og lave om igen senere.</p> <p>Det interessante her var, at jeg begyndte at forst\u00e5 forskellen p\u00e5 \u201clagdeling\u201d og \u201csystemform\u201d. Clean Architecture er lagene og retningen. Modul\u00e6r monolith er formen og m\u00e5den at holde dom\u00e6nerne adskilt.</p> <p>Og n\u00e5r der allerede var tegn p\u00e5, at AI skulle k\u00f8re i sin egen lille boble og helst isoleres fra dom\u00e6net, s\u00e5 var det oplagt at bygge noget, som kunne h\u00e5ndtere det fra starten.</p> <p>Jeg kunne ogs\u00e5 m\u00e6rke, at Clean Architecture ville g\u00f8re det lettere for teamet at dele arbejdet op. Alle kan arbejde i hver sit modul, uden at alt lander i \u00e9n stor muddy folder. Det var lige s\u00e5 meget et praktisk valg som et arkitektonisk valg.</p> <p>[[2. Clean architecture og modul\u00e6r monolith.]]</p>"},{"location":"Blog/Software-arkitektur-blog/3.%20Software%20arkitektur%20%26%20Design%20Patterns/#projekt-specifikt","title":"Projekt specifikt","text":"<p>Clean Architecture bliver den struktur, vi bygger projektet op omkring. Vi deler lagene op i Domain, Application, Infrastructure og Web, og derfra holder vi os til de regler, Clean Architecture stiller op.</p> <p>Samtidig t\u00e6nker vi projektet som en modul\u00e6r monolith, hvor dom\u00e6nerne er opdelt logisk, men systemet stadig deployes som \u00e9n enhed. Det betyder, at vi kan begynde sm\u00e5t, men stadig holde mulighederne \u00e5bne for fremtiden, hvor modulerne m\u00e5ske bliver st\u00f8rre eller mere adskilte.</p>"},{"location":"Blog/Software-arkitektur-blog/4.%20Software%20arkitektur%20%26%20Design%20patterns/","title":"Mine f\u00f8rste eksperimenter med patterns (CQRS + struktur)","text":""},{"location":"Blog/Software-arkitektur-blog/4.%20Software%20arkitektur%20%26%20Design%20patterns/#mal-for-etapen","title":"M\u00e5l for etapen","text":"<p>At afpr\u00f8ve nogle af de patterns, der kunne komme til at spille en rolle i projektet, og samtidig begynde at m\u00e6rke efter, hvordan de passer ind i den arkitektur jeg har valgt. Her er det prim\u00e6rt CQRS der er planen.</p>"},{"location":"Blog/Software-arkitektur-blog/4.%20Software%20arkitektur%20%26%20Design%20patterns/#hvad-jeg-lrte-denne-uge","title":"\ud83d\udcda Hvad jeg l\u00e6rte denne uge","text":"<p>Efter at have besluttet mig for Clean Architecture og en modul\u00e6r monolith som ramme, havde jeg brug for at finde ud af, hvilke m\u00f8nstre der kunne underst\u00f8tte use cases og forretningslogik.  </p> <p>Jeg valgte her is\u00e6r at kigge p\u00e5:</p> <ul> <li>CQRS</li> </ul> <p>Det er ret tydeligt, at CQRS passer rigtigt godt til vores projek</p> <ul> <li>Commands \u2192 handlinger</li> <li>Queries \u2192 l\u00e6sning</li> </ul> <p>Brugen af CQRS giver en tydeligere fornemmelse af, hvad en \u201cuse case\u201d er i projektet og opdelingen af ansvaret i forhold til l\u00e6sning og skrivning g\u00f8r det nemmere at gennemskue de metoder vi bruger i forhold til use cases.   Derfor valgte jeg at se n\u00e6rmere p\u00e5 CQRS som et grundelement i projektet.  Det er ogs\u00e5 godt til separation og som en form for struktur p\u00e5 CRUD operationer og som en form for ramme til vores features.  Jeg startede p\u00e5 denne gennemgang af CQRS: [[CQRS i vores projekt med vertical slice]]</p>"},{"location":"Blog/Software-arkitektur-blog/4.%20Software%20arkitektur%20%26%20Design%20patterns/#refleksion","title":"Refleksion","text":"<p>Det var ret tydeligt, at Clean Architecture og CQRS arbejder godt sammen. Clean Architecture gav lagene, mens CQRS gav struktur i lagene og en vej der var til at spore igennem lagene.</p>"},{"location":"Blog/Software-arkitektur-blog/4.%20Software%20arkitektur%20%26%20Design%20patterns/#projekt-specifikt","title":"\ud83d\udca1 Projekt specifikt","text":"<p>Jeg fik sat en tidlig mappestruktur op og begyndte at dele parts af systemet op i:</p> <ul> <li>Commands</li> <li>Queries</li> <li>Handlers</li> <li>Interfaces</li> </ul> <p>Det er p\u00e5 nuv\u00e6rende prim\u00e6rt en mappestruktur i forhold til clean og CQRS der er ved at v\u00e6re bygget. men det gav mig et godt fundament til de n\u00e6ste eksperimenter med andre  patterns.</p>"},{"location":"Blog/Software-arkitektur-blog/5.%20Software%20arkitektur%20%26%20Design%20patterns/","title":"Observer Pattern vs. Domain Events","text":""},{"location":"Blog/Software-arkitektur-blog/5.%20Software%20arkitektur%20%26%20Design%20patterns/#mal-for-etapen_","title":"M\u00e5l for etapen_","text":"<p>At afpr\u00f8ve nogle af de patterns jeg havde l\u00e6st om \u2014 is\u00e6r Observer og Domain Events \u2014 for at finde ud af, hvilke der faktisk gav mening i projektets arkitektur og i vores dom\u00e6nelogik. Her er det oplagt at kigge p\u00e5 begge to samtidigt da de kan opfylde lidt af samme form\u00e5l p\u00e5 forskellige niveauer.</p>"},{"location":"Blog/Software-arkitektur-blog/5.%20Software%20arkitektur%20%26%20Design%20patterns/#hvad-jeg-lrte-denne-uge_","title":"Hvad jeg l\u00e6rte denne uge_","text":"<p>[[Domain Events VS. Observer Pattern]]</p> <p>Jeg startede faktisk med Observer Pattern, mest fordi det er et m\u00f8nster man ofte st\u00f8der p\u00e5 tidligt, og det virker meget intuitivt: \u201cnoget \u00e6ndrer sig \u00e9t sted \u2192 noget andet reagerer automatisk.\u201d</p> <p>Det l\u00f8d som noget, vi kunne f\u00e5 gl\u00e6de af i projektet, is\u00e6r fordi vi har omr\u00e5der hvor der sker \u201c\u00e6ndringer\u201d, fx n\u00e5r der bliver oprettet nyt \"content\" eller \u00e6ndret i et \"membership\"</p> <p>Men da jeg lavede spikeprojektet og pr\u00f8vede Observer Pattern af, gik det hurtigt op for mig, at det ikke passede naturligt ind i vores arkitektur**.</p>"},{"location":"Blog/Software-arkitektur-blog/5.%20Software%20arkitektur%20%26%20Design%20patterns/#hvorfor-observer-pattern-ikke-rigtig-gav-mening-hos-os","title":"Hvorfor Observer Pattern ikke rigtig gav mening hos os","text":"<p>Det, der is\u00e6r stod klart, var:</p> <ul> <li>det ligger meget t\u00e6t p\u00e5 UI-t\u00e6nkning (\u201cjeg observerer en property\u201d)</li> <li>i Blazor sker der allerede automatiske UI-opdateringer via binding, s\u00e5 vi ville reelt bare lave dobbelt arbejde</li> <li>det binder tingene sammen p\u00e5 en m\u00e5de, som ikke matcher Clean Architecture</li> </ul> <p>Observer Pattern ville bare skabe kobling mellem omr\u00e5der, der ikke skal kende hinanden.</p> <p>Det passer fint i sm\u00e5 apps eller rene UI-scenarier og med mindre lagdeling end det vi sigter efter i vores projekt.</p>"},{"location":"Blog/Software-arkitektur-blog/5.%20Software%20arkitektur%20%26%20Design%20patterns/#hvor-domain-events-derimod-gav-mening","title":"Hvor Domain Events derimod gav mening","text":"<p>Da jeg s\u00e5 pr\u00f8vede Domain Event Pattern af var det lidt mere oplagt i min verden i forhold til projektet.</p> <p>For eksempel:</p> <ul> <li> <p>N\u00e5r der bliver oprettet et post, kan dom\u00e6net rejse et <code>PostCreatedEvent</code>.     Det betyder, at resten af systemet kan reagere \u2014 men dom\u00e6net er ligeglad med hvordan.</p> </li> <li> <p>N\u00e5r et membership \u00e6ndres til premium, kan dom\u00e6net rejse et <code>MembershipUpgradedEvent</code>.     Det giver os en naturlig hook til at opdatere permissions, sende notifikationer eller trigge noget i AI-modulet.</p> </li> <li> <p>N\u00e5r et review bliver oprettet, kan der s\u00e6ttes gang i moderation, scoreberegning eller andre processer \u2014 igen uden at review-logikken ved det.</p> </li> </ul> <p>Det der g\u00f8r Domain Events s\u00e5 st\u00e6rke i vores projekt er:</p> <ul> <li>dom\u00e6net st\u00e5r rent \u2014 ingen afh\u00e6ngigheder</li> <li>Application-laget h\u00e5ndterer eventet \u2014 hvor reglerne og flowet h\u00f8rer hjemme</li> <li>Infrastructure tager sig af side-effekter (emails, logs, AI-kald)</li> <li>vi kan bygge cross-module flows uden at flette modulerne sammen</li> <li>det passer til Clean Architectures krav om afh\u00e6ngighedsretning</li> <li>det forbereder os p\u00e5, at systemet kan vokse i moduler over tid</li> <li>Minimal coupling</li> </ul>"},{"location":"Blog/Software-arkitektur-blog/5.%20Software%20arkitektur%20%26%20Design%20patterns/#refleksion","title":"\ud83d\udca1 Refleksion","text":"<p>I starten troede jeg, at Observer Pattern og Domain Events var \u201cn\u00e6sten det samme\u201d. Men efter at have afpr\u00f8vet dem i praksis, kunne jeg se forskellen meget tydeligt:</p> <ul> <li>Observer Pattern er et simpelt, generelt m\u00f8nster (UI / lokale komponenter)</li> <li>Domain Events er et dom\u00e6necentreret m\u00f8nster (DDD / Clean Architecture)</li> </ul> <p>Domain Events passer direkte ind i Clean Architecture\u2019s afh\u00e6ngighedsregler, hvor dom\u00e6net faktisk er i centrum.</p> <p>Observer Pattern er fint i simple apps, men Domain Events gav mig et strukturelt v\u00e6rkt\u00f8j, som jeg kunne bygge videre p\u00e5 \u2014 b\u00e5de i Application-laget og i moduleringen af dom\u00e6net.</p>"},{"location":"Blog/Software-arkitektur-blog/5.%20Software%20arkitektur%20%26%20Design%20patterns/#projekt-specifikt","title":"\ud83d\udca1 Projekt specifikt","text":"<p>P\u00e5 det her tidspunkt var jeg begyndt at arbejde med Clean Architecture i mappestrukturen. Det bet\u00f8d prim\u00e6rt, at jeg fik opdelt projektet i de fire klare lag:</p> <ul> <li>Domain</li> <li>Application</li> <li>Infrastructure</li> <li>Web</li> </ul> <p>Det var ogs\u00e5 i den her fase, at Domain Events begyndte at give rigtig meget mening \u2014 is\u00e6r i content og membership.</p> <p>For eksempel:</p> <ul> <li> <p>N\u00e5r et nyt content-post blev oprettet, kunne jeg se et klart behov for at generere en h\u00e6ndelse, som senere kunne bruges til ting som notifikationer eller AI-analyse.</p> </li> <li> <p>N\u00e5r et membership blev opgraderet fra standard \u2192 premium, var det oplagt at markere det som en event, fordi det \u00e5bner for flere automatiske handlinger (fx opdatering af permissions, triggers til andre moduler osv.).</p> </li> </ul> <p>Selvom jeg ikke havde implementeret alle detaljer endnu, kunne jeg allerede se, at Domain Events ville blive en naturlig del af projektet. Det passede til m\u00e5den dom\u00e6net var ved at vokse p\u00e5 \u2014 og Clean Architecture gjorde det lettere at holde h\u00e6ndelserne renere og mere fokuserede.</p> <p>Det f\u00f8ltes som det f\u00f8rste rigtige skridt mod en l\u00f8sning, der kunne skaleres og udvides, uden at systemet blev rodet.</p>"},{"location":"Blog/Software-arkitektur-blog/6.%20Software%20arkitektur%20%26%20Design%20patterns/","title":"Factory og Strategy Patterns (og hvordan de passer ind i arkitekturen)","text":""},{"location":"Blog/Software-arkitektur-blog/6.%20Software%20arkitektur%20%26%20Design%20patterns/#mal-for-etapen","title":"M\u00e5l for etapen","text":"<p>At forst\u00e5 og afpr\u00f8ve Factory Pattern og Strategy Pattern i sm\u00e5 spikeprojekter \u2014 og se om de kunne bruges i projektet p\u00e5 en meningsfuld m\u00e5de.</p>"},{"location":"Blog/Software-arkitektur-blog/6.%20Software%20arkitektur%20%26%20Design%20patterns/#hvad-jeg-lrte-denne-uge","title":"\ud83d\udcda Hvad jeg l\u00e6rte denne uge","text":"<p>[[Semester/Software arkitektur og design pattern projekters/Projekter/Factory pattern|Factory pattern]] [[Semester/Software arkitektur og design pattern projekters/Projekter/Strategy pattern|Strategy pattern]]</p> <p>Efter at have arbejdet med Domain Events, blev mit fokus rettet mod to andre patterns, som ofte g\u00e5r igen i st\u00f8rre systemer: Factory og Strategy. Jeg lavede sm\u00e5 testprojekter for at forst\u00e5, hvad de hver is\u00e6r g\u00f8r, og hvordan de eventuelt kunne spille sammen med Clean Architecture og Vertical Slice.</p> <p>Factory Pattern viste sig at v\u00e6re ret intuitivt:</p> <ul> <li>det adskiller oprettelsen af objekter</li> <li>det g\u00f8r konstruktionen fleksibel</li> <li>det g\u00f8r det nemt at udvide med nye typer senere</li> </ul> <p>N\u00e5r jeg t\u00e6nkte p\u00e5 vores dom\u00e6ne, kunne jeg se flere steder, hvor en Factory kunne give mening \u2014 is\u00e6r hvis vi senere f\u00e5r forskellige typer content eller forskellige m\u00e5der at bygge posts p\u00e5. Der er en ide om, at en Factory kan \u201csamle\u201d oprettelseslogikken \u00e9t sted, s\u00e5 dom\u00e6nemodellerne kan holdes rene.</p> <p>Strategy Pattern gav et andet perspektiv og andre brugsscenarier:</p> <ul> <li>det handler mere om at udskifte adf\u00e6rd</li> <li>hver strategi har \u00e9n version af en metode</li> <li>du kan v\u00e6lge strategi i runtime afh\u00e6ngigt af behov</li> </ul> <p>Det var interessant, men jeg kunne hurtigt m\u00e6rke, at Strategy kun er n\u00f8dvendigt, hvis dom\u00e6net bliver komplekst nok til at kr\u00e6ve mange varianter af samme handling. Lige nu er projektet ikke helt d\u00e9r endnu, men det var stadig l\u00e6rerigt at se, hvordan man kan adskille logik og g\u00f8re den mere fleksibel.</p>"},{"location":"Blog/Software-arkitektur-blog/6.%20Software%20arkitektur%20%26%20Design%20patterns/#refleksion","title":"\ud83d\udca1 Refleksion","text":"<p>Det vigtigste for mig i denne fase var ikke at \u201cv\u00e6lge\u201d det rigtige pattern \u2014 men at l\u00e6re nok til at kunne tage stilling. Factory og Strategy er begge gode patterns, men de opfylder forskellige behov:</p> <ul> <li>Factory hj\u00e6lper med oprettelse</li> <li>Strategy hj\u00e6lper med variation i adf\u00e6rd</li> </ul> <p>I konteksten af vores Clean Architecture kunne jeg se, at:</p> <ul> <li>Factory passer bedst i Domain eller Application, hvor objekter oprettes</li> <li>Strategy kan v\u00e6re relevant, hvis vi f\u00e5r flere alternative m\u00e5der at validere, moderere eller generere content p\u00e5</li> </ul> <p>Begge patterns passer ind i den modul\u00e6re monolith og kan bruges uden at bryde Clean Architecture\u2019s afh\u00e6ngighedsregler.</p> <p>Men jeg besluttede ogs\u00e5, at Strategy ikke skal tages i brug \u201cbare fordi det findes\u201d. Det skal give mening i forhold til dom\u00e6nets kompleksitet og den konkrete use case.</p>"},{"location":"Blog/Software-arkitektur-blog/6.%20Software%20arkitektur%20%26%20Design%20patterns/#projekt-specifikt","title":"\ud83d\udca1 Projekt specifikt","text":"<p>P\u00e5 dette tidspunkt havde jeg:</p> <ul> <li>Clean Architecture p\u00e5 plads</li> <li>CQRS til use cases</li> <li>Domain Events integreret</li> </ul> <p>Factory pattern kan jeg se potentiale i til oprettelse af forskellige indholdstyper, men det er ikke et must fra start.</p> <p>Strategy pattern er noget, der kan komme i spil senere, fx hvis vi f\u00e5r:</p> <ul> <li>forskellige moderation-strategier</li> <li>forskellige content-regler</li> <li>alternative beregninger</li> <li>eller forskellige AI-svar-logikker</li> </ul> <p>Men indtil videre holder jeg det \u00e5bent.</p>"},{"location":"Blog/Software-arkitektur-blog/7.%20Software%20arkitektur%20%26%20Design%20patterns./","title":"Domain Events i Content-dom\u00e6net i bounded-context","text":""},{"location":"Blog/Software-arkitektur-blog/7.%20Software%20arkitektur%20%26%20Design%20patterns./#mal-for-etapen","title":"M\u00e5l for etapen","text":"<p>At arbejde med Domain Event Pattern i et konkret bounded context, nemlig vores Content omr\u00e5de. M\u00e5let var at afpr\u00f8ve og implementere, hvordan Domain Events fungerer i praksis, n\u00e5r der er flere sm\u00e5 regler, sideeffekter og flows, som skal h\u00e6nge sammen.</p>"},{"location":"Blog/Software-arkitektur-blog/7.%20Software%20arkitektur%20%26%20Design%20patterns./#hvad-jeg-lrte-denne-etape","title":"Hvad jeg l\u00e6rte denne etape","text":"<p>Nu hvor Clean Architecture og de f\u00f8rste patterns var p\u00e5 plads, begyndte jeg at se dom\u00e6net som noget mere \u201clevende\u201d. Is\u00e6r Content-delen havde mange naturlige h\u00e6ndelser:</p> <ul> <li>n\u00e5r en post bliver oprettet</li> <li>n\u00e5r en post bliver publiceret</li> <li>n\u00e5r et review tilf\u00f8jes</li> <li>n\u00e5r der skal laves et summary eller sendes en notifikation</li> </ul> <p>Jeg kunne tydeligt se, at \u00e9n handling ofte skulle s\u00e6tte gang i flere ting. Og det er pr\u00e6cis d\u00e9r Domain Events giver mening.</p> <p>Det blev tydeligt, at Domain Events fungerer bedst i:</p> <ul> <li>et rent dom\u00e6nelag (Clean Architecture)</li> <li>et omr\u00e5de med klare regler (Content)</li> <li>et bounded context, hvor der er flere sm\u00e5 flows</li> </ul>"},{"location":"Blog/Software-arkitektur-blog/7.%20Software%20arkitektur%20%26%20Design%20patterns./#refleksion","title":"Refleksion","text":"<p>Jeg kunne m\u00e6rke, at Domain Events passer perfekt ind i vores arkitektur, fordi:</p> <ul> <li>dom\u00e6net udl\u00f8ser events uden at kende noget om Infrastructure</li> <li>Application-laget kan h\u00e5ndtere dem stille og roligt</li> <li>Infrastructure tager sig af sideeffekter (fx AI, mails, persistence)</li> <li>det giver en naturlig opdeling efter SRP og SOLID</li> </ul> <p>Det f\u00f8ltes som det  \u201cbedste\u201d pattern, jeg har arbejdet med indtil nu. Ikke fordi det er kompliceret \u2014 men fordi det l\u00f8ser et reelt problem, nemlig hvordan man reagerer p\u00e5 dom\u00e6neh\u00e6ndelser uden at binde lagene sammen.</p>"},{"location":"Blog/Software-arkitektur-blog/7.%20Software%20arkitektur%20%26%20Design%20patterns./#projekt-specifikt","title":"Projekt specifikt","text":"<p>I Content-dom\u00e6net gav det mening at:</p> <ul> <li>lade Content-entiteter skabe events, n\u00e5r noget \u00e6ndrer sig</li> <li>lade Application-laget reagere via handlers</li> <li>lade Infrastructure udf\u00f8re sideeffekter</li> <li>holde UI helt ude af det</li> </ul> <p>Eksempel:</p> <p>N\u00e5r et post bliver publiceret:</p> <ol> <li>Dom\u00e6net opretter PostPublishedEvent</li> <li>Application fanger det og sender en opsummering</li> <li>Infrastructure s\u00f8rger for database-update, email eller AI-analyse</li> <li>Vertical Slice flowet holder det hele samlet i \u00e9n feature</li> </ol> <p>Denne kombination af Clean Architecture +  Domain Events fik Content-delen til at f\u00f8les som et rigtigt bounded context.</p>"},{"location":"Blog/Software-arkitektur-blog/8.%20%20Vertical%20Slice%20og%20en%20anden%20struktur%20p%C3%A5%20features./","title":"8. Vertical Slice og en anden struktur p\u00e5 features","text":""},{"location":"Blog/Software-arkitektur-blog/8.%20%20Vertical%20Slice%20og%20en%20anden%20struktur%20p%C3%A5%20features./#mal-for-etapen","title":"M\u00e5l for etapen","text":"<p>At f\u00e5 styr p\u00e5, hvordan mine use cases skulle organiseres i praksis \u2014 is\u00e6r i Blazor \u2014 og f\u00e5 en struktur, der kunne vokse sammen med projektets mange features og dom\u00e6ner. Jeg haren ide om at se p\u00e5 vertical slice til projektet ogs\u00e5.</p>"},{"location":"Blog/Software-arkitektur-blog/8.%20%20Vertical%20Slice%20og%20en%20anden%20struktur%20p%C3%A5%20features./#_hvad-jeg-lrte-denne-etape","title":"_Hvad jeg l\u00e6rte denne etape","text":"<p>Efter Clean Architecture var p\u00e5 plads, s\u00e5 havde vi:</p> <ul> <li>Commands</li> <li>Queries</li> <li>Domain Events</li> <li>CQRS</li> <li>og en masse kommende UI-flows</li> </ul> <p>Men alt f\u00f8ltes stadig lidt \u201cl\u00f8st\u201d. Jeg havde en fornemmelse af lag, men ikke af struktur inde i lagene.</p> <p>Det var her Vertical Slice Architecture begyndte at give mening.</p> <p>Jeg har tidligere opdaget at vi kan blande og g\u00f8re brug af det bedste fra forskellige arkitekturer og p\u00e5 det her stadie kunne det v\u00e6re rart med noget mere struktur over features jeg var begyndt at opbygge i projektet. Her giver vertical slice jo god mening, da det netop er hvad det g\u00f8r. giver en m\u00e5de at samle features i samspil med en clean arkitektur og en dom\u00e6nefokuseret t\u00e6nkning med bounded contekst.</p> <p>Det betyder, at hvis jeg arbejder p\u00e5 \u201cCreate Content\u201d, s\u00e5 ligger alt for den funktion i samme mappe:</p> <ul> <li>Razor-page</li> <li>ViewModel / FormModel</li> <li>Command</li> <li>Handler </li> <li>osv..</li> </ul>"},{"location":"Blog/Software-arkitektur-blog/8.%20%20Vertical%20Slice%20og%20en%20anden%20struktur%20p%C3%A5%20features./#8-vertical-slice-og-en-anden-struktur-pa-features","title":"[[8.  Vertical Slice og en anden struktur p\u00e5 features.]]","text":""},{"location":"Blog/Software-arkitektur-blog/8.%20%20Vertical%20Slice%20og%20en%20anden%20struktur%20p%C3%A5%20features./#refleksion","title":"Refleksion","text":"<p>Vertical Slice f\u00f8ltes som det naturlige n\u00e6ste skridt efter Clean Architecture, fordi:</p> <ul> <li>Clean gav os lagene</li> <li>Vertical Slice gav os m\u00e5den at bygge funktioner i lagene</li> <li>Domain Events gav mig m\u00e5den at reagere p\u00e5 dom\u00e6neh\u00e6ndelser</li> </ul> <p>Det gjorde gr\u00e6nserne mellem omr\u00e5derne mere synlige \u2014 og det er der DDD giver mening og kommer til syne.</p> <p>Jeg kunne nu se at:</p> <ul> <li>Content er sit eget omr\u00e5de\u201d</li> <li>\u201cMembership har sine egne regler og flows\u201d</li> <li>\u201cReviews h\u00f8rer til som en separat del\u201d</li> </ul> <p>Og fra Vertical Slice gik vejen n\u00e6sten automatisk videre til:</p> <p>Bounded Contexts \u2192 Entities \u2192 Aggregates \u2192 Domain Events (DDD-tankegangen)</p>"},{"location":"Blog/Software-arkitektur-blog/8.%20%20Vertical%20Slice%20og%20en%20anden%20struktur%20p%C3%A5%20features./#projekt-specifikt","title":"\ud83d\udca1 Projekt specifikt","text":"<p>Vertical Slice blev hurtigt en gamechanger i projektet.</p> <p>Det gjorde:</p> <ul> <li>UI meget lettere at arbejde med</li> <li>Use cases sm\u00e5 og overskuelige</li> <li>Dom\u00e6neomr\u00e5der tydeligere</li> <li>CQRS mere naturligt</li> <li>Flere features lettere at bygge (og fjerne)</li> <li>Testbarheden st\u00f8rre</li> <li>Domain Events nemmere at implementere</li> <li>Optimeret til mit team og selvst\u00e6ndigt arbejdsflow</li> </ul>"},{"location":"Blog/Software-arkitektur-blog/9.%20DDD%20-%20Forst%C3%A5else%20af%20dom%C3%A6net./","title":"9. DDD   Forst\u00e5else af dom\u00e6net.","text":""},{"location":"Blog/Software-arkitektur-blog/9.%20DDD%20-%20Forst%C3%A5else%20af%20dom%C3%A6net./#mal-for-etapen","title":"M\u00e5l for etapen","text":"<p>At forst\u00e5 DDD (Domain-Driven Design) p\u00e5 et niveau, hvor jeg kan se:</p> <ul> <li>hvordan det passer naturligt sammen med Clean Architecture</li> <li>hvorfor domain events begynder at give mening i det store billede</li> <li>hvordan vores projekt faktisk allerede bev\u00e6ger sig i en DDD-retning</li> <li>og hvilke beslutninger det f\u00f8rer til i forhold til struktur, bounded contexts og regler</li> </ul>"},{"location":"Blog/Software-arkitektur-blog/9.%20DDD%20-%20Forst%C3%A5else%20af%20dom%C3%A6net./#hvad-jeg-lrte","title":"\ud83d\udcda Hvad jeg l\u00e6rte","text":"<p>[[4. Dom\u00e6ne driven design - DDD patterns.]] I starten s\u00e5 DDD meget tungt ud og det var klart da vi startede projektet at det ikke skulle v\u00e6re alt dominerende for dette projekt n\u00f8dvendigvis. </p> <p>Men efter at have arbejdet med:</p> <ul> <li>vertical slice</li> <li>domain events i Content</li> <li>clean architecture</li> <li>og almindelig logisk dom\u00e6neopdeling</li> </ul> <p>Det kunne dermed bruges for os som en r\u00e6kke design principper og ved At DDD ikke er en arkitektur, men det er en m\u00e5de at t\u00e6nke dom\u00e6ne p\u00e5</p> <p>Det handler om at forst\u00e5 regler, relationer, begivenheder og betydning** i ens system.</p> <p>Efter vertical slice + domain events blev det meget tydeligt, at vi faktisk har:</p> <ul> <li>Content (posts, regler, publicering, validering)</li> <li>Membership (roller, premium, restriktioner)</li> <li>Review (ejer-feedback, billeder, kommentarer)</li> <li>Notifications</li> <li>AI (eksternt domain-modul)</li> </ul> <p>DDD handler ikke om, at alt skal ligge i \u00e9t k\u00e6mpe dom\u00e6ne. Det handler om at adskille omr\u00e5der, der har hver deres regler.---</p>"},{"location":"Blog/Software-arkitektur-blog/9.%20DDD%20-%20Forst%C3%A5else%20af%20dom%C3%A6net./#refleksion","title":"Refleksion","text":"<p>Det vigtigste jeg har indset er:</p> <p>DDD giver f\u00f8rst mening, n\u00e5r man forst\u00e5r dom\u00e6net \u2014 ikke f\u00f8r.</p> <p>I starten pr\u00f8vede jeg at forst\u00e5 DDD uden kontekst. Det var for abstrakt.</p> <p>Men nu, efter vertical slice + clean + domain events:</p> <ul> <li>dom\u00e6nerne er synlige</li> <li>reglerne er tydelige</li> <li>use cases er isolerede</li> <li> <p>domain events binder tingene sammen</p> </li> <li> <p>Clean Architecture = lagdelingen</p> </li> <li>Vertical Slice = workflows</li> <li>DDD = dom\u00e6neforst\u00e5else og sprog</li> </ul> <p>passes sammen som tre lag af samme proces.</p>"},{"location":"Blog/Software-arkitektur-blog/9.%20DDD%20-%20Forst%C3%A5else%20af%20dom%C3%A6net./#projekt-specifikt","title":"Projekt specifikt","text":"<p>Vores projekt har \u2014 ret naturligt \u2014 ledt os i retning af DDD:</p> <ul> <li>Vi har flere selvst\u00e6ndige dom\u00e6ner</li> <li>De har hver deres regler</li> <li>Domain events bruges allerede (ContentPublishedEvent osv.)</li> <li>Vertical slice definerer gr\u00e6nser mellem features</li> <li>AI er et eksternt bounded context i sig selv</li> </ul> <p>Jeg kan is\u00e6r se, at:</p> <p>Content er det mest dom\u00e6ne-rige omr\u00e5de. Der er regler for:</p> <ul> <li>publicering</li> <li>validering</li> <li>moderation</li> <li>ejerskab</li> <li>notifikationer</li> </ul> <p>Det giver helt naturligt mening at definere det som et bounded context.</p> <p>Membership og Review er p\u00e5 samme m\u00e5de deres egne sm\u00e5 dom\u00e6ner.</p> <p>Jeg kan derfor gradvist begynde at se, at jeg har struktureret projektet med DDD tankegangen allerede.</p> <p>Ikke alt skal overf\u00f8res 1:1 fra DDD-bogen \u2014 men tankegangen matcher vores arkitekturvalg.</p>"},{"location":"Generelt/","title":"Generelt \u2013 Oversigt","text":""},{"location":"Generelt/Deployment%20og%20services/","title":"Deployment & Services","text":""},{"location":"Generelt/Deployment%20og%20services/#5-infrastruktur-er-udskiftelig","title":"\u2b50 5) Infrastruktur er udskiftelig","text":"<ul> <li> <p>database</p> </li> <li> <p>email</p> </li> <li> <p>AI</p> </li> <li> <p>busser</p> </li> <li> <p>API'er</p> </li> </ul> <p>Kan \u00e6ndres uden at p\u00e5virke Domain eller Application.</p>"},{"location":"Generelt/Deployment%20og%20services/#6-mulighed-for-fremtidig-opsplitning-til-microservices","title":"\u2b50 6) Mulighed for fremtidig opsplitning til microservices","text":"<p>Modul\u00e6r monolith + Clean Architecture = naturlig vej til microservices senere.</p>"},{"location":"Generelt/Deployment%20og%20services/#7-ai-delen-er-teknisk-isoleret","title":"\u2b50 7) AI-delen er teknisk isoleret","text":"<p>S\u00e5 AI aldrig kan p\u00e5virke forretningsregler eller database direkte.</p>"},{"location":"Generelt/Deployment%20og%20services/#samlet-konklusion-den-korte-strke-stning","title":"\u2b50 Samlet konklusion \u2013 den korte, st\u00e6rke s\u00e6tning","text":"<p>Vi startede med en simpel monolith og layered architecture, men efterh\u00e5nden som projektets dom\u00e6ne voksede og fik dybere forretningslogik, domain events, AI-moduler og flere bounded contexts, blev layered for begr\u00e6nsende.</p> <p>Derfor skiftede vi til en modul\u00e6r monolith med Clean Architecture og Vertical Slice Pattern, fordi det giver rene afh\u00e6ngigheder, klar domain-adskillelse, bedre testbarhed, isoleret AI-integration og langt bedre skalerbarhed og vedligehold p\u00e5 lang sigt.</p> <p>Udgangspunktet \u2013 vi startede simpelt</p> <p>Monlith med layered architecture var f\u00f8rste indskydelse.</p> <p>I begyndelsen havde projektet bare:</p> <ul> <li>brugere</li> <li>simple blogposts</li> <li>et lille dashboard</li> </ul> <p>Man kunne i princippet have lavet alt i \u00e9t stort projekt. Men meget hurtigt havde du flere krav:</p> <ul> <li>anmeldelser (reviews)</li> <li>medlemskaber</li> <li>AI-chat</li> <li>profiler</li> <li>paywalled health-tips</li> </ul> <p>\u2192 Systemet voksede i funktionalitet.</p> <p>Dette gjorde at vi gik fra monolith med layered N-tier arkitektur gik til clean architecture lagdeling.</p>"},{"location":"Generelt/Deployment%20og%20services/#vi-valgte-clean-architecture-for-at-holde-kerne-logikken-ren","title":"Vi valgte Clean Architecture for at holde kerne-logikken ren","text":"<p>Vi \u00f8nskede:</p> <ul> <li>klare gr\u00e6nser mellem lag</li> <li>minimal coupling</li> <li>testbarhed</li> <li>adskillelse mellem dom\u00e6ne og infrastruktur</li> </ul> <p>Derfor endte vi med:</p> <ul> <li> <p>Domain (entities, regler, events)</p> </li> <li> <p>Application (use cases, interfaces)</p> </li> <li> <p>Infrastructure (DB, repos, email, gateways)</p> </li> <li> <p>Web (UI, vertical slices)</p> </li> </ul> <p>Clean Architecture var naturligt her, fordi det:</p> <p>holder dom\u00e6net rent  sikrer klare gr\u00e6nser  g\u00f8r det let at vokse senere  er moderne og forst\u00e5et af virksomheder</p>"},{"location":"Generelt/Deployment%20og%20services/#3-behavior-voksede-vertical-slice-architecture-var-ndvendig","title":"3\ufe0f\u20e3 Behavior voksede \u2013 Vertical Slice Architecture var n\u00f8dvendig","text":"<p>Blazor-delen var begyndt at f\u00e5:</p> <ul> <li> <p>Create/Edit/Delete</p> </li> <li> <p>moderationsflows</p> </li> <li> <p>paywall-checks</p> </li> <li> <p>sub-features (video review, image review, text review)</p> </li> <li> <p>chat integration</p> </li> </ul> <p>Det blev for tungt at l\u00e6gge alt i standard MVC- eller mappe-opdeling. Derfor valgte vi Vertical Slice Architecture for Web-laget:</p> <ul> <li> <p><code>/Posts/Create</code></p> </li> <li> <p><code>/Reviews/Owner/CreateImage</code></p> </li> <li> <p><code>/Membership/Activate</code></p> </li> <li> <p>osv.</p> </li> </ul> <p>Hver \"feature\" fik sin egen lille mini-mappe med:</p> <ul> <li> <p>sin egen component</p> </li> <li> <p>sin egen handler</p> </li> <li> <p>sin egen route</p> </li> <li> <p>sin egen validation</p> </li> </ul> <p>\u2192 Dette er modul\u00e6r monolit i praksis.</p>"},{"location":"Generelt/Deployment%20og%20services/#4-skulle-det-vre-microservices-nej-og-det-blev-et-bevidst-valg","title":"4\ufe0f\u20e3 Skulle det v\u00e6re microservices? \u2192 Nej, og det blev et bevidst valg","text":"<p>Vi diskuterede microservices flere gange:</p> <p>FOR microservices:</p> <ul> <li> <p>isoleret skalering</p> </li> <li> <p>teams kan arbejde uafh\u00e6ngigt</p> </li> <li> <p>god til meget store systemer</p> </li> </ul> <p>IMOD microservices:</p> <ul> <li> <p>du skal have orchestration</p> </li> <li> <p>distributed tracing</p> </li> <li> <p>logging p\u00e5 tv\u00e6rs</p> </li> <li> <p>event-bus</p> </li> <li> <p>for meget kompleksitet til dit behov</p> </li> </ul> <p>Dit projekt havde \u00e9t team (dig selv) og \u00e9t dom\u00e6ne.</p> <p>\u2192 Microservices ville v\u00e6re overkill og g\u00f8re projektet langsommere og mere komplekst.</p>"},{"location":"Generelt/Deployment%20og%20services/#5-ai-delen-passede-ikke-i-net","title":"5\ufe0f\u20e3 AI-delen passede ikke i .NET","text":"<p>Da du begyndte at arbejde med AI-chat, embeddings og vektor-databaser, opstod sp\u00f8rgsm\u00e5let:</p> <p>Skal AI-delen bygges i samme .NET-projekt?</p> <p>\u27a1\ufe0f Svaret blev NEJ, fordi:</p> <ul> <li> <p>Python har langt bedre bibliotek-st\u00f8tte (Chroma, huggingface, LLM-agenter, etc.)</p> </li> <li> <p>Det k\u00f8rer bedre isoleret</p> </li> <li> <p>Det kan skaleres separat</p> </li> <li> <p>Det kan k\u00f8re lokalt eller i Docker uden at p\u00e5virke appen</p> </li> </ul> <p>Derfor blev AI-delen sin egen eksterne service.</p> <p>\u2192 Dette er ikke microservices, men external service integration.</p>"},{"location":"Generelt/Deployment%20og%20services/#6-derfor-endte-vi-med-en-modulr-monolit","title":"6\ufe0f\u20e3 Derfor endte vi med en modul\u00e6r monolit","text":"<p>Summen af alle beslutninger:</p> Punkt Consequence Du vil gerne holde intern kompleksitet nede Monolit i kernen Du vil gerne holde features isoleret Vertical Slices Du vil f\u00f8lge Clean Architecture som skole + industristandard Domain/Application/Infrastructure Du vil have AI i Python Ekstern service Du vil have noget, der kan dockeriseres Moduler + services i compose Du vil skalere AI uden at skalere .NET Python separat <p>Den bedste kombination blev:</p>"},{"location":"Generelt/Deployment%20og%20services/#modulr-monolit-clean-architecture-vertical-slices","title":"\ud83d\udfe9 Modul\u00e6r monolit (Clean Architecture + Vertical Slices)","text":""},{"location":"Generelt/Deployment%20og%20services/#ekstern-ai-service-i-python","title":"\ud83d\udfe6 Ekstern AI-service i Python","text":""},{"location":"Generelt/Deployment%20og%20services/#postgres-database-som-flles-persistence-lag","title":"\ud83d\udfe7 Postgres database som f\u00e6lles persistence-lag","text":"<p>Dette er moderne arkitektur. Det er pr\u00e6cis det, mange startups bruger i dag, inkl. dem der senere skalerer til microservices.</p>"},{"location":"Generelt/Deployment%20og%20services/#hvorfor-det-er-en-modulr-monolit","title":"Hvorfor det er en modul\u00e6r monolit","text":""},{"location":"Generelt/Deployment%20og%20services/#1-alt-domnet-er-samlet-i-et-system","title":"\u2714 1. Alt dom\u00e6net er samlet i \u00e9t system","text":"<p>Du har:</p> <ul> <li> <p>Domain</p> </li> <li> <p>Application</p> </li> <li> <p>Infrastructure</p> </li> <li> <p>Web (Blazor Server)</p> </li> </ul> <p>\u2192 Alt er i \u00e9n codebase og \u00e9n samlet deploybar enhed.</p>"},{"location":"Generelt/Deployment%20og%20services/#2-men-det-er-opdelt-i-moduler","title":"\u2714 2. Men det er opdelt i moduler","text":"<p>I Web-laget har du Vertical Slice feature-mapper:</p> <p><code>/Posts /Reviews /Profiles /Membership /Chat</code></p> <p>Hver \u201cfeature\u201d fungerer som et lille modul med sine egne handlers, DTO'er, components, repo-calls osv.</p> <p>Det er definitionen p\u00e5 modul\u00e6r monolit.</p>"},{"location":"Generelt/Deployment%20og%20services/#3-ingen-services-er-selvstndigt-deployet","title":"\u2714 3. Ingen services er selvst\u00e6ndigt deployet","text":"<p>Du deployer systemet som \u00e9t system, ikke som 10 mikroservices.</p>"},{"location":"Generelt/Deployment%20og%20services/#hvorfor-det-ikke-er-en-mikroservice-arkitektur","title":"Hvorfor det ikke er en mikroservice-arkitektur","text":"<ul> <li> <p>Ingen selvst\u00e6ndige bounded context services.</p> </li> <li> <p>Ingen event-bus mellem services.</p> </li> <li> <p>Ingen independent deployment.</p> </li> <li> <p>Database deles i \u00e9t EF Core AppDbContext.</p> </li> </ul> <p>Du har dog en lille service:</p>"},{"location":"Generelt/Deployment%20og%20services/#python-ai-agenten-en-ekstern-service-ikke-en-microservice-arkitektur","title":"\u2714 Python AI-agenten \u2192 en ekstern service, ikke en microservice-arkitektur","text":"<p>Den k\u00f8rer som:</p> <ul> <li> <p>et selvst\u00e6ndigt API / container</p> </li> <li> <p>men uden eget bounded domain     \u2192 mere som et external integration service, ikke en microservice.</p> </li> </ul>"},{"location":"Generelt/Deployment%20og%20services/#hvorfor-det-heller-ikke-er-en-klassisk-monolith","title":"Hvorfor det heller ikke er en klassisk monolith","text":"<p>En klassisk monolith = \u00e9t projekt, typisk lagdelt, uden modulopdeling.</p> <p>Din arkitektur:</p> <ul> <li> <p>Clean Architecture (Domain, Application, Infrastructure)</p> </li> <li> <p>Vertical Slices i Web</p> </li> <li> <p>AI-gateway ud i Python-container     \u2192 det er modul\u00e6rt opbygget, ikke \u00e9t stort sammenklumpet projekt.</p> </li> </ul>"},{"location":"Generelt/Deployment%20og%20services/#hvordan-projektet-bliver-deployet","title":"Hvordan projektet bliver deployet","text":"<p>Den deployment-model vi snakkede mest om:</p>"},{"location":"Generelt/Deployment%20og%20services/#net-hele-christians-side-som-en-container","title":".NET (hele Christians Side) \u2192 som \u00e9n container","text":"<ul> <li> <p>Domain + Application + Infrastructure + Web (Blazor Server)</p> </li> <li> <p>EF Core database (Postgres i egen container)</p> </li> </ul>"},{"location":"Generelt/Deployment%20og%20services/#python-ai-service-egen-container","title":"Python AI-service \u2192 egen container","text":"<ul> <li>Sammen med egen vektorstore (Chroma eller Postgres embeddings)</li> </ul>"},{"location":"Generelt/Deployment%20og%20services/#docker-compose-orkestrerer-dem","title":"\u2192 Docker Compose orkestrerer dem:","text":"<p><code>app (Blazor Server) db (Postgres) ai-service (Python) ai-vector-db (Postgres/Chroma)</code></p> <p>Det er klassisk modul\u00e6r monolit + eksterne services.</p>"},{"location":"Generelt/Samfundsm%C3%A6ssige%20aspekter/","title":"Samfundsm\u00e6ssige aspekter af softwarearkitektur og AI-integration","text":"<p>Softwarearkitektur handler ikke kun om teknik; den har ogs\u00e5 tydelige samfundsm\u00e6ssige konsekvenser. I vores projekt bliver dette is\u00e6r tydeligt, fordi vi arbejder med b\u00e5de AI, persondata, sundhedsindhold og brugergenereret content. Valget af arkitektur p\u00e5virker derfor b\u00e5de brugernes sikkerhed, systemets kvalitet og fremtidens mulighed for vedligehold og udvikling.</p>"},{"location":"Generelt/Samfundsm%C3%A6ssige%20aspekter/#1-sikkerhed-og-ansvarlig-datahandtering-samfundsperspektiv","title":"1. Sikkerhed og ansvarlig datah\u00e5ndtering (samfundsperspektiv)","text":"<p>En ren og velstruktureret arkitektur (Clean Architecture + modul\u00e6r monolith) har stor betydning for datasikkerhed. N\u00e5r:</p> <ul> <li> <p>dom\u00e6nelaget er isoleret</p> </li> <li> <p>AI ikke har direkte adgang til databasen</p> </li> <li> <p>UI ikke kender forretningslogik</p> </li> <li> <p>infrastrukturen er tydeligt adskilt</p> </li> </ul> <p>\u2026s\u00e5 reduceres risikoen for datal\u00e6k, misbrug og uautoriseret adgang.</p> <p>I et samfund hvor data (is\u00e6r helbredsdata) er ekstremt f\u00f8lsomme, er dette en essentiel del af ansvarlig softwareudvikling.</p>"},{"location":"Generelt/Samfundsm%C3%A6ssige%20aspekter/#2-bredygtighed-og-langsigtet-digital-infrastruktur","title":"2. B\u00e6redygtighed og langsigtet digital infrastruktur","text":"<p>D\u00e5rligt designede systemer for\u00e6ldes hurtigt og kr\u00e6ver:</p> <ul> <li> <p>dyr vedligeholdelse</p> </li> <li> <p>store omskrivninger</p> </li> <li> <p>ressourcetunge driftsmilj\u00f8er</p> </li> <li> <p>risiko for fejl og ustabilitet</p> </li> </ul> <p>Ved at bygge en modul\u00e6r monolith:</p> <ul> <li> <p>kan systemet vokse gradvist</p> </li> <li> <p>moduler kan udskiftes uden at genopbygge alt</p> </li> <li> <p>AI-delen kan skaleres uafh\u00e6ngigt</p> </li> <li> <p>driftsomkostninger holdes nede (\u00f8konomisk b\u00e6redygtighed)</p> </li> </ul> <p>God arkitektur har derfor en samfunds\u00f8konomisk dimension, fordi robuste systemer sparer tid, penge og energi \u2014 b\u00e5de for virksomheder, det offentlige og brugerne.</p>"},{"location":"Generelt/Samfundsm%C3%A6ssige%20aspekter/#3-samfundsmssig-tillid-til-ai-baserede-systemer","title":"3. Samfundsm\u00e6ssig tillid til AI-baserede systemer","text":"<p>N\u00e5r AI integreres forkert, risikerer man:</p> <ul> <li> <p>mangel p\u00e5 gennemsigtighed</p> </li> <li> <p>bias i beslutningsprocesser</p> </li> <li> <p>fejlfortolkning af data</p> </li> <li> <p>manglende kontrol over forretningskritiske flows</p> </li> </ul> <p>Ved at placere AI som eksternt modul i vores arkitektur (ikke i Domain, ikke i Application), f\u00e5r vi:</p> <ul> <li> <p>kontrol over hvilke data AI f\u00e5r adgang til</p> </li> <li> <p>mulighed for at udskifte eller forbedre AI uden risiko</p> </li> <li> <p>transparens i hvordan AI bruges</p> </li> <li> <p>bedre mulighed for revision og dokumentation</p> </li> </ul> <p>Dette bidrager til digital ansvarlighed \u2014 en central samfundspraksis i dag.</p>"},{"location":"Generelt/Samfundsm%C3%A6ssige%20aspekter/#4-kvalitet-robusthed-og-brugeroplevelse-som-samfundsvrdi","title":"4. Kvalitet, robusthed og brugeroplevelse som samfundsv\u00e6rdi","text":"<p>Software er en del af vores dagligdag, og kvaliteten p\u00e5virker mennesker direkte. En gennemt\u00e6nkt arkitektur sikrer:</p> <ul> <li> <p>f\u00e6rre fejl</p> </li> <li> <p>bedre brugeroplevelser</p> </li> <li> <p>mindre frustration</p> </li> <li> <p>h\u00f8jere tilg\u00e6ngelighed</p> </li> <li> <p>mindre mental belastning hos brugerne</p> </li> </ul> <p>For et sundhedsorienteret projekt som dit, hvor brugere m\u00e5ske s\u00f8ger hj\u00e6lp, information eller st\u00f8tte, er systemets stabilitet og tydelighed en vigtig samfundsm\u00e6ssig faktor.</p>"},{"location":"Generelt/Samfundsm%C3%A6ssige%20aspekter/#5-arkitekturens-betydning-for-udviklere-og-teamwork","title":"5. Arkitekturens betydning for udviklere og teamwork","text":"<p>En god arkitektur har ogs\u00e5 sociale konsekvenser:</p> <ul> <li> <p>teams kan samarbejde bedre</p> </li> <li> <p>nye udviklere kan onboardes hurtigere</p> </li> <li> <p>man undg\u00e5r teknisk g\u00e6ld, som dr\u00e6ner tid og ressourcer</p> </li> <li> <p>man sikrer, at systemer kan leve i 5, 10 eller 20 \u00e5r</p> </li> </ul> <p>I et samfund hvor softwareprojekter ofte vokser i kompleksitet, og hvor flere udviklere skal kunne arbejde p\u00e5 samme kodebase, bliver arkitektur et arbejdsmilj\u00f8m\u00e6ssigt aspekt \u2014 ikke kun et teknisk.</p>"},{"location":"Generelt/Samfundsm%C3%A6ssige%20aspekter/#kort-konklusion","title":"\u2b50 Kort konklusion","text":"<p>Softwarearkitektur har klare samfundsm\u00e6ssige konsekvenser. Ved at v\u00e6lge en ren, modulariseret og ansvarlig arkitektur mindsker man risici, beskytter brugernes data, reducerer omkostninger, skaber bedre brugeroplevelser, bygger mere b\u00e6redygtige digitale systemer og underst\u00f8tter ansvarlig AI-anvendelse.</p> <p>God arkitektur er derfor ikke kun teknisk korrekt, men ogs\u00e5 samfundsm\u00e6ssigt ansvarlig.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/","title":"Refleksioner","text":"<p>Her kommer en refleksion, der binder det hele sammen: \u2013 MVC (som ASP.NET-controllers) \u2013 MVVM (som UI-pattern i Blazor) \u2013 hvorn\u00e5r man bruger hvad \u2013 hvordan det relaterer sig til dit projekt \u2013 og hvorfor MVC/MVVM ikke er \u201carkitekturer\u201d, men stadig er vigtige.</p> <p>Det er skrevet i en akademisk/refleksiv tone, s\u00e5 du kan bruge det direkte i rapport/blog.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#refleksion-mvc-og-mvvm-i-forhold-til-vores-projekt-og-valgte-arkitektur","title":"\u2b50 Refleksion: MVC og MVVM i forhold til vores projekt og valgte arkitektur","text":""},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#mvc-i-praksis-controller-baseret-ui-og-klassisk-webflow","title":"MVC i praksis \u2014 controller-baseret UI og klassisk webflow","text":"<p>I undervisningen l\u00e6rte vi MVC gennem ASP.NET MVC, hvor:</p> <ul> <li> <p>Controlleren h\u00e5ndterer HTTP-requests</p> </li> <li> <p>Modellen repr\u00e6senterer de data, som viewet skal vise</p> </li> <li> <p>Viewet er en Razor Page (.cshtml), der renderes af serveren</p> </li> </ul> <p>Det er en klassisk server-renderet webmodel, hvor hvert klik f\u00f8rer til et nyt HTTP-request og en ny server-side rendering.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#refleksion","title":"Refleksion:","text":"<p>MVC giver en klar separation i UI'et og fungerer godt til traditionelle webapplikationer, hvor hvert request er selvst\u00e6ndigt. Men i vores projekt havde vi brug for:</p> <ul> <li> <p>real-time UI-opdateringer</p> </li> <li> <p>fulde komponenter med state</p> </li> <li> <p>kompleks interaktion (chat, medlemsskabsh\u00e5ndtering, AI-integration)</p> </li> <li> <p>data binding i UI'et</p> </li> </ul> <p>Dette passer ikke godt til MVC\u2019s stateless request-model.</p> <p>MVC er alts\u00e5 st\u00e6rkt til struktureret server-baseret UI, men det passer ikke til et moderne, interaktivt Blazor-baseret system.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#mvvm-implicit-blazor-moderne-ui-med-data-binding-og-stateful-logik","title":"MVVM (implicit Blazor) \u2014 moderne UI med data-binding og stateful logik","text":"<p>Blazor bruger ikke \u201cren MVVM\u201d, men det er meget t\u00e6t p\u00e5:</p> <ul> <li> <p>View (Razor Component) = markup + UI</p> </li> <li> <p>ViewModel = C# kode-behind + state + eventh\u00e5ndtering</p> </li> <li> <p>Model = de dataobjekter og DTO\u2019er UI\u2019et arbejder med</p> </li> </ul> <p>Blazor tillader:</p> <ul> <li> <p>tovejrs data-binding (<code>@bind</code>)</p> </li> <li> <p>stateful komponenter</p> </li> <li> <p>eventbaseret logik</p> </li> <li> <p>real-time rendering via SignalR (Server)</p> </li> <li> <p>separation mellem UI og application\u2192domain</p> </li> </ul>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#refleksion_1","title":"Refleksion:","text":"<p>MVVM-lignende m\u00f8nstre passer perfekt til vores projekt, fordi:</p> <ul> <li> <p>UI\u2019et er interaktivt</p> </li> <li> <p>der er meget kompleks UI-state</p> </li> <li> <p>vi har flows som chat, bookings, medlemsskab, content-redigering</p> </li> <li> <p>UI\u2019et skal respondere uden reload</p> </li> <li> <p>vi vil holde UI og forretningsregler adskilt</p> </li> <li> <p>ViewModel taler kun til Application-lag via mediator \u2192 domain</p> </li> </ul> <p>Her giver MVVM (i Blazor-versionen) renere UI og bedre separation end MVC kunne.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#mvc-vs-mvvm-i-forhold-til-vores-systemarkitektur","title":"\u2b50 MVC vs MVVM i forhold til vores systemarkitektur","text":"<p>N\u00e5r vi s\u00e6tter MVC/MVVM i forhold til Clean Architecture + Vertical Slice + DDD, bliver forskellen tydelig:</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#mvcs-rolle-i-systemet-hvis-det-var-brugt","title":"MVC\u2019s rolle i systemet (hvis det var brugt):","text":"<ul> <li> <p>ville ligge 100% i UI-laget</p> </li> <li> <p>ville IKKE p\u00e5virke Domain/Application/Infrastructure</p> </li> <li> <p>ville v\u00e6re en teknik til at strukturere UI views</p> </li> </ul>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#mvvms-rolle-i-systemet-blazor","title":"MVVM\u2019s rolle i systemet (Blazor):","text":"<ul> <li> <p>ligger ogs\u00e5 i UI-laget</p> </li> <li> <p>fungerer som UI-arkitektur oven p\u00e5 Clean Architecture</p> </li> <li> <p>UI kalder Application-lag via Mediator</p> </li> <li> <p>ViewModel indeholder UI-state, ikke dom\u00e6nelogik</p> </li> </ul> <p>Begge er UI-patterns \u2014 ikke systemarkitekturer.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#hvornar-bruger-man-hvad-i-et-professionelt-projekt","title":"\u2b50 Hvorn\u00e5r bruger man hvad i et professionelt projekt?","text":""},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#man-bruger-mvc-nar","title":"\u2714 Man bruger MVC n\u00e5r:","text":"<ul> <li> <p>applikationen er prim\u00e6rt stateless</p> </li> <li> <p>man laver klassisk request/response UI</p> </li> <li> <p>SEO-optimering er vigtigt</p> </li> <li> <p>man har simple UI\u2019er (fx formularer og tabeller)</p> </li> <li> <p>man bygger et REST-API via controllers</p> </li> </ul> <p>MVC passer ogs\u00e5 til microservices-API\u2019er, fordi controllers er gode entry-points.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#man-bruger-mvvmblazor-nar","title":"\u2714 Man bruger MVVM/Blazor n\u00e5r:","text":"<ul> <li> <p>UI\u2019et skal v\u00e6re interaktivt og dynamisk</p> </li> <li> <p>der er komplekse flows (chat, live opdateringer, AI-interaktion)</p> </li> <li> <p>brugeren bliver i samme UI uden reload</p> </li> <li> <p>komponentbaseret udvikling giver v\u00e6rdi</p> </li> <li> <p>man vil have st\u00e6rk separation mellem UI og forretningslag</p> </li> </ul> <p>Det er netop den situation vi har i projektet.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#refleksion-ift-vores-projekt","title":"\u2b50 Refleksion ift. vores projekt","text":"<p>I vores projekt:</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#1-mvc-blev-fravalgt-som-ui-teknologi","title":"1) MVC blev fravalgt som UI-teknologi","text":"<p>Fordi:</p> <ul> <li> <p>MVC kan ikke h\u00e5ndtere real-time opdateringer</p> </li> <li> <p>MVC kr\u00e6ver reloads</p> </li> <li> <p>MVC\u2019s struktur passer ikke til komponenter</p> </li> <li> <p>MVC er ikke designet til moderne, stateful webapps</p> </li> </ul> <p>Til geng\u00e6ld kunne MVC godt bruges som API-lag (controller-baseret API), men vi valgte Mediator + Clean Architecture i stedet.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#2-mvvm-via-blazor-passer-til-vores-arkitektur","title":"2) MVVM (via Blazor) passer til vores arkitektur","text":"<p>Fordi:</p> <ul> <li> <p>det holder UI rent og logik i ViewModel</p> </li> <li> <p>UI snakker struktureret med Application-laget (CQRS)</p> </li> <li> <p>UI-bindinger h\u00e5ndterer state uden reloads</p> </li> <li> <p>passer direkte ovenp\u00e5 Clean Architecture</p> </li> <li> <p>UI bliver fleksibelt og modul\u00e6rt</p> </li> </ul>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#3-mvc-og-mvvm-er-kun-ui-mnstre-resten-af-arkitekturen-flger-clean-architecture-vertical-slice-ddd","title":"3) MVC og MVVM er kun UI-m\u00f8nstre \u2014 resten af arkitekturen f\u00f8lger Clean Architecture + Vertical Slice + DDD","text":"<p>Selvom MVC og MVVM definerer UI-strukturen, bestemmer de ALDRIG:</p> <ul> <li> <p>hvordan domain er struktureret</p> </li> <li> <p>hvor forretningsregler bor</p> </li> <li> <p>hvordan events rejser</p> </li> <li> <p>hvordan repos er bygget</p> </li> <li> <p>hvordan AI-moduler kobles p\u00e5</p> </li> <li> <p>hvordan systemet skalerer</p> </li> <li> <p>hvordan modul\u00e6r monolith er organiseret</p> </li> </ul> <p>Alt dette bestemmes af Clean Architecture + DDD + Vertical Slice, ikke af MVC/MVVM.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#kort-tekst-klar-til-rapportblog","title":"\u2b50 Kort tekst (klar til rapport/blog)","text":"<p>I undervisningen arbejdede vi b\u00e5de med MVC og MVVM som UI-design patterns. MVC bruges i ASP.NET til at strukturere server-renderede webapplikationer via Controller, Model og View. Blazor anvender derimod et MVVM-lignende m\u00f8nster, hvor Views er komponenter og ViewModels h\u00e5ndterer UI-state og logik.</p> <p>Begge teknikker h\u00f8rer til i UI-laget, ikke i systemarkitekturen. I vores projekt valgte vi Blazor/MVVM-tilgangen, fordi den underst\u00f8tter interaktive komponenter, data-binding og et moderne eventdrevet UI. MVC ville ikke passe til et system med real-time UI, AI-integration, komplekse flows og et CQRS-drevet Application Layer.</p> <p>Derfor ligger MVC og MVVM kun i pr\u00e6sentationslaget, mens systemets egentlige arkitektur bygger p\u00e5 Clean Architecture, Vertical Slice og DDD.</p> <p>Hvis du vil, kan jeg:</p> <p>\u2714 lave en grafisk illustration til rapporten \u2714 lave en kort eksamenss\u00e6tning til mundtlig freml\u00e6ggelse \u2714 lave et lille \u201cUI patterns vs systemarkitektur\u201d afsnit</p> <p>Bare sig til!</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#perspektivering-hvordan-dette-forlb-hnger-sammen-med-uddannelsens-vrige-fag","title":"\u2b50 Perspektivering: Hvordan dette forl\u00f8b h\u00e6nger sammen med uddannelsens \u00f8vrige fag","text":"<p>Selvom fokus i dette forl\u00f8b har v\u00e6ret softwarearkitektur og design patterns, bygger forst\u00e5elsen direkte videre p\u00e5 n\u00e6sten alle tidligere semestre og fagomr\u00e5der. Arkitekturvalg bliver nemlig f\u00f8rst meningsfulde, n\u00e5r de ses i sammenh\u00e6ng med den teknologiske og programmatiske viden, der er opbygget under uddannelsen.</p> <p>Nedenfor er en kort perspektivering, som binder det hele sammen.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#1-programmering-c-fundamentet-for-clean-architecture-ddd-og-patterns","title":"1. Programmering (C#) \u2192 Fundamentet for Clean Architecture, DDD og patterns","text":"<p>Alt v\u00e5rt arkitekturarbejde hviler p\u00e5 grundl\u00e6ggende programmeringsf\u00e6rdigheder:</p> <ul> <li> <p>klasser, interfaces, inheritance</p> </li> <li> <p>events, async/await</p> </li> <li> <p>collections og datastrukturer</p> </li> <li> <p>separation of concerns</p> </li> </ul> <p>Uden dette kunne vi ikke:</p> <ul> <li> <p>implementere domain entities</p> </li> <li> <p>skrive clean domain logic</p> </li> <li> <p>anvende Strategy, Factory, Repository</p> </li> <li> <p>arbejde med CQRS og commands/queries</p> </li> </ul> <p>Perspektiv: Programmeringsfaget gav os sproget \u2013 arkitekturen giver os grammatiken.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#2-ui-udvikling-mvc-blazor-forstaelse-af-prsentationsmnstre","title":"2. UI-udvikling (MVC &amp; Blazor) \u2192 Forst\u00e5else af pr\u00e6sentationsm\u00f8nstre","text":"<p>Tidligere har vi arbejdet med:</p> <ul> <li> <p>MVC \u2192 server-renderet arkitektur, controller-flow</p> </li> <li> <p>Blazor (MVVM-inspireret) \u2192 komponenter, state management, binding</p> </li> </ul> <p>Denne viden er essentiel for at forst\u00e5:</p> <ul> <li> <p>hvorfor MVC ikke fungerede til dit projekt</p> </li> <li> <p>hvorfor Blazor\u2019s MVVM-lignende model underst\u00f8tter real-time UI</p> </li> <li> <p>hvordan UI passer ind som \u201cyderste lag\u201d i Clean Architecture</p> </li> <li> <p>hvordan vertical slices giver en naturlig mappe- og feature-struktur</p> </li> </ul> <p>Perspektiv: UI-fagene gav os evnen til at forst\u00e5 pr\u00e6sentationsniveauet, s\u00e5 systemarkitekturen kan afgr\u00e6nse det fra forretningskodens dom\u00e6ne.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#3-databaser-ef-core-sql-grundlaget-for-infrastructure-layer","title":"3. Databaser (EF Core, SQL) \u2192 Grundlaget for Infrastructure Layer","text":"<p>Alt arbejde med:</p> <ul> <li> <p>EF Core</p> </li> <li> <p>DBContext</p> </li> <li> <p>SQL-sp\u00f8rringer</p> </li> <li> <p>normalisering</p> </li> <li> <p>relationer</p> </li> </ul> <p>\u2026er direkte relevant for Infrastructure-laget, som i Clean Architecture er sat op som:</p> <ul> <li> <p>data persistence</p> </li> <li> <p>repositories</p> </li> <li> <p>DB-mapping</p> </li> <li> <p>migration pipeline</p> </li> </ul> <p>Desuden gav databasefaget os forst\u00e5elsen for hvorfor datalag ikke m\u00e5 ligge i domain, men skal abstraheres via interfaces i Application-laget.</p> <p>Perspektiv: Databasefaget gav os v\u00e6rkt\u00f8jet \u2013 arkitekturen gav os reglen: \u201cDomain m\u00e5 ikke kende database.\u201d</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#4-webapi-faget-understtter-application-layer-integrationer","title":"4. Web/API-faget \u2192 Underst\u00f8tter Application layer + integrationer","text":"<p>N\u00e5r vi arbejder med:</p> <ul> <li> <p>REST API\u2019er</p> </li> <li> <p>JSON</p> </li> <li> <p>HttpClient</p> </li> <li> <p>tokens</p> </li> <li> <p>controller-flow</p> </li> <li> <p>statuskoder</p> </li> </ul> <p>\u2026s\u00e5 bliver vi bedre til at forst\u00e5:</p> <ul> <li> <p>hvorfor Application Layer indeholder \u201cuse cases\u201d</p> </li> <li> <p>hvorfor controllers ikke m\u00e5 indeholde logik</p> </li> <li> <p>hvordan UI \u2192 API \u2192 Application \u2192 Domain flowet skal fungere</p> </li> <li> <p>hvordan ekstern AI-service integreres korrekt</p> </li> </ul> <p>Perspektiv: API-faget gav os kommunikation \u2013 arkitekturen sikrer, at kommunikationen sker korrekt og uden l\u00e6k mellem lag.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#5-softwaredesign-patterns-direkte-fagligt-kernestof","title":"5. Softwaredesign &amp; Patterns \u2192 Direkte fagligt kernestof","text":"<p>Patterns fra tidligere semestre, fx:</p> <ul> <li> <p>Observer (events)</p> </li> <li> <p>Factory</p> </li> <li> <p>Strategy</p> </li> <li> <p>Dependency Injection</p> </li> <li> <p>Repository</p> </li> </ul> <p>\u2026er alle blevet brugt i dit projekt og koblet til Clean Architecture og DDD.</p> <p>Perspektiv: Tidligere pattern-viden blev til konkrete beslutninger i arkitekturen.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#6-systemudvikling-projektstyring-og-proces-arkitektur-som-projektbeslutning","title":"6. Systemudvikling, projektstyring og proces \u2192 Arkitektur som projektbeslutning","text":"<p>Scrum, dokumentation, analyse og kravforst\u00e5else har givet os evnen til at:</p> <ul> <li> <p>analysere behov</p> </li> <li> <p>forst\u00e5 dom\u00e6ner</p> </li> <li> <p>tr\u00e6ffe arkitekturvalg baseret p\u00e5 udviklingens retning</p> </li> <li> <p>lave begr\u00e6nset scope</p> </li> <li> <p>v\u00e6lge modul\u00e6r monolith i stedet for microservices</p> </li> </ul> <p>Perspektiv: Metodefagene l\u00e6rte os hvordan man tr\u00e6ffer beslutninger \u2013 arkitekturforl\u00f8bet er anvendelsen af dem.</p>"},{"location":"Generelt/refleksioner%20til%20tidligere%20l%C3%A6ring/#samlet-perspektiv-en-stning","title":"\u2b50 Samlet perspektiv \u2013 \u00e9n s\u00e6tning","text":"<p>Dette arkitekturforl\u00f8b bygger p\u00e5 og integrerer hele min uddannelse: programmering, UI, databaser, web/API, patterns og systemudvikling. Alle fag er samlet i \u00e9n praktisk forst\u00e5else, hvor Clean Architecture, Vertical Slice og DDD bliver den strukturerede m\u00e5de at anvende dem p\u00e5 i et komplekst projekt</p>"},{"location":"Software-arkitektur/","title":"Software Arkitektur \u2013 Oversigt","text":""},{"location":"Software-arkitektur/L%C3%A6ringsm%C3%A5l%20Software%20arkitektur/","title":"L\u00e6ringsm\u00e5l","text":""},{"location":"Software-arkitektur/L%C3%A6ringsm%C3%A5l%20Software%20arkitektur/#1-opna-forstaelse-for-centrale-arkitekturprincipper-og-kunne-anvende-dem-i-praksis","title":"1. Opn\u00e5 forst\u00e5else for centrale arkitekturprincipper og kunne anvende dem i praksis","text":""},{"location":"Software-arkitektur/L%C3%A6ringsm%C3%A5l%20Software%20arkitektur/#1-high-level-forstaelse-af-moderne-arkitekturvalg","title":"1. High-level forst\u00e5else af moderne arkitekturvalg","text":"<p>Jeg kan forklare forskellen p\u00e5 monolit, modul\u00e6r monolit, microservices og Clean Architecture p\u00e5 et overordnet niveau, og jeg kan begrunde, hvorfor vores projekt anvender en Clean/Vertical Slice-inspireret struktur.</p>"},{"location":"Software-arkitektur/L%C3%A6ringsm%C3%A5l%20Software%20arkitektur/#2-viden-om-arkitekturpatterns-og-deres-trade-offs","title":"2. Viden om arkitekturpatterns og deres trade-offs","text":"<p>Jeg kan redeg\u00f8re for centrale arkitekturpatterns s\u00e5som Layered Architecture, Clean Architecture, Event-Driven Architecture og CQRS, samt forklare hvorn\u00e5r de er relevante, og hvilke fordele/ulemper der f\u00f8lger med de forskellige arkitekturvalg.</p>"},{"location":"Software-arkitektur/L%C3%A6ringsm%C3%A5l%20Software%20arkitektur/#3-opna-praktisk-erfaring-med-brug-af-design-patterns-i-softwareudvikling","title":"3. Opn\u00e5 praktisk erfaring med brug af design patterns i softwareudvikling","text":"<p>Jeg vil kunne forklare og anvende design patterns som Factory, Strategy, Observer og Domain Events, og forst\u00e5 forskellen mellem UI-patterns (Observer) og dom\u00e6nepatterns (Domain Events). Jeg vil kunne vise eksempler fra projektet, hvor patterns reducerer kompleksitet og forbedrer vedligeholdelsen.</p>"},{"location":"Software-arkitektur/L%C3%A6ringsm%C3%A5l%20Software%20arkitektur/#4-forstaelse-for-clean-architecture-struktur-og-ansvar","title":"4. Forst\u00e5else for Clean Architecture-struktur og ansvar","text":"<p>Jeg kan forklare Clean Architecture\u2019s opdeling i Domain, Application og Infrastructure, og vise, hvordan denne struktur hj\u00e6lper med at organisere ansvar og holde systemet adskilt og overskueligt.</p>"},{"location":"Software-arkitektur/L%C3%A6ringsm%C3%A5l%20Software%20arkitektur/#5-opna-forstaelse-for-hvordan-cqrs-og-event-drevet-design-forbedrer-systemets-struktur","title":"5. Opn\u00e5 forst\u00e5else for hvordan CQRS og event-drevet design forbedrer systemets struktur","text":"<p>Jeg vil forst\u00e5, hvordan CQRS adskiller l\u00e6se- og skriveansvar i systemet, og hvorfor det giver klarere flows i komplekse dom\u00e6ner. Jeg vil kunne forklare Domain Events og deres rolle i Clean Architecture \u2014 hvordan dom\u00e6net kan udl\u00f8se h\u00e6ndelser uden at kende resten af systemet, og hvordan Application-laget reagerer gennem event-handlers.</p>"},{"location":"Software-arkitektur/L%C3%A6ringsm%C3%A5l%20Software%20arkitektur/#5-forstaelse-af-cqrs-og-event-drevet-design-i-praksis","title":"5. Forst\u00e5else af CQRS og event-drevet design i praksis","text":"<p>Jeg kan forklare, hvordan CQRS adskiller l\u00e6se- og skriveoperationer, og hvordan Domain Events g\u00f8r det muligt for dom\u00e6net at udl\u00f8se h\u00e6ndelser, som application-laget h\u00e5ndterer gennem event handlers.</p>"},{"location":"Software-arkitektur/L%C3%A6ringsm%C3%A5l%20Software%20arkitektur/#6-opna-indsigt-i-softwarekvalitet-teststrategier-og-vedligeholdbarhed","title":"6. Opn\u00e5 indsigt i softwarekvalitet, teststrategier og vedligeholdbarhed","text":"<p>Jeg vil forst\u00e5, hvordan arkitekturvalg p\u00e5virker teststrategier, enhedstest, mocks og integrationstests. Jeg vil kunne redeg\u00f8re for testpyramiden og vise eksempler p\u00e5, hvordan arkitektur og patterns g\u00f8r det lettere at teste vores dom\u00e6ne og services..</p>"},{"location":"Software-arkitektur/L%C3%A6ringsm%C3%A5l%20Software%20arkitektur/#konklusion","title":"Konklusion","text":"<p>I denne del af projektet har jeg arbejdet mig ind i de vigtigste principper inden for softwarearkitektur og design patterns. Jeg er g\u00e5et fra at have en mere teknisk, kodeorienteret forst\u00e5else til at kunne se systemet fra et h\u00f8jere niveau, hvor struktur, ansvar og arkitekturvalg betyder lige s\u00e5 meget som selve implementeringen.</p> <p>Jeg har f\u00e5et et klarere billede af forskellen p\u00e5 de store arkitekturtyper, og hvorfor Clean Architecture gav mening i vores projekt. Samtidig har jeg f\u00e5et praktisk erfaring gennem sm\u00e5 spikes, hvor jeg har afpr\u00f8vet forskellige patterns som Strategy, Factory, Observer og Domain Events \u2013 og l\u00e6rt, hvilke m\u00f8nstre der faktisk passer ind i vores l\u00f8sning, og hvilke der ikke g\u00f8r.</p> <p>S\u00e6rligt arbejdet med CQRS og Domain Events har gjort det tydeligt, hvordan arkitekturvalg kan skabe struktur, tydeligere flows og bedre adskillelse af ansvar. Det har ogs\u00e5 vist mig, at arkitektur i h\u00f8j grad handler om at tr\u00e6ffe bevidste valg, forst\u00e5 trade-offs og kende begr\u00e6nsningerne ved alternativerne.</p> <p>Samlet set har jeg f\u00e5et et st\u00e6rkere helhedsbillede af, hvordan et system bygges op fra dom\u00e6ne til infrastruktur, og hvordan patterns og principper kan bruges som v\u00e6rkt\u00f8jer \u2013 ikke som regler, men som hj\u00e6lp til at skabe et mere overskueligt, fleksibelt og skalerbart system.</p>"},{"location":"Software-arkitektur/Projekter/","title":"Oversigt","text":"<p>Dette er sektionen.</p>"},{"location":"Software-arkitektur/Projekter/Factory%20pattern/","title":"Factory Pattern \u2014 Form\u00e5l (helt kort)","text":"<p>Factory Pattern bruges til at oprette objekter, uden at den kode der bruger dem, beh\u00f8ver at vide hvilken konkret klasse der bliver lavet.</p> <p>Det handler om:</p> <ul> <li>at samle objekt-oprettelse \u00e9t sted</li> <li>at undg\u00e5 <code>new</code> i hele projektet</li> <li>at kunne udvide systemet med nye varianter uden at \u00e6ndre eksisterende kode</li> </ul> <p>Projektet. ![[Pasted image 20251121233759.png]] Interfacet IContent er kontrakten for Article, HealthTip og VideoPost typerne. De implementerer hver is\u00e6r metoden - Void Display(); fra IContent. ![[Pasted image 20251121234038.png]]</p> <p>Her implementer Article interfacet og dets regler. Alle klasser kan implementere det p\u00e5 sin egen m\u00e5de og derefter kan de laves via ContentFactory ![[Pasted image 20251121234150.png]]</p> <p>ContentFactory ![[Pasted image 20251121234311.png]]Her bliver de hver is\u00e6r lavet af contenFactory - der er fabrikken hvorp\u00e5 det besluttes hvilken en der skal laves via Create metoden.</p> <p>Programmet siger \u201cgiv mig indhold\u201d, fabrikken beslutter hvilken type, og programmet bruger objektet via interfacet.</p>"},{"location":"Software-arkitektur/Projekter/Factory%20pattern/#hvorfor-factory-er-nyttigt","title":"**Hvorfor Factory er nyttigt","text":"<ul> <li>Man slipper for if/switch alle steder</li> <li>Man undg\u00e5r afh\u00e6ngigheder til konkrete klasser</li> <li>Man kan tilf\u00f8je nye content-typer uden at \u00e6ndre i resten af systemet</li> <li>Koden bliver langt nemmere at vedligeholde og teste</li> </ul>"},{"location":"Software-arkitektur/Projekter/Factory%20pattern/#factory-pattern-hvordan-vi-bruger-det-og-hvorfor-det-er-ndvendigt-i-vores-projekt","title":"Factory Pattern (hvordan vi bruger det, og hvorfor det er n\u00f8dvendigt i vores projekt)","text":"<p>Factory Pattern er en af de mest anvendelige konstruktioner i DDD\u2010centrerede systemer. Det bruges n\u00e5r et objekt:</p> <ul> <li>har komplekse regler for oprettelse</li> <li>kr\u00e6ver forskellige strategier</li> <li>skal skabes p\u00e5 en konsistent m\u00e5de</li> <li>ikke m\u00e5 konstrueres manuelt i UI eller Application</li> <li>afh\u00e6nger af dom\u00e6net (incl. value objects, invariants og events)</li> </ul> <p>I dette projekt opst\u00e5r disse behov ofte \u2014 inden for</p> <ul> <li>content creation</li> </ul> <p>Det er derfor her vi valgte at bruge det.</p>"},{"location":"Software-arkitektur/Projekter/Factory%20pattern/#formalet-med-contentfactory","title":"Form\u00e5let med ContentFactory","text":"<p>Form\u00e5let var:</p> <p>At Application-laget kan skabe de rigtige Content-objekter (BlogPost, VideoPost, ReviewPost) uden at skrive <code>new</code> og uden at kende de konkrete klasser.</p> <p>Det vil sige:</p> <ul> <li>Application siger kun: \u201cOpret en blog\u201d, \u201cOpret et review\u201d, \u201cOpret en video\u201d</li> <li>Domain.Factory v\u00e6lger det korrekte dom\u00e6neobjekt</li> <li>Dom\u00e6nelogik ligger centralt og rent</li> </ul>"},{"location":"Software-arkitektur/Projekter/Factory%20pattern/#hvad-gjorde-vores-contentfactory","title":"Hvad gjorde vores ContentFactory?","text":"<p>Den havde overloads som:</p> <p><code>CreateBlog(title, authorId, body, imageUrl) CreateVideo(title, authorId, videoUrl, description) CreateReview(title, authorId, productName, rating, reviewText)</code></p> <p>Hver metode:</p> <p>tager simple primitive parametre  returnerer det korrekte dom\u00e6neobjekt:</p> <ul> <li><code>BlogPost</code></li> <li>`VideoPost</li> <li><code>ReviewPost</code></li> </ul> <p>\u2192 UI og Application-laget beh\u00f8vede aldrig at sige <code>new BlogPost(...)</code>. \u2192 Domain styrede oprettelsen \u00e9t sted. ![[Pasted image 20251128160901.png]]</p>"},{"location":"Software-arkitektur/Projekter/Factory%20pattern/#2-hvorfor-factory-pattern-er-vigtigt-i-projektet","title":"2) Hvorfor Factory Pattern er vigtigt i projektet","text":""},{"location":"Software-arkitektur/Projekter/Factory%20pattern/#a-domnet-har-regler-ved-oprettelse","title":"A) Dom\u00e6net har regler ved oprettelse","text":"<p>Eksempler:</p> <ul> <li>content skal valideres og evt. modereres ved oprettelse</li> <li>membership\u2010activation skal rejse domain events</li> <li>reviews skal skabe AI-baserede triggers afh\u00e6ngigt af type</li> <li>content body og title er value objects \u2192 kr\u00e6ver driftssikre konstruktioner</li> </ul> <p>Hvis Application bare k\u00f8rer:</p> <p><code>var content = new Content(...);</code></p> <p>\u2026 s\u00e5 risikerer du:</p> <ul> <li>forvirring om hvor invariants ligger</li> <li>use cases der opretter objekter forskelligt</li> <li>duplikeret logik</li> <li>fejl ved manglende dom\u00e6neregler</li> </ul> <p>Factory Pattern l\u00f8ser dette.</p>"},{"location":"Software-arkitektur/Projekter/Factory%20pattern/#b-nye-typer-skal-kunne-tilfjes-uden-at-ndre-eksisterende-kode","title":"B) Nye typer skal kunne tilf\u00f8jes uden at \u00e6ndre eksisterende kode","text":"<p>Eksempler:</p> <ul> <li>nyt content\u2010type (fx audio, pdf, embed, guide, premium-content)</li> <li>nye membership\u2010levels</li> <li>nye AI\u2010strategier</li> </ul> <p>Factory Pattern f\u00f8lger OCP (Open/Closed Principle):</p> <p>\u2192 Du kan tilf\u00f8je en ny type objekt uden at \u00e6ndre eksisterende factory. \u2192 Du registrerer blot en ny implementation, og DI finder den.</p>"},{"location":"Software-arkitektur/Projekter/Factory%20pattern/#hvordan-factory-pattern-passer-ind-i-clean-architecture","title":"Hvordan Factory Pattern passer ind i Clean Architecture","text":""},{"location":"Software-arkitektur/Projekter/Factory%20pattern/#domain","title":"Domain:","text":"<p>Entities og Value Objects forbliver rene. Factories kan ligge i Domain eller Application afh\u00e6ngigt af reglerne.</p>"},{"location":"Software-arkitektur/Projekter/Factory%20pattern/#application","title":"Application:","text":"<p>Commands/Handlers bruger factories til at skabe objekter korrekt.</p>"},{"location":"Software-arkitektur/Projekter/Factory%20pattern/#infrastructure","title":"Infrastructure:","text":"<p>Strategy-implementeringer og factories kan registreres via DI.</p>"},{"location":"Software-arkitektur/Projekter/Factory%20pattern/#hvordan-vi-bruger-og-implementerer-contentfactory-i-projektet","title":"Hvordan vi bruger og implementerer ContentFactory i projektet","text":"<p>I The Way of Coherence har vi flere forskellige typer indhold, s\u00e5som blogindl\u00e6g, videoer og produktanmeldelser. Hver type har sine egne dom\u00e6ne-regler og felter, men vi vil ikke have, at Application-laget eller UI\u2019et skal kende til de konkrete klasser eller skrive <code>new</code> for at oprette dem.</p> <p>For at l\u00f8se det bruger vi Factory Pattern i dom\u00e6nelaget.</p> <p>Vi har oprettet en ContentFactory, som fungerer som en central indgang til at oprette alle typer af content-objekter. N\u00e5r et nyt indhold skal oprettes, sender Application-laget kun de n\u00f8dvendige primitive v\u00e6rdier \u2013 f.eks. titel, forfatter-id, tekst, video-url eller produktnavn. Ud fra dette v\u00e6lger fabrikken den korrekte dom\u00e6neklasse og bygger det rette objekt.</p> <p>P\u00e5 den m\u00e5de skjuler vi konstruktionen af BlogPost, VideoPost og ReviewPost, s\u00e5 resten af systemet ikke kender til konkrete implementeringer. Det g\u00f8r dom\u00e6nelaget mere robust og udvidelsesvenligt, fordi vi kan tilf\u00f8je nye content-typer senere uden at \u00e6ndre kode i Application-laget.</p> <p>N\u00e5r et indhold er oprettet via fabrikken, bliver objektet typisk pakket ind i et Post-aggregate, hvor vi tilf\u00f8jer metadata som kategori. Herefter kan vi udl\u00f8se et PostPublishedEvent, som dom\u00e6nelaget bruger til sideeffekter som logging eller notifikationer.</p> <p>Samlet set giver ContentFactory os:</p> <ul> <li>\u00e9t sted at styre al konstruktion af indhold</li> <li>lavere coupling mellem lagene</li> <li>renere dom\u00e6nemodeller</li> <li>mulighed for at tilf\u00f8je nye content-typer uden at \u00e6ndre eksisterende kode</li> </ul> <p>Det er derfor en simpel, men effektiv brug af Factory Pattern i dom\u00e6nelaget.</p>"},{"location":"Software-arkitektur/Projekter/Factory%20pattern/#konklusion","title":"Konklusion","text":"<p>Factory Pattern er uundv\u00e6rligt i vores projekt, fordi det giver en ensartet, regelstyret m\u00e5de at skabe dom\u00e6neobjekter p\u00e5.</p> <p>Det kombinerer perfekt med Strategy Pattern, Domain Events, DDD\u2019s value objects og Clean Architecture\u2019s afh\u00e6ngighedsregler.</p> <p>Resultatet er rene handlers, testbare dom\u00e6neflows og et system, der er let at udvide uden at \u00e6ndre eksisterende logik.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/","title":"Observer vs Domain Events","text":"<p>For at genopfriske l\u00e6ringen omkring observer pattern fra tidligere semestre og se hvordan vi kan bruge det i vores projekt, s\u00e5 har jeg valgt at lave et lille projekt og se hvordan det kan bruges i en situation der passer til vores projekt i forhold til at observere ved oprettelse af ny content via post hvor der s\u00e5 bliver lyttet samt reageret p\u00e5 eventet, hvilket resulterer i udsendelsen af en email.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#observer-pattern","title":"**Observer Pattern","text":""},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#ide","title":"Id\u00e9:","text":"<p>Et objekt (subject) holder styr p\u00e5 flere observers. N\u00e5r subject \u00e6ndrer sig, notificerer den alle observers direkte.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#karakteristika","title":"Karakteristika:","text":"<ul> <li>direkte reference mellem subject og observer</li> <li>t\u00e6t kobling</li> <li>objekter kender ofte hinanden</li> <li>typisk synkront</li> <li>er bedst i UI og simple apps</li> <li>fungerer som \u201chvem lytter p\u00e5 mig?\u201d-model</li> </ul>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#domain-events-ddd","title":"Domain Events (DDD)","text":""},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#ide_1","title":"Id\u00e9:","text":"<p>Dom\u00e6net udsender en h\u00e6ndelse \u2014 men ved ikke hvem der reagerer p\u00e5 den.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#karakteristika_1","title":"Karakteristika:","text":"<ul> <li>ingen references mellem domain og event handlers</li> <li>lav coupling</li> <li>rent dom\u00e6ne</li> <li>h\u00e6ndelser beskriver forretningssituationer (ikke UI-tilstande)</li> <li>Application-laget h\u00e5ndterer eventet</li> <li>Infrastructure kan h\u00e5ndtere sideeffekter</li> </ul>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#observer-pattern_1","title":"Observer Pattern","text":"<p>Her ses opbygningen af mit observer spikeprojekt. ![[Pasted image 20251121115652.png]]</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#1-subject-contentpublisher","title":"1) Subject \u2192 ContentPublisher","text":"<p>Den der udsender beskeder / h\u00e6ndelser. ContentPublisher implementerer ISubject, som er kontrakten for et subject. Her kan observers blive tilmeldt (Attach) eller frameldt (Detach). N\u00e5r noget sker, kalder subject Notify, som sender en besked til alle observers.</p> <p>![[Pasted image 20251121121805.png]]</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#2-observers-emailsubscriber-pushsubscriber","title":"2) Observers \u2192 EmailSubscriber / PushSubscriber","text":"<p>Modtagere af beskeder. De implementerer IObserver, som er kontrakten for hvordan observers reagerer. N\u00e5r de modtager <code>Update(message)</code>, h\u00e5ndterer de h\u00e6ndelsen p\u00e5 hver deres m\u00e5de.</p> <p>![[Pasted image 20251121123919.png]]</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#3-interfaces-isubject-og-iobserver","title":"3) Interfaces \u2192 ISubject og IObserver","text":"<p>Kontrakten for hvordan subject og observers skal opf\u00f8re sig. ISubject styrer notifikationerne. IObserver styrer hvordan subscribers reagerer. ![[Pasted image 20251121122737.png]]</p> <p>ISubject er kontrakten for publishers (ContentPublisher) og udsendelsen af beskeder og h\u00e6ndelser ![[Pasted image 20251121123007.png]]</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#flowet-i-min-kode","title":"Flowet i min kode","text":"<ol> <li>Observers tilmelder sig via <code>Attach()</code></li> <li>ContentPublisher publicerer nyt content og kalder <code>Notify()</code></li> <li>Notify kalder <code>Update(message)</code> p\u00e5 alle observers</li> <li>Email og Push reagerer hver for sig</li> </ol> <p>Pointen med Observer Pattern: Det giver l\u00f8s kobling: Subject kender ikke implementeringen af observers, kun interfacet. Det g\u00f8r systemet fleksibelt og udvideligt.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#domain-event","title":"Domain event","text":"<p>Her har jeg afpr\u00f8vet et domain event implementering for at sammenligne med Observer pattern. Jeg har i dette Spike Project ikke brugt MediatR til at styre handlers for at f\u00e5 et bedre indblik i hvordan DDD-event fungerer reelt.</p> <p>Her er projektets opbygning. ![[Pasted image 20251121134220.png]]</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#application-laget","title":"Application-laget","text":"<p>Her ligger klasser, der h\u00e5ndterer h\u00e6ndelser og styrer, hvad der skal ske i systemet.</p> <ul> <li> <p>DomainEventBus.cs     Event-bussen der sender domain events videre til de rigtige handlers.</p> </li> <li> <p>IDomainEventHandler.cs     Interface for alle handlers. Bestemmer hvordan en handler skal reagere p\u00e5 et event.</p> </li> <li> <p>PostPublishedHandler.cs     Selve handleren for PostPublishedEvent. K\u00f8rer application-logik som email og kald til dom\u00e6net.</p> </li> </ul> <p>Application-laget reagerer p\u00e5 events og binder dom\u00e6ne og infrastruktur sammen.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#domain-laget","title":"Domain-laget","text":"<p>Her ligger alt, der h\u00f8rer til selve dom\u00e6nelogikken \u2014 alts\u00e5 kernefunktionalitet.</p> <ul> <li> <p>ContentService.cs     Dom\u00e6neservice med forretningslogik. Den genererer nye Domain Events.</p> </li> <li> <p>IDomainEvent.cs     Kontrakten for alle domain events.</p> </li> <li> <p>PostPublishedEvent.cs     Et konkret domain event. Repr\u00e6senterer \u201cpost er publiceret\u201d.</p> </li> </ul> <p>Domain-laget er systemets kerne og indeholder regler, entiteter og events.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#infrastructure-laget","title":"Infrastructure-laget","text":"<p>Her ligger kode, der taler med eksterne systemer eller ressourcer.</p> <ul> <li>EmailNotifier.cs     En simpel infrastrukturservice for at sende e-mails.</li> </ul> <p>Infrastructure er afh\u00e6ngigt af eksterne ressourcer og bruges af application layer.</p> <p>EventBus EventBus er programmets central, der styrer indkomne events. Den ved hvordan de kaldes og den ved hvilke handlers der h\u00e5ndterer hvilke events og kan derfor distriuere dem til den korrekte handler. I dette projekt har vi DomainEventBus som vores eventBus.</p> <p>![[Pasted image 20251121134623.png]] Priavte readonly List..- Her laves listen over alle typer eventhandlers. i RegisterHandler metoden - Her registreres en handler og bliver gemt til et domain event. Det er her den korrekte handler registreres. Den der lytter efter eventet. PublishAsync metoden - Her sendes eventet ud i systemet og metoden udf\u00f8res p\u00e5 eventet.</p> <p>![[Pasted image 20251121135800.png]]</p> <p>I PostPublishedEvent - Der implmenteres kontrakten fra IDomainEventHandler. Den lytter alts\u00e5 efter PostPublishedEvent og bliver deror kaldt af DomainEventBus.</p> <p>De 3 services fra EmailNotifier, ContentService og DomainEventBus bliver injiceret i constructoren, s\u00e5 de kan bruges. EmailNotifier - Sender email ved event. ContentService - kan lave nye events DomainEventBus - Kan publisere event fra dom\u00e6net.</p> <p>I handleAsync metode - Kaldes automatisk n\u00e5r Der er et PostPublishedEvent i DomainEventBus. Den udf\u00f8rer logikken for EmailNotifier og ContentService.</p> <p>Til sidst bliver der via foreach - Foreach tager hvert event, som dom\u00e6net selv har skabt, og sender det tilbage ind i event-systemet, s\u00e5 de ogs\u00e5 bliver h\u00e5ndteret. Her bruges liste som standard for at kunne h\u00e5ndtere flere events. Hvis flere events udl\u00f8ses som fx. notifikationer eller logging. ![[Pasted image 20251121140922.png]]</p> <p>ContentService ![[Pasted image 20251121144458.png]] Her kan der skabes events i _pendingEvents Og via publishPost() - publiseres post og genereres et nyt dom\u00e6ne event.</p> <p>ContentSerivce ligger i dom\u00e6nelaget, da den publiserer post og dom\u00e6ne events.</p> <p>Dette kan derefter bruges af PostPublishHandler - Der kan hente listen og sende events videre i EventBus. ContentService udf\u00f8rer forretningslogik og genererer nye Domain Events, som gemmes i en liste, s\u00e5 de senere kan sendes videre til EventBus og blive h\u00e5ndteret.</p> <p>![[Pasted image 20251121145221.png]] PostPublishedEvent - Indeholder de data handlers bruger, her i form af author og title og den repr\u00e6senterer h\u00e6ndelsen at \" Et indl\u00e6g blev publiceret\" Den repr\u00e6senterer hvad der sker i dom\u00e6net og h\u00f8rer derfor til i dom\u00e6nelaget.</p> <p>EmailNotifier - simulerer sending af email og ligger i infrastructure da den h\u00f8rer til ydre services der kobles p\u00e5 systemet.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#domain-events-i-the-way-of-coherence","title":"**Domain Events i  The Way of Coherence","text":"<p>I The Way of Coherence anvender vi Domain Events for at sikre en klar og fleksibel adskillelse mellem dom\u00e6nelogikken og de procesflows, der skal k\u00f8re efter en forretningsh\u00e6ndelse. Dom\u00e6neh\u00e6ndelserne bruges til at markere, at noget betydningsfuldt er sket i systemets kerne, uden at dom\u00e6nelaget beh\u00f8ver at kende de konkrete reaktioner eller eksterne konsekvenser.</p> <p>Det passer direkte ind i b\u00e5de Clean Architecture og jeres Vertical Slice-struktur. Dom\u00e6net rejser h\u00e6ndelsen, og den enkelte slice i Application-laget h\u00e5ndterer den del af logikken, der vedr\u00f8rer netop det forl\u00f8b.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#1-hvad-er-et-domain-event-i-projektet","title":"1. Hvad er et Domain Event i projektet?","text":"<p>Et Domain Event er en lille model, der beskriver en vigtig forretningsh\u00e6ndelse. N\u00e5r et indl\u00e6g bliver udgivet, er dette en central handling i systemets Content-dom\u00e6ne. I stedet for at lade dom\u00e6neobjekterne selv st\u00e5 for logging, notifikationer eller statistik, rejser de blot et Domain Event.</p> <p>P\u00e5 den m\u00e5de kan andre dele af systemet reagere, uden at dom\u00e6net skal \u00e6ndres eller opn\u00e5 nye afh\u00e6ngigheder.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#2-hvorfor-bruger-vi-domain-events","title":"2. Hvorfor bruger vi Domain Events?","text":"<p>Domain Events anvendes for at opn\u00e5:</p> <ul> <li>Lav kobling mellem lagene.</li> <li>Et dom\u00e6nelag uden tekniske afh\u00e6ngigheder til logging, e-mails, UI eller applikationsservices.</li> <li>En fleksibel arkitektur, hvor nye reaktioner kan tilf\u00f8jes uden \u00e6ndringer i dom\u00e6nemodellerne.</li> <li>En vertikal slice-opdeling, hvor hver slice kan reagere p\u00e5 h\u00e6ndelser, uden at det p\u00e5virker andre features.</li> <li>Lettest mulig testbarhed, da dom\u00e6nelogik kan testes isoleret.</li> </ul> <p>Vi valgte Domain Events i stedet for Observer Pattern, fordi Domain Events giver l\u00f8s kobling, rent dom\u00e6ne, h\u00f8j testbarhed og perfekt integration med Clean Architecture, DDD og Vertical Slice Architecture.  </p> <p>Observer Pattern ville have skabt coupling i dom\u00e6net og brudt arkitekturens afh\u00e6ngighedsregler.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#3-hvor-rejser-vi-hndelsen","title":"3. Hvor rejser vi h\u00e6ndelsen?","text":"<p>N\u00e5r et indl\u00e6g udgives via dom\u00e6nemetoden Publish(), registrerer objektet selv en Domain Event. Dom\u00e6nelaget reagerer alts\u00e5 ikke p\u00e5 h\u00e6ndelsen \u2013 det fort\u00e6ller blot, at den er sket.</p> <p>Dette f\u00f8lger principperne i Domain-Driven Design: Dom\u00e6net kender reglerne og ved, hvorn\u00e5r noget er betydningsfuldt, men det kender ikke resten af systemet.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#4-hvordan-kommer-hndelsen-videre-i-systemet","title":"4. Hvordan kommer h\u00e6ndelsen videre i systemet?","text":"<p>N\u00e5r indl\u00e6gget gemmes via repositoryet, opsamler infrastrukturen alle Domain Events, der er rejst af dette objekt. Disse events sendes videre gennem en Event Dispatcher, som er placeret i Infrastructure-laget.</p> <p>Dispatcheren sender h\u00e6ndelserne ind i MediatR-pipelinen, hvor hver h\u00e6ndelse oms\u00e6ttes til en notifikation, som Application-laget kan reagere p\u00e5.</p> <p>Dom\u00e6net skal ikke kende MediatR og har ingen afh\u00e6ngighed til tekniske biblioteker.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#5-hvordan-reagerer-application-laget","title":"5. Hvordan reagerer Application-laget?","text":"<p>I Application-laget ligger event handlers i de relevante vertical slices. For eksempel i Features/Posts/EventHandlers h\u00e5ndteres h\u00e6ndelsen om, at et indl\u00e6g er blevet udgivet.</p> <p>Her kan vi udf\u00f8re sideeffekter som:</p> <ul> <li>opdatere statistikker</li> <li>skrive audit-logs</li> <li>opdatere dashboardet</li> <li>sende beskeder videre til andre systemdele</li> </ul> <p>Det er kun Application-laget, der foretager disse opgaver. Dom\u00e6nelaget har ingen viden om, hvad der sker efterf\u00f8lgende.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#6-hvordan-passer-det-ind-i-vertical-slice-architecture","title":"6. Hvordan passer det ind i Vertical Slice Architecture?","text":"<p>Vertical Slice betyder, at hver feature (fx Posts) indeholder alt, der vedr\u00f8rer den funktion: commands, queries, validators, event handlers osv.</p> <p>Domain Events passer godt ind, fordi:</p> <ul> <li>En event handler ligger i den slice, som er relevant for h\u00e6ndelsen.</li> <li>Hver slice kan reagere p\u00e5 events uden at f\u00e5 afh\u00e6ngigheder til andre slices.</li> <li>Nye slices kan tilf\u00f8je flere handlers p\u00e5 den samme event uden at r\u00f8re eksisterende kode.</li> </ul> <p>Det giver en naturlig, isoleret og let at udvide implementering.</p>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#7-afslutning","title":"**7. Afslutning","text":"<p>Ved at kombinere Domain Events med Vertical Slice og Clean Architecture opn\u00e5r projektet:</p> <ul> <li>En st\u00e6rk adskillelse mellem forretningslogik og efterf\u00f8lgende handlinger.</li> <li>Et dom\u00e6nelag uden teknisk st\u00f8j og uden afh\u00e6ngigheder.</li> <li>Et application-lag der kan udvides slice for slice.</li> <li>Fleksibilitet til at bygge nye forl\u00f8b, der reagerer p\u00e5 eksisterende h\u00e6ndelser.</li> <li>En arkitektur, der er robust, skalerbar og let at teste.</li> </ul>"},{"location":"Software-arkitektur/Projekter/Observer%20Pattern%20vs.%20Domain%20Event/#domain-events-vs-observer-pattern-og-hvorfor-vi-valgte-domain-events","title":"Domain Events vs Observer Pattern (og hvorfor vi valgte Domain Events)**","text":"<p>I dette indl\u00e6g g\u00e5r vi i dybden med to patterns, der ligner hinanden i id\u00e9, men fungerer fundamentalt forskelligt i praksis:</p> <ul> <li>Observer Pattern</li> <li>Domain Events (DDD)</li> </ul> <p>Begge bruges til at reagere p\u00e5 h\u00e6ndelser. Men de g\u00f8r det p\u00e5 vidt forskellige m\u00e5der, og valget har stor betydning for arkitektur, koblingsgrad og dom\u00e6nedesign.</p> <p>I vores projekt valgte vi Domain Events \u2014 og her forklarer vi pr\u00e6cis hvorfor.</p>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/","title":"Arkitektur i projektet","text":"<p>Arkitekturen i projektet er bygget op omkring tre centrale valg:</p> <ol> <li> <p>Clean Architecture som lag- og afh\u00e6ngighedsstruktur</p> </li> <li> <p>Vertical Slice Architecture som metode til at organisere funktionalitet</p> </li> <li> <p>DDD-principper som grundlag for dom\u00e6nemodellering</p> </li> </ol> <p>Disse valg giver samlet set et system, der er opdelt, stabilt og nemt at udvide. Nedenfor gennemg\u00e5r jeg, hvad hver af disse betyder i mit projekt, og hvordan jeg konkret har implementeret dem.</p>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#1-clean-architecture-mit-lag-og-mine-afhngigheder","title":"\u2b50 1. Clean Architecture \u2013 mit lag og mine afh\u00e6ngigheder","text":"<p>For mig betyder Clean Architecture, at systemet er opdelt i lag, hvor dom\u00e6net ligger i centrum, og alle afh\u00e6ngigheder g\u00e5r indad. Det vigtigste er:</p> <ul> <li> <p>Dom\u00e6nelaget (Entities, Domain Events, Value Objects) kender ikke tekniske detaljer.</p> </li> <li> <p>Application-laget definerer use cases via Commands, Queries og Event Handlers.</p> </li> <li> <p>Infrastruktur implementerer interfaces fra Application \u2014 aldrig omvendt.</p> </li> <li> <p>UI (Blazor) taler kun med Application.</p> </li> </ul> <p>I praksis giver denne opdeling et system, hvor jeg kan \u00e6ndre teknologi (database, API, UI) uden at \u00e6ndre dom\u00e6net.</p>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#diagram-rapportvenligt","title":"Diagram (rapportvenligt)","text":"<pre><code>                 `Presentation (Blazor)                               \u2193                Application (CQRS + Handlers)                               \u2193                      Domain (Core Logic)                               \u2191                     Infrastructure (EF, API)`\n</code></pre> <p>\u2192 Dette er min kernearkitektur.</p>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#2-vertical-slice-architecture-sadan-organiserer-jeg-funktioner","title":"\u2b50 2. Vertical Slice Architecture \u2013 s\u00e5dan organiserer jeg funktioner","text":"<p>Hvor Clean Architecture definerer lag, definerer Vertical Slice Architecture funktionalitet. For mig betyder Vertical Slice:</p> <ul> <li> <p>Hver feature har sine egne mapper</p> </li> <li> <p>Commands, Queries, Handlers og Validation ligger samlet under \u00e9n feature</p> </li> <li> <p>Man skal ikke lede rundt i projektet efter logik, fordi alt tilh\u00f8rende ligger \u00e9t sted</p> </li> </ul> <p>Dette bruger jeg i Application-laget, hvor jeg har slices som:</p> <ul> <li> <p>Membership</p> </li> <li> <p>Content</p> </li> <li> <p>Reviews</p> </li> <li> <p>Notifications</p> </li> </ul> <p>Hver slice indeholder sit eget:</p> <ul> <li> <p>Command</p> </li> <li> <p>CommandHandler</p> </li> <li> <p>Query</p> </li> <li> <p>QueryHandler</p> </li> <li> <p>EventHandlers</p> </li> <li> <p>Interfaces</p> </li> </ul>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#eksempel","title":"Eksempel","text":"<p><code>Application/  \u251c\u2500 Membership/  \u2502     \u251c\u2500 Commands/  \u2502     \u251c\u2500 Queries/  \u2502     \u2514\u2500 Handlers/  \u251c\u2500 Content/  \u251c\u2500 Reviews/</code></p> <p>Vertical Slice giver mig et modul\u00e6rt system, hvor \u00e9n del kan udvikles eller \u00e6ndres uden at p\u00e5virke de andre.</p>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#3-domain-driven-design-hvad-det-er-for-mig-og-hvordan-jeg-bruger-det","title":"\u2b50 3. Domain-Driven Design \u2013 hvad det er for mig og hvordan jeg bruger det","text":"<p>Jeg har valgt at bruge DDD som modelleringsmetode, ikke som arkitektur.</p> <p>I mit projekt betyder DDD:</p> <ul> <li> <p>Jeg opdeler systemet i dom\u00e6ner som content, membership og reviews</p> </li> <li> <p>Jeg bruger Entities og Value Objects til at sikre tydelige modeller</p> </li> <li> <p>Jeg bruger Domain Events til at reagere p\u00e5 \u00e6ndringer i dom\u00e6net</p> </li> <li> <p>Jeg t\u00e6nker i bounded contexts, selvom det ligger i \u00e9n kodebase</p> </li> </ul> <p>Men \u2014 og det er vigtigt for mig \u2014 DDD er ikke min arkitektur. DDD hj\u00e6lper mig med at forst\u00e5 dom\u00e6net og skabe rene modeller, men det er Clean Architecture og Vertical Slice, der strukturerer systemet.</p> <p>Jeg bruger eksempelvis Domain Events n\u00e5r:</p> <ul> <li> <p>et review bliver oprettet</p> </li> <li> <p>et content-indl\u00e6g bliver publiceret</p> </li> <li> <p>et medlemskab \u00e6ndres</p> </li> </ul> <p>Event-handlers ligger i Application-laget, hvilket f\u00f8lger Clean Architectures \u201cindadg\u00e5ende afh\u00e6ngigheder\u201d.</p>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#4-hvordan-de-tre-valg-hnger-sammen-i-projektet","title":"\u2b50 4. Hvordan de tre valg h\u00e6nger sammen i projektet","text":"<p>Den samlede arkitektur kan beskrives s\u00e5dan:</p> <ul> <li> <p>Systemform: Modul\u00e6r monolith</p> </li> <li> <p>Lagstruktur: Clean Architecture (Domain \u2192 Application \u2192 Infrastructure \u2192 UI)</p> </li> <li> <p>Feature-opdeling: Vertical Slice Architecture</p> </li> <li> <p>Dom\u00e6nemodellering: DDD-principper (Entities, Value Objects, Domain Events)</p> </li> </ul>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#diagram-for-rapport-samlet-model","title":"Diagram (for rapport \u2013 samlet model)","text":"<p><code>\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                     Presentation                       \u2502 \u2502                      (Blazor UI)                      \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2193\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                Application (Vertical Slices)           \u2502 \u2502  \u251c\u2500 Membership: Commands, Queries, Handlers            \u2502 \u2502  \u251c\u2500 Content: Commands, Queries, Handlers               \u2502 \u2502  \u251c\u2500 Reviews: Commands, Queries, Handlers               \u2502 \u2502  \u2514\u2500 Notifications: Event Handlers                      \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2193\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                      Domain                            \u2502 \u2502   Entities, Value Objects, Domain Events, Services     \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2191\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2502                    Infrastructure                      \u2502 \u2502  EF Core, Repositories, External API Services, Logging \u2502 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518</code></p>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#kort-afslutning","title":"\u2b50 Kort afslutning","text":"<p>Arkitekturen i projektet er derfor en kombination af:</p> <ul> <li> <p>Clean Architecture, som definerer lag og afh\u00e6ngigheder</p> </li> <li> <p>Vertical Slice Architecture, som organiserer funktionalitet</p> </li> <li> <p>DDD-principper, som strukturerer dom\u00e6net</p> </li> </ul> <p>Denne kombination har givet et system, der er let at udvide, nemt at navigere i, og som holder forretningslogik fri af tekniske detaljer \u2014 pr\u00e6cis som god arkitektur skal.</p> <p>![[Pasted image 20251129135424.png]]\u201cHer ses mine 4 lag. Dom\u00e6net er i centrum. Application best\u00e5r af Vertical Slices. Infrastruktur er tekniske detaljer. Blazor ligger i Presentation.\u201d</p> <p>\u201cDom\u00e6net indeholder kerneforretningsmodeller og events. Der er ingen afh\u00e6ngigheder til database eller tekniske detaljer.\u201d</p> <p>![[Pasted image 20251129135535.png]] ![[Pasted image 20251129135616.png]] I dom\u00e6nelaget er enums, domain events og entities samlet.</p> <p>Her er apllications laget. ![[Pasted image 20251129140022.png]] ![[Pasted image 20251129140606.png]]</p> <p>Abstractions Her ligger alle interfaces, som Application har brug for \u2014 men som implementeres i Infrastructure. Det adskiller logik fra teknik.</p> <p>Contracts Kontrakter/aftaler mellem Application og eksterne systemer. Ingen logik \u2014 kun definitioner.</p> <p>Gateways Interfaces for adgang til eksterne systemer eller tekniske ressourcer (AI, Cache, Email, Identity).</p> <p>Hver fil kort:</p> <ul> <li> <p>IAIChatGateway \u2013 interface for AI-chat (Application kender ikke den konkrete AI-teknologi).</p> </li> <li> <p>ICache \u2013 abstraktion for caching (Memory/Redis bestemmes af Infrastructure).</p> </li> <li> <p>IEmailNotifier \u2013 abstraktion for e-mail-afsendelse.</p> </li> <li> <p>IDomainEventDispatcher \u2013 interface til at dispatchere domain events.</p> </li> <li> <p>IIdentityService \u2013 abstraktion for bruger/identity-opslag.</p> </li> <li> <p>IUserLookupService \u2013 abstraktion for at hente brugerinfo uden at kende Identity-implementeringen.</p> </li> <li> <p>Dtos/ \u2013 sm\u00e5 modeller der bruges som datakontrakter udadtil.</p> </li> </ul> <p>Kort konklusion:</p> <p>Application definerer hvad den skal bruge gennem interfaces. Infrastructure implementerer det. Det holder arkitekturen ren og afh\u00e6ngighederne indad).</p> <p>![[Pasted image 20251129140218.png]]\u201cHver feature er samlet \u00e9t sted \u2014 command, query, handler, interfaces. Det er Vertical Slice Architecture og giver lav coupling.\u201d</p>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#infrastrukturmappen-kort-forklaring-rapportvenlig","title":"Infrastrukturmappen \u2013 kort forklaring (rapportvenlig)","text":"<p>Din Infrastructure/-mappe er opbygget helt korrekt efter Clean Architecture.</p> <p>Her ligger alle konkrete tekniske implementeringer, mens Application kun kender interfaces.</p> <p>Her er en meget kort forklaring af dine undermapper:</p>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#dependencies","title":"Dependencies/","text":"<ul> <li> <p>Her samler du dine extension methods eller registreringer, der binder Application-interfaces til Infrastructure-implementeringer.</p> </li> <li> <p>Bruges ofte til <code>AddInfrastructureServices()</code> i Program.cs.</p> </li> </ul>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#events","title":"Events/","text":"<ul> <li>Indeholder h\u00e5ndtering af dom\u00e6neevents fra Infrastructure's perspektiv, f.eks. persistence-logik eller integrationer der skal reagere p\u00e5 events.</li> </ul>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#gateways","title":"Gateways/","text":"<ul> <li> <p>Konkrete implementationer af dine Abstractions \u2192 Contracts \u2192 Gateways.</p> </li> <li> <p>Eksempel: <code>AIChatGateway</code>, <code>EmailNotifier</code>, <code>Cache</code>, osv.</p> </li> </ul>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#identity","title":"Identity/","text":"<ul> <li> <p>Implementeringer relateret til autentificering/autorisation.</p> </li> <li> <p>Typisk adaptere til ASP.NET Identity eller custom IdentityService.</p> </li> </ul>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#persistence","title":"Persistence/","text":"<ul> <li> <p>EF Core DbContext</p> </li> <li> <p>Repositories</p> </li> <li> <p>Migrations</p> </li> <li> <p>Database-konfiguration</p> </li> <li> <p>Alle data-relaterede tekniske detaljer</p> </li> </ul>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#appconfigurationoptionscs","title":"appConfigurationOptions.cs","text":"<ul> <li>Konfigurationsklasser til binding af appsettings.</li> </ul>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#servicecollectionextensionscs","title":"ServiceCollectionExtensions.cs","text":"<ul> <li>Extension methods som:</li> </ul> <p>![[Pasted image 20251130125913.png]]</p> <p>\u201cHer kan man se, at Application kun definerer IPostRepository som kontrakt. Infrastructure implementerer den konkrete PostRepository, som bruger EF Core og databasen. Det viser Clean Architectures dependency rule: Application afh\u00e6nger af abstraktioner, ikke konkrete tekniske implementeringer.\u201d</p>"},{"location":"Software-arkitektur/Projekter/Prototype%20implementering%20til%20projekt/#web-presentation-laget","title":"Web (Presentation-laget)","text":"<p>\u201cUI-laget er implementeret i Blazor. Det indeholder kun Pages og Components til pr\u00e6sentation. UI\u2019et kalder Application-laget via Commands/Queries og indeholder ingen forretningslogik. Dette f\u00f8lger Clean Architecture\u2019s princip om, at UI ligger i yderste lag og afh\u00e6nger af Application.\u201d</p>"},{"location":"Software-arkitektur/Projekter/Strategy%20pattern/","title":"Strategy Pattern","text":"<p>**Strategy Pattern \u2014 Step 1: Hvad handler det om?</p> <p>Strategy Pattern bruges, n\u00e5r man vil skifte en algoritme eller adf\u00e6rd dynamisk, uden at \u00e6ndre koden i den klasse der bruger den.</p> <p>![[Pasted image 20251121150415.png]]</p> <p>I vores lille spike handler det om:</p> <ul> <li> <p>hvordan indhold vises for forskellige brugertyper     (Guest, Member, Admin )     Her repr\u00e6senteret af DisplayStrategy klasserne, der alle implementerer interfacet IContentDisplayStrategy</p> <p>De har alle forskellige regler for implmenteringen af interfacet. Kun strategy klasser kender til reglerne for implmenteringen af de forskellige strategier. Ikke contenViewer.</p> </li> </ul> <p>![[Pasted image 20251121230910.png]] I GuestDisplayStrategy, der er der begr\u00e6nsning p\u00e5 hvad der vises, da d</p> <p>![[Pasted image 20251121230827.png]] I memberDisplayStrategy klassen, der vises alt indhold via Display content og der er her ingen begr\u00e6nsniger p\u00e5.</p> <p>![[Pasted image 20251121231417.png]] Kotekst klassen ContentViewer f\u00e5r en strategy fra en af strategy klasserne og viser den via ShowContent metoden.</p> <p>Derefter udf\u00f8rer strategy klassen sin logik i metoden DisplayContent.</p> <p>Det smarte ved dette pattern er at der kan skiftes strategi og udf\u00f8rsel hele tiden, alt efter hvilken regler strategy klassen har. </p> <p>HVorfor strategy pattern: Den kan h\u00e5ndtere udskiftelige regler. Kan nemt h\u00e5ndtere den samme type handling, men p\u00e5 forskellige m\u00e5der.</p> <p>Strategy Pattern l\u00e6rte mig, hvordan adf\u00e6rd kan udskiftes uden at \u00e6ndre selve klassen. Men i det rigtige projekt blev jeg klar over, at rollebaseret visning h\u00f8rer til i Identity og UI\u2019et \u2014 ikke i strategi-klasser. Derfor brugte vi princippet, men ikke Strategy Pattern direkte. I et rigtigt Blazor/Identity-system giver denne tilgang mere mening:</p> <ul> <li><code>if (User.IsInRole(\"Admin\"))</code></li> <li><code>[Authorize(Roles=\"Member\")]</code></li> <li>UI der skjuler/shower elementer</li> <li>backend der beskytter endpoints</li> </ul> <p>Det h\u00e5ndterer pr\u00e6cis det Strategy skulle \u2014 bare bedre.</p> <p>Jeg havde i overvejelserne at der kunne v\u00e6re behov for m\u00f8nstret ved brug af forskellige notifications strategier - hvilket vi dog ikke implementerede</p> <p>Hvis der skulle v\u00e6re personlige anbefalinger, eller filter p\u00e5 s\u00f8gninger, men igen er det ikke noget vi har kunnet g\u00f8re brug af i det her lille projekt..</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/","title":"Oversigt","text":"<p>Dette er sektionen.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./","title":"ARKITEKTURKORT \u2014 Oversigt over arkitekturtyper.","text":""},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#1-klassisk-layered-architecture-3-tier-n-tier","title":"\ud83e\uddf1 1. Klassisk Layered Architecture (3-Tier / N-Tier)","text":""},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#opbygning","title":"Opbygning","text":"<ul> <li>UI (pr\u00e6sentation)</li> <li>Business / Service Layer</li> <li>Data / Repository / Database Access</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#god-til","title":"God til","text":"<ul> <li>sm\u00e5 til mellemstore systemer</li> <li>simple dom\u00e6ner</li> <li>hurtig udvikling</li> <li>struktureret adskillelse mellem UI og database</li> <li>let at forst\u00e5 (lav l\u00e6ringskurve)</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#ulemper","title":"Ulemper","text":"<ul> <li>Service Layer bliver ofte stort og rodet og med en masse services.</li> <li>dom\u00e6neregler spredes ud</li> <li>EF og teknologier siver op i dom\u00e6nelaget</li> <li>use cases er ikke isolerede</li> <li>afh\u00e6ngigheder g\u00e5r nedad, ikke indad</li> <li>sv\u00e6rt at udvide med nye moduler (fx AI)</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#sammenspil-med-projektet","title":"Sammenspil med projektet","text":"<p>I begyndelsen overvejede jeg denne arkitektur fint, fordi projektet virkede til at have et mindre dom\u00e6ne med simplere regler samt en begr\u00e6nset m\u00e6ngde features i f\u00f8lge vores analyser. Men da det virker til at AI-delen kr\u00e6ver lidt tilkobling udefra og da der iforhold til features er flere end f\u00f8rst antaget, s\u00e5 virker det ikke hel optimalt.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#2-hexagonal-architectur","title":"\ud83d\udfe6 **2. Hexagonal Architectur","text":""},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#opbygning_1","title":"Opbygning","text":"<ul> <li>Core Domain i midten</li> <li>Ports (interfaces) omkring</li> <li>Adapters (implementeringer) i ydre lag</li> <li>Data, UI, API\u2019er er \u201cplugins\u201d</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#god-til_1","title":"God til","text":"<ul> <li>st\u00e6rk isolation af dom\u00e6net</li> <li>let at udskifte teknologier</li> <li>testbarhed</li> <li>eksterne moduler s\u00e5som AI eller API-klienter</li> <li>l\u00f8s kobling</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#ulemper_1","title":"Ulemper","text":"<ul> <li>kr\u00e6ver meget disciplin</li> <li>For tungt til vores mindre projekter og kan ende med overengineering.</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#sammenspil-med-projektet_1","title":"Sammenspil med projektet","text":"<p>Da jeg kiggede p\u00e5 Hexagonal Architecture, kunne jeg godt se nogle id\u00e9er der gav mening for projektet. Is\u00e6r tanken om, at alt \u201cudenfor\u201d dom\u00e6net skal behandles som adaptere, som man kan skifte ud uden at r\u00f8re kerne-logikken.</p> <p>Det passer fint til:</p> <ul> <li>vores AI-del, som k\u00f8rer i Python</li> <li>databaseadgangen</li> <li>mails/notifikationer</li> </ul> <p>Hexagonal er fedt, men det er ogs\u00e5 ret \u201ctungt\u201d i den fulde form. Kravene til struktur, opdeling og dokumentation bliver hurtigt mere end vi reelt har brug for \u2014 is\u00e6r fordi vi ikke bygger microservices, og fordi vores team ikke har mulighed for at have meget samspil og analyse af den komplekse implementering det vil f\u00f8re til.</p> <p>S\u00e5 min konklusion blev:</p> <p>Hexagonal gav nogle gode id\u00e9er**, is\u00e6r omkring AI og eksterne ting som adaptere \u2014  </p> <p>men det ville v\u00e6re overkill at bruge som vores prim\u00e6re arkitektur.</p> <p>I et lille projekt som vores, hvor vi gerne vil holde tingene fleksible uden at overdesigne alt,  </p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#3-clean-architecture","title":"\ud83d\udfe9 3. Clean Architecture","text":""},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#opbygning_2","title":"Opbygning","text":"<ul> <li>Domain (Entities, Events, Value Objects)</li> <li>Application (Use cases, Commands, Queries, Interfaces)</li> <li>Infrastructure (Repos, EF Core, Email, API\u2019er, Identity)</li> <li>UI (Web / Blazor)</li> </ul> <p>Afh\u00e6ngigheder m\u00e5 KUN g\u00e5 indad mod Domain.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#god-til_2","title":"God til","text":"<ul> <li>komplekse dom\u00e6ner</li> <li>DDD-Principper</li> <li>klare use cases</li> <li>h\u00f8j testbarhed</li> <li>AI og eksterne systemer som infrastruktur</li> <li>Strukturering af kodeprojektet.</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#ulemper_2","title":"Ulemper","text":"<ul> <li>Flere nye tiltag der skal l\u00e6res.</li> <li>kr\u00e6ver disciplin</li> <li>st\u00f8rre mappestruktur</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#sammenspil-med-projektet_2","title":"Sammenspil med projektet","text":"<p>Clean Architecture virker til at passe godt til problemerne i vores projekt:</p> <ul> <li>domain forbliver rent</li> <li>AI blev en ekstern enhed.</li> <li>application use cases isolerer forretningslogik</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#4-vertical-slice-architecture","title":"\ud83d\udfe7 4. Vertical Slice Architecture","text":""},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#opbygning_3","title":"Opbygning","text":"<p>Hver feature (slice) indeholder:</p> <ul> <li>komponenter</li> <li>handlers</li> <li>modeller</li> <li>validering</li> <li>routes</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#god-til_3","title":"God til","text":"<ul> <li>store UI-lag (Blazor / ASP.NET)</li> <li>undg\u00e5 gigantiske service-lag</li> <li>klare feature-moduler</li> <li>hurtigere udvikling</li> <li>h\u00f8j sammenh\u00e6ng (cohesion)</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#ulemper_3","title":"Ulemper","text":"<ul> <li>kr\u00e6ver struktur</li> <li>matcher bedst sammen med Clean / CQRS</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#sammenspil-med-projektet_3","title":"Sammenspil med projektet","text":"<p>Her er det en fin nem m\u00e5de at opdele features og arbejde p\u00e5 tv\u00e6rs af hinanden i teamet, da man kan arbejde isoleret med egne features og emner i forhold til vertical slice principperne selv ved minimalt samarbejde og evaluering i teamet.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#5-microservices-architecture","title":"\ud83d\udfe5 **5. Microservices Architecture.","text":"<p>jeg analyserede kort microservices for at se, om det passede.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#god-til_4","title":"God til","text":"<ul> <li>store organisationer</li> <li>mange teams eller store teams</li> <li>ekstrem skalering af enkelte komponenter</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#ulemper_4","title":"Ulemper","text":"<ul> <li>ekstrem kompleksitet</li> <li>kr\u00e6ver DevOps, Kubernetes, distributed logging, tracing</li> <li>hver service har sin egen database</li> <li>slet ikke egnet til et lille projekt</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#sammenspil-med-projektet_4","title":"Sammenspil med projektet","text":"<ul> <li>AI-delen kunne v\u00e6re en microservice</li> <li>men resten af systemet ville blive over-engineered</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#6-modulr-monolith-analyse-af-denne-arkitekturform","title":"\ud83d\udfe9 6. Modul\u00e6r Monolith (analyse af denne arkitekturform)","text":""},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#opbygning-generelt","title":"Opbygning (generelt)","text":"<p>En modul\u00e6r monolith er stadig \u00e9t samlet system, men internt opdelt i moduler eller \u201cmini-dom\u00e6ner\u201d, ofte styret af:</p> <ul> <li>Clean Architecture eller andre lagdelingsmodeller</li> <li>Vertical Slice eller feature-baseret struktur i UI</li> <li>Dom\u00e6neomr\u00e5der opdelt som moduler eller bounded contexts</li> <li>En f\u00e6lles database eller delt infrastruktur</li> <li>Mulighed for eksterne moduler som AI, email, logging m.v.</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#hvad-en-modulr-monolith-generelt-er-god-til","title":"Hvad en modul\u00e6r monolith generelt er god til","text":"<ul> <li>H\u00f8j cohesion**: hvert modul har sine egne regler og logik</li> <li>Lav coupling**: moduler er adskilt af interfaces, domain events eller boundaries</li> <li>Skalering uden microservice-kompleksitet**</li> <li>God udvikleroplevelse**: \u00e9t projekt, men med klare gr\u00e6nser</li> <li>Mulighed for senere opsplitning** (hvis man vokser)</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#ulemper_5","title":"Ulemper","text":"<ul> <li>Kr\u00e6ver disciplin**, s\u00e5 modulerne ikke begynder at \u201cl\u00e6kke\u201d sammen</li> <li>St\u00f8rre intern struktur**, som kan virke tungt p\u00e5 et lille team</li> <li>Kan blive for meget**, hvis projektet reelt er lille og ikke vokser</li> <li>Klar afgr\u00e6nsning af dom\u00e6ner** kan kr\u00e6ve en del designarbejde</li> </ul> <p>Det er derfor en arkitektur, der giver rigtig god mening, hvis projektet vokser \u2014 men kan f\u00f8les overdrevet, hvis det er meget lille.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/1.%20Arkitektur%20gennemgang%20og%20korte%20analyser./#sammenspil-med-projektet-generelt-ikke-beslutning","title":"Sammenspil med projektet (generelt, ikke beslutning)","text":"<p>Under analysen af vores projekt har modul\u00e6r monolith vist sig som en mulighed, der:</p> <ul> <li>giver plads til, at dom\u00e6net kan udvikle sig i flere retninger</li> <li>passer godt til feature-baseret UI og vertical slice</li> <li>underst\u00f8tter rene lag og domain-fokuseret design</li> <li>ikke kr\u00e6ver drift eller kompleksitet som microservices</li> <li>tillader ekstern teknologi (fx AI) at ligge som eget modul</li> <li>bevarer fordelen ved \u00e9t samlet system (deploy, debugging, performance)</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/2.%20Clean%20architecture%20og%20modul%C3%A6r%20monolith./","title":"Fra Layered Architecture og hvorfor det naturligt f\u00f8rte til Modul\u00e6r Monolith, samt Clean Architecture**","text":""},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/2.%20Clean%20architecture%20og%20modul%C3%A6r%20monolith./#1-udgangspunktet-layered-architecture-var-frste-indskydelse","title":"**1) Udgangspunktet \u2013 Layered Architecture Var f\u00f8rste indskydelse","text":"<p>I begyndelsen var projektet lille og vi havde et godt kendskab til denne arkitektur fra tidligere semestre:</p> <ul> <li>brugere</li> <li>simple blogposts</li> <li>et lille dashboard</li> </ul> <p>Her var Layered Architecture et godt valg:</p> <ul> <li>det var hurtigt at bygge</li> <li>UI \u2192 Business \u2192 Data var simpelt og overskueligt.</li> <li>kompleksiteten var lav</li> <li>dom\u00e6net var simpelt Det gav os mulighed for at komme i gang uden at overdesigne.</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/2.%20Clean%20architecture%20og%20modul%C3%A6r%20monolith./#2layered-kunne-ikke-dkke-behovene","title":"**2)Layered kunne ikke d\u00e6kke behovene","text":"<p>Nye dom\u00e6neomr\u00e5der begyndte at dukke op, samt regler og kompleksitet og behov for moduler blev mere tydeligt:</p> <ul> <li>Content</li> <li>Membership</li> <li>Notifications</li> <li>AI-modulet</li> <li>flere regler og interaktioner mellem dom\u00e6ner</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/2.%20Clean%20architecture%20og%20modul%C3%A6r%20monolith./#problemer","title":"Problemer:","text":"<ul> <li>Business-laget blev stort og sammenblandet</li> <li>Dom\u00e6ne- og teknologilogik blev blandet</li> <li>Ingen naturlig m\u00e5de at adskille dom\u00e6ner internt</li> <li>Ingen isolation af AI</li> <li>Ingen beskyttelse af dom\u00e6net</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/2.%20Clean%20architecture%20og%20modul%C3%A6r%20monolith./#3-ai-modulets-integration","title":"3) AI-modulets integration","text":"<p>AI-delen var den direkte faktor der viste, at layered architecture ikke l\u00e6ngere var det rigtige for projektet:</p> <p>AI kr\u00e6vede bla.:</p> <ul> <li>isolation fra dom\u00e6net</li> <li>mulighed for at k\u00f8re i egen service/container   </li> <li>ingen direkte adgang til database</li> <li>fleksibilitet til at blive udskiftet eller \u00e6ndret</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/2.%20Clean%20architecture%20og%20modul%C3%A6r%20monolith./#4-derfor-blev-modulr-monolith-det-naturlige-nste-skridt","title":"4) Derfor blev Modul\u00e6r Monolith det naturlige n\u00e6ste skridt","text":"<p>I stedet for at hoppe direkte til microservices, som ville v\u00e6re \"overkill\", s\u00e5 var den bedste l\u00f8sning:</p> <p>Modul\u00e6r Monolith</p> <p>En modul\u00e6r monolith g\u00f8r det muligt at:</p> <ul> <li>adskille dom\u00e6ner fra hinanden</li> <li>holde funktioner i egne moduler</li> <li>isolere AI som eget modul</li> <li>beholde \u00e9t samlet kodebase og \u00e9t deployment</li> <li>undg\u00e5 kompleksiteten i microservices</li> </ul> <p>Det gav den balance mellem struktur og simplicitet projektet havde brug for.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/2.%20Clean%20architecture%20og%20modul%C3%A6r%20monolith./#5-modulr-monolith-hrer-ogsa-fint-sammen-med-clean-architecture","title":"5) Modul\u00e6r Monolith h\u00f8rer ogs\u00e5 fint sammen med Clean Architecture","text":"<p>Da projektet nu blev opdelt i interne moduler, opstod behovet for:</p> <ul> <li>rene dom\u00e6ner</li> <li>klare gr\u00e6nser mellem logik og teknologi</li> <li>\u00e9n vej for afh\u00e6ngigheded</li> <li>beskyttelse af dom\u00e6net</li> <li>testbarhed</li> <li>mulighed for at udskifte database, AI eller UI uden at p\u00e5virke dom\u00e6net</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/2.%20Clean%20architecture%20og%20modul%C3%A6r%20monolith./#hvorfor-clean-architecture","title":"Hvorfor Clean Architecture?","text":"<ul> <li>Dom\u00e6net skal v\u00e6re rent og stabilt</li> <li>Teknologier skal ligge i Infrastructure</li> <li>Use cases skal ligge i Application</li> <li>UI m\u00e5 kun kalde Application</li> <li>Infrastructure skal v\u00e6re \u201cplugins\u201d</li> </ul> <p>Clean Architecture gav struktur til den modul\u00e6re monolith.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/3.Vertical%20slice/","title":"Analyse: Hvorfor Vertical Slice Architecture blev et supplement til Clean Architecture","text":"<p>Efter vi havde valgt Clean Architecture** som den overordnede lagdeling (Domain, Application, Infrastructure, UI), stod vi overfor et nyt praktisk sp\u00f8rgsm\u00e5l:</p> <p>Hvordan organiserer vi de mange use cases og UI-flows, s\u00e5 de ikke ender i store services, spredt logik og uoverskuelige mapper?</p> <p>Clean Architecture giver de rigtige LAG. Men den beskriver ikke, hvordan dine features skal organiseres.</p> <p>Det var her Vertical Slice Architecture blev svaret.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/3.Vertical%20slice/#1-hvorfor-vertical-slice-var-ndvendigt-oven-pa-clean-architecture","title":"1) Hvorfor Vertical Slice var n\u00f8dvendigt oven p\u00e5 Clean Architecture","text":"<p>Selvom Clean Architecture gav klar lagdeling, gav det stadig ikke en l\u00f8sning p\u00e5:</p> <ul> <li>hvordan du organiserer Create, Edit, Delete, Moderate, ActivateMembership osv.</li> <li>hvordan du strukturerer UI i Blazor</li> <li>hvordan du undg\u00e5r store \u201cContentService\u201d og \u201cMembershipService\u201d</li> <li>hvordan du holder feature-logik samlet \u00e9t sted</li> </ul> <p>Dette krav om mange forskellige brugerhandlinger gjorde, at Clean Architecture IKKE var nok alene.</p> <p>Vi havde brug for:</p> <ul> <li>h\u00f8j cohesion</li> <li>lav coupling</li> <li>adskilte use cases</li> <li>sm\u00e5, fokuserede mapper</li> <li>en approach der nemt kunne bruges af vores team</li> </ul> <p>Det er pr\u00e6cis det Vertical Slice Architecture leverer.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/3.Vertical%20slice/#2-hvad-vertical-slice-architecture-er-og-hvorfor-det-passer-til-projektet","title":"2) Hvad Vertical Slice Architecture er \u2013 og hvorfor det passer til projektet","text":"<p>Vertical Slice betyder:</p> <p>En feature = \u00e9n samlet pakke af alt der skal bruges til den funktion.</p> <p>S\u00e5 fx \u201cCreateContent\u201d best\u00e5r af:</p> <ul> <li>Razor-page</li> <li>ViewModel / FormModel</li> <li>Command</li> <li>Handler</li> <li>Validation</li> <li>Repository-kald</li> <li>Domain events</li> <li>Response/DTO</li> <li>UI-kode</li> </ul> <p>Alt samlet i \u00e9n mappe:</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/3.Vertical%20slice/#3vertical-slice-og-clean-architecture-arbejder-sammen","title":"3)Vertical Slice og Clean Architecture arbejder sammen","text":"<p>Flowet er:</p> <p>UI \u2192 Feature Folder \u2192 Command/Query \u2192 Handler \u2192 Domain \u2192 Infrastructure</p> <p>Vertikal opdeling (Vertical Slice) fungerer indenfor lagene i Clean Architecture.</p> <p>Clean Architecture definerer lagene.</p> <p>Vertical Slice definerer hvordan du organiserer logikken inden i lagene.</p> <p>Det er derfor de to passer perfekt sammen.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/3.Vertical%20slice/#4-hvad-vertical-slice-giver-vores-projekt-i-praksis","title":"4) Hvad Vertical Slice giver vores projekt i praksis","text":""},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/3.Vertical%20slice/#overblik","title":"Overblik","text":"<p>Hver feature findes \u00e9t sted.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/3.Vertical%20slice/#ingen-mudret-services","title":"Ingen mudret services","text":"<p>Alt ligger i sm\u00e5, fokuserede use cases.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/3.Vertical%20slice/#let-ui-udvikling","title":"Let UI-udvikling","text":"<p>Blazor-udvikling bliver markant hurtigere.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/3.Vertical%20slice/#let-at-teste","title":"Let at teste","text":"<p>Handler + Domain kan testes isoleret.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/3.Vertical%20slice/#passer-til-modulr-monolith","title":"Passer til modul\u00e6r monolith","text":"<p>Hver modul kan have egne slices.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/3.Vertical%20slice/#vejen-banes-for-ddd","title":"Vejen banes for DDD","text":"<p>Aggregates og domain events passer perfekt ind i slices.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/3.Vertical%20slice/#samlet-konklusion","title":"Samlet konklusion","text":"<p>Vertical Slice Architecture blev valgt, fordi Clean Architecture alene ikke giver en brugbar struktur for mange UI-flows og use cases.</p> <p>Sammen g\u00f8r de to ting:</p> <ul> <li>Clean Architecture giver lag, isolation og rene regler</li> <li>Vertical Slice giver feature-opdeling, overskuelighed og hastighed i udviklingen Vertical Slice er derfor en naturlig tilf\u00f8jelse** ovenp\u00e5 Clean Architecture i projektet</li> </ul> <p>Det er denne kombination, der g\u00f8r systemet b\u00e5de let at vedligeholde og robust nok til at rumme mange forskellige dom\u00e6ner, AI-flows og fremtidig udvidelse.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./","title":"DDD","text":"<p>Efter at have etableret arkitekturen (Clean Architecture + Vertical Slice + Modul\u00e6r Monolith), var n\u00e6ste skridt at skabe en solid dom\u00e6nemodel. Arkitekturen giver rammen \u2014 men DDD (Domain-Driven Design) giver indholdet i dom\u00e6net.</p> <p>I dette indl\u00e6g forklarer vi:</p> <ul> <li> <p>hvorfor DDD blev n\u00f8dvendigt i vores projekt</p> </li> <li> <p>hvordan DDD er koblet til vores arkitektur</p> </li> <li> <p>hvilke patterns vi bruger i dom\u00e6net</p> </li> <li> <p>hvordan disse patterns p\u00e5virker projektets struktur og logik</p> </li> <li> <p>hvordan de forbereder os til n\u00e6ste del af l\u00e6ringen: design patterns</p> </li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#1-hvorfor-vi-havde-brug-for-ddd-i-projektet","title":"1) Hvorfor vi havde brug for DDD i projektet","text":"<p>DDD blev ikke valgt fordi \u201cdet er moderne\u201d, men fordi: vores dom\u00e6ne var for komplekst til simple modeller.</p> <p>Projektet havde:</p> <ul> <li> <p>content med regler og moderation</p> </li> <li> <p>medlemskaber (premium, owner, normal)</p> </li> <li> <p>reviews og opsummeringer</p> </li> <li> <p>dom\u00e6neh\u00e6ndelser</p> </li> <li> <p>forskellige brugertyper</p> </li> <li> <p>flere bounded contexts</p> </li> <li> <p>AI-genererede anbefalinger og analyser</p> </li> <li> <p>valideringsregler, workflows og tilstande</p> </li> </ul> <p>Dette er pr\u00e6cis den type system, hvor DDD giver v\u00e6rdi.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#2-hvordan-ddd-understtter-vores-arkitektur","title":"2) Hvordan DDD underst\u00f8tter vores arkitektur","text":"<p>DDD passer perfekt ovenp\u00e5 Clean Architecture.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#domain-laget-far-rene-modeller","title":"\u2714 Domain-laget f\u00e5r rene modeller","text":"<p>Entities og Value Objects uden EF Core eller AI-logik.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#application-laget-bliver-orkestrator","title":"\u2714 Application-laget bliver orkestrator","text":"<p>Use case handlers styrer workflows gennem Commands og Queries.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#infrastructure-bliver-teknologisk-adapter","title":"\u2714 Infrastructure bliver teknologisk adapter","text":"<p>Database, AI, Identity, Email og Logging er plugins.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#vertical-slice-forbinder-ui-til-use-cases","title":"\u2714 Vertical Slice forbinder UI til use cases","text":"<p>Hver slice aktiverer en handler, som interagerer med dom\u00e6net.</p> <p>DDD beskriver hvad der foreg\u00e5r i dom\u00e6net, Clean Architecture beskriver hvor det ligger, og Vertical Slice beskriver hvordan det bruges.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#3-ddd-begreber-brugt-i-projektet","title":"3) DDD-begreber brugt i projektet","text":"<p>Her gennemg\u00e5r vi de konkrete patterns, du rent faktisk bruger i dit projekt \u2014 og som l\u00e6reren forventer, du kan forklare.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#a-entities-ting-med-identitet","title":"\u2b50 A) Entities \u2014 ting med identitet","text":"<p>Eksempler fra projektet:</p> <ul> <li> <p>Content (post/artikel)</p> </li> <li> <p>Review</p> </li> <li> <p>Membership</p> </li> <li> <p>User</p> </li> </ul> <p>Karakteristika:</p> <ul> <li> <p>har ID</p> </li> <li> <p>\u00e6ndrer tilstand</p> </li> <li> <p>har regler</p> </li> <li> <p>kan trigge domain events</p> </li> </ul> <p>I projektet: Entities ligger i Domain og indeholder AL logik der h\u00f8rer til objektets kerne.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#b-value-objects-vrdier-der-reprsenterer-kvalitet-ikke-identitet","title":"\u2b50 B) Value Objects \u2014 v\u00e6rdier der repr\u00e6senterer kvalitet, ikke identitet","text":"<p>Eksempler:</p> <ul> <li> <p>Title</p> </li> <li> <p>ContentBody</p> </li> <li> <p>MembershipType</p> </li> <li> <p>EmailAddress</p> </li> </ul> <p>Karakteristika:</p> <ul> <li> <p>immutables</p> </li> <li> <p>sammenlignes p\u00e5 v\u00e6rdi</p> </li> <li> <p>valideres i konstrukt\u00f8ren</p> </li> </ul> <p>I projektet: Value Objects blev vigtige for at sikre datakvalitet og forretningsregler t\u00e6t p\u00e5 modellen.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#c-domain-services-logik-der-ikke-hrer-til-en-enkelt-entity","title":"\u2b50 C) Domain Services \u2014 logik der ikke h\u00f8rer til en enkelt entity","text":"<p>Eksempler:</p> <ul> <li> <p>Beregning af medlemskab tilstand</p> </li> <li> <p>Moderationsstrategi for content</p> </li> <li> <p>Aggregation af data p\u00e5 tv\u00e6rs af entities</p> </li> </ul> <p>Domain services ligger i Domain, men de orkestrerer regler mellem flere modeller.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#d-aggregates-grupper-af-entities-der-hnger-sammen","title":"\u2b50 D) Aggregates \u2014 grupper af entities der h\u00e6nger sammen","text":"<p>Eksempler:</p> <ul> <li> <p>Content + Reviews kan v\u00e6re separate aggregates</p> </li> <li> <p>Membership kan v\u00e6re sin egen aggregate</p> </li> </ul> <p>Regel:</p> <p>\u201cKun aggregate root m\u00e5 eksponeres til omverdenen.\u201d</p> <p>Dette styrer dataintegritet og reducerer coupling.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#e-domain-events-hndelser-udlst-af-domnet","title":"\u2b50 E) Domain Events \u2014 h\u00e6ndelser udl\u00f8st af dom\u00e6net","text":"<p>Brugt aktivt i projektet:</p> <ul> <li> <p>PostPublishedEvent</p> </li> <li> <p>MembershipActivatedEvent</p> </li> <li> <p>ReviewCreatedEvent</p> </li> </ul> <p>Fordele:</p> <ul> <li> <p>l\u00f8s kobling mellem dom\u00e6ner</p> </li> <li> <p>Application-layer h\u00e5ndterer sideeffekter</p> </li> <li> <p>Infrastructure udf\u00f8rer tekniske ting (fx email, AI analyse)</p> </li> </ul> <p>Dette passer perfekt til Clean Architecture\u2019s afh\u00e6ngighedsregler.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#f-repositories-ddd-versionen","title":"\u2b50 F) Repositories (DDD-versionen)","text":"<p>I DDD er et repository:</p> <p>\u201cEn samling af aggregates som du henter og gemmer.\u201d</p> <p>Vi bruger:</p> <ul> <li> <p>IContentRepository</p> </li> <li> <p>IUserRepository</p> </li> <li> <p>IMembershipRepository</p> </li> <li> <p>IReviewRepository</p> </li> </ul> <p>Alle som interfaces i Application-laget og implementeret i Infrastructure (EF Core).</p> <p>Dette giver:</p> <ul> <li> <p>lav coupling</p> </li> <li> <p>teknologisk udskiftelighed</p> </li> <li> <p>klar ansvarsfordeling</p> </li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#g-bounded-contexts-de-naturlige-domneopdelinger","title":"\u2b50 G) Bounded Contexts \u2014 de naturlige dom\u00e6neopdelinger","text":"<p>I vores projekt fandt vi disse bounded contexts:</p> <ul> <li> <p>Content</p> </li> <li> <p>Membership</p> </li> <li> <p>Review</p> </li> <li> <p>Notification</p> </li> <li> <p>Chat/AI</p> </li> </ul> <p>Hver context har:</p> <ul> <li> <p>egne modeller</p> </li> <li> <p>egne events</p> </li> <li> <p>egne regler</p> </li> <li> <p>egne use cases</p> </li> <li> <p>egne vertical slices</p> </li> </ul> <p>Dette er fundamentet for modul\u00e6r monolith.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#4-hvordan-ddd-patterns-understtter-projektets-arkitektur","title":"4) Hvordan DDD patterns underst\u00f8tter projektets arkitektur","text":"<p>N\u00e5r vi ser DDD sammen med Clean Architecture og Vertical Slice, fungerer de s\u00e5dan:</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#ddd-giver-domnet-form","title":"\u2714 DDD giver dom\u00e6net form","text":"<p>\u2192 Entities, Value Objects, Aggregates, Events</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#clean-architecture-beskytter-domnet","title":"\u2714 Clean Architecture beskytter dom\u00e6net","text":"<p>\u2192 Domain er rent, Application orkestrerer</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#vertical-slice-styrer-brugen-i-ui-og-use-cases","title":"\u2714 Vertical Slice styrer brugen i UI og Use Cases","text":"<p>\u2192 hver feature kobler direkte til en handler i Application</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#modulr-monolith-holder-domnerne-samlet-men-adskilt","title":"\u2714 Modul\u00e6r Monolith holder dom\u00e6nerne samlet men adskilt","text":"<p>\u2192 bounded contexts er moduler, ikke microservices</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#5-hvordan-ddd-patterns-gr-koden-bedre-for-dig-og-i-praksis","title":"5) Hvordan DDD patterns g\u00f8r koden bedre (for dig og i praksis)","text":""},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#koden-bliver-nemmere-at-lse","title":"\u2b50 Koden bliver nemmere at l\u00e6se","text":"<p>(Entity-logik samlet, ingen spaghetti)</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#domnet-afspejler-virkeligheden","title":"\u2b50 Dom\u00e6net afspejler virkeligheden","text":"<p>(membership, content, premium, moderation)</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#regler-bor-samme-sted-som-data","title":"\u2b50 Regler bor samme sted som data","text":"<p>(ikke i services og controllers)</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#domnet-er-framework-uafhngigt","title":"\u2b50 Dom\u00e6net er framework-uafh\u00e6ngigt","text":"<p>(giver testbarhed og mulighed for fremtidige \u00e6ndringer)</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#sideeffekter-handteres-korrekt","title":"\u2b50 Sideeffekter h\u00e5ndteres korrekt","text":"<p>(domain event \u2192 application handler \u2192 infra service)</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#perfect-match-til-design-patterns","title":"\u2b50 Perfect match til design patterns","text":"<p>(strategy, factory, observer vs domain events)</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#6-hvordan-dette-leder-naturligt-videre-til-design-patterns","title":"6) Hvordan dette leder naturligt videre til design patterns","text":"<p>DDD bruger allerede patterns \u2014 og du bruger dem i projektet.</p> <p>Det giver en glidende overgang til n\u00e6ste indl\u00e6g:</p> <ul> <li> <p>Strategy Pattern i moderation, membership, AI flows</p> </li> <li> <p>Factory Pattern i content creation og dom\u00e6nebygning</p> </li> <li> <p>Observer vs Domain Events (dit projekt bruger Domain Events)</p> </li> <li> <p>Repository Pattern (DDD-versionen)</p> </li> <li> <p>CQRS via Commands/Queries i vertical slices</p> </li> <li> <p>Specification Pattern (valgfrit, men passer godt til dom\u00e6neregler)</p> </li> </ul> <p>DDD er derfor broen mellem:</p> <p>\u2714 arkitekturen (Clean + Vertical + Modul\u00e6r Monolith) \u2714 og patterns-delen, som kommer i n\u00e6ste fase af l\u00e6ringsforl\u00f8bet.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/4.%20Dom%C3%A6ne%20driven%20design%20-%20DDD%20patterns./#konklusion","title":"\u2b50 Konklusion","text":"<p>DDD blev ikke et teoretisk lag i projektet \u2014 det blev den m\u00e5de, vi strukturerede dom\u00e6net p\u00e5:</p> <ul> <li> <p>Entities og Value Objects beskytter data og regler</p> </li> <li> <p>Aggregates og domain boundaries styrer kompleksitet</p> </li> <li> <p>Domain Events g\u00f8r dom\u00e6net reaktivt og fleksibelt</p> </li> <li> <p>Repositories abstraherer persistence</p> </li> <li> <p>Domain services h\u00e5ndterer regler p\u00e5 tv\u00e6rs</p> </li> <li> <p>Bounded contexts giver modulopdeling</p> </li> </ul> <p>Sammen med Clean Architecture og Vertical Slice skaber DDD en robust, skalerbar og forst\u00e5elig kodebase, der kan b\u00e6re b\u00e5de AI, dom\u00e6nekoblinger og fremtidig v\u00e6kst.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/CQRS%20i%20vores%20projekt%20med%20vertical%20slice/","title":"**CQRS + Vertical Slice Architecture (og hvorfor det passer perfekt til projektet","text":"<p>CQRS og Vertical Slice Architecture h\u00e6nger t\u00e6t sammen. Faktisk giver CQRS f\u00f8rst mening i praksis, n\u00e5r man bruger vertical slice eller eventuelle variationer af \u201cfeature-based architecture\u201d.</p> <p>Vertical Slice er UI + Application struktur. CQRS er handler-m\u00f8nstret i Application-laget.</p> <p>Her forklarer vi:</p> <ul> <li>hvad CQRS er</li> <li>hvordan det h\u00e6nger sammen med vertical slice</li> <li>hvordan vi bruger det i projektet</li> <li>hvad vi opn\u00e5r</li> <li>hvad vi undg\u00e5r</li> <li>hvad alternativerne er</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/CQRS%20i%20vores%20projekt%20med%20vertical%20slice/#1-grundideen-i-cqrs","title":"1) Grundid\u00e9en i CQRS","text":"<p>CQRS betyder:</p> <p>Command Query Responsibility Segregation \u2192 Adskil \u201cread\u201d og \u201cwrite\u201d.</p> <p>Det betyder:</p> <ul> <li> <p>Command = noget der \u00e6ndrer tilstand     Create, update osv..</p> </li> <li> <p>Query = noget der l\u00e6ser data     Get</p> </li> </ul> <p>I vores projekt:</p> <ul> <li>Vertical Slice \u2192 \u00e9n mappe per feature</li> <li>CQRS \u2192 \u00e9n handler per operation</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/CQRS%20i%20vores%20projekt%20med%20vertical%20slice/#2-hvorfor-cqrs-passer-perfekt-til-vertical-slice","title":"2) Hvorfor CQRS passer perfekt til Vertical Slice","text":"<p>Vertical Slice siger:</p> <ul> <li>hver feature er sin egen \u201cslice\u201d</li> <li>UI + Command/Query + Handler + Validator + Repo + Domain-logik</li> <li>alt ligger samlet \u00e9t sted \u2192 h\u00f8j cohesion</li> </ul> <p>CQRS siger:</p> <ul> <li>\u201chver operation skal v\u00e6re sin egen handler\u201d</li> </ul> <p>Vertical Slice bestemmer strukturen. CQRS bestemmer handler-metoden.</p> <p>Det giver:</p> <ul> <li>ingen store services</li> <li>ingen blanding af use cases</li> <li>ingen k\u00e6mpe \u201cgod class\u201d eller service klasse.</li> <li>rene flows</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/CQRS%20i%20vores%20projekt%20med%20vertical%20slice/#3-hvorfor-cqrs-blev-ndvendigt-i-dit-projekt","title":"3) Hvorfor CQRS blev n\u00f8dvendigt i dit projekt","text":"<p>Use cases var flere end f\u00f8rst antaget og nogle af dom\u00e6nerne har mange use cases </p> <p>Hvis alt dette l\u00e5 i \u00e9n \u201cContentService\u201d:</p> <ul> <li>mange linjer af kode</li> <li>afh\u00e6ngigheder p\u00e5 kryds og tv\u00e6rs</li> <li>ingen forst\u00e5elig arkitektur</li> </ul> <p>CQRS l\u00f8ser dette:</p> <p>Det er simpelt, testbart, og Clean Architecture-kompatibelt.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/CQRS%20i%20vores%20projekt%20med%20vertical%20slice/#4-hvordan-cqrs-bruges-i-projektet","title":"4) Hvordan CQRS bruges i projektet","text":"<p>Kontaktformularen i projektet er bygget efter CQRS-princippet, hvor kommandoer st\u00e5r for \u00e6ndringer, og queries st\u00e5r for l\u00e6sning. N\u00e5r en bruger sender en kontaktbesked, h\u00e5ndteres processen som en Command, der udf\u00f8rer en r\u00e6kke opgaver i en klar og adskilt sekvens.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/CQRS%20i%20vores%20projekt%20med%20vertical%20slice/#1-commanden-skabes-i-ui-laget","title":"1. Commanden skabes i UI-laget","text":"<p>N\u00e5r en bruger indsender kontaktformularen, skabes en kommando, som repr\u00e6senterer intentionen: \u201cSend denne kontaktbesked\u201d. UI'et sender ikke dom\u00e6neobjekter videre \u2013 kun de rene v\u00e6rdier, der skal bruges til at udf\u00f8re handlingen.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/CQRS%20i%20vores%20projekt%20med%20vertical%20slice/#2-commanden-modtages-i-application-laget","title":"2. Commanden modtages i Application-laget","text":"<p>I stedet for at UI kalder en service direkte, opfanges kommandoen af en handler i Application-laget. Dette sikrer, at al logik for at \u00e6ndre systemets tilstand ligger \u00e9t sted, isoleret i sin egen vertical slice. Handleren er ansvarlig for forretningsflowet, ikke UI\u2019et.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/CQRS%20i%20vores%20projekt%20med%20vertical%20slice/#3-domneobjektet-oprettes","title":"3. Dom\u00e6neobjektet oprettes","text":"<p>I handleren skabes der et ContactMessage-dom\u00e6neobjekt. Dette objekt indeholder al den n\u00f8dvendige information og er ansvarlig for at h\u00e5ndh\u00e6ve dom\u00e6nets regler, fx at nye beskeder automatisk f\u00e5r status som \u201cny\u201d.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/CQRS%20i%20vores%20projekt%20med%20vertical%20slice/#4-persistens-udfres-gennem-et-repository","title":"4. Persistens udf\u00f8res gennem et repository","text":"<p>Application-laget gemmer dom\u00e6neobjektet via et repository-interface. Dette betyder, at Application-laget ikke ved noget om databasen, EF Core, SQL eller noget andet teknisk \u2014 kun at objektet skal gemmes. CQRS sikrer her en ren adskillelse mellem intentionen og implementeringen.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/CQRS%20i%20vores%20projekt%20med%20vertical%20slice/#5-sideeffekter-handteres-efter-persistens","title":"5. Sideeffekter h\u00e5ndteres efter persistens","text":"<p>Efter beskeden er gemt, udf\u00f8rer handleren de n\u00f8dvendige sideeffekter \u2014 i dette tilf\u00e6lde at sende en e-mail til ejeren af siden. Denne opgave h\u00e5ndteres via en e-mail-notifikationsservice, som er abstraheret bag et interface. CQRS sikrer dermed, at kommandoens ansvar er tydeligt:</p> <ul> <li>f\u00f8rst \u00e6ndres systemets tilstand</li> <li>derefter udf\u00f8res n\u00f8dvendige opf\u00f8lgende handlinger</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/CQRS%20i%20vores%20projekt%20med%20vertical%20slice/#6-domnelaget-forbliver-rent","title":"6. Dom\u00e6nelaget forbliver rent","text":"<p>ContactMessage-dom\u00e6neobjektet har ingen afh\u00e6ngighed til applikationslogik, databaser eller notifikationer. Det indeholder kun data og regler. Dette er i tr\u00e5d med b\u00e5de CQRS og Clean Architecture, hvor dom\u00e6net skal v\u00e6re helt teknologiuafh\u00e6ngigt.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/CQRS%20i%20vores%20projekt%20med%20vertical%20slice/#7-ingen-lselogik-blandes-ind","title":"7. Ingen l\u00e6selogik blandes ind","text":"<p>De beskeder, der bliver gemt, hentes senere via rene Query-operationer. Disse ligger i deres egen slice, adskilt fra Commands. CQRS-princippet sikrer dermed, at \"send besked\" og \"hent beskeder\" er to fuldst\u00e6ndigt adskilte flows.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/CQRS%20i%20vores%20projekt%20med%20vertical%20slice/#hvad-vi-opnar-i-projektet-ved-at-bruge-cqrs","title":"Hvad vi opn\u00e5r i projektet ved at bruge CQRS","text":"<ul> <li> <ol> <li>Ren separering af logik</li> </ol> </li> </ul> <p>Read- og write-operationer blandes ikke sammen.</p> <ul> <li> <ol> <li>Sm\u00e5, klare, testbare klasser</li> </ol> </li> </ul> <p>En handler med 15\u201340 linjer i stedet for \u00e9n service med 500.</p> <ul> <li> <ol> <li>Bedre domain-model</li> </ol> </li> </ul> <p>Hver handler styrer \u00e9t use case \u2192 klarere dom\u00e6neregler.</p> <ul> <li> <ol> <li>Passer perfekt med domain events</li> </ol> </li> </ul> <p>Commands = raise events Queries = ingen events Det giver ren forretningslogik.</p> <ul> <li> <ol> <li>Passer perfekt med Clean Architecture</li> </ol> </li> </ul> <p>UI \u2192 Application \u2192 Domain \u2192 Infrastructure er klart opdelt.</p> <ol> <li>Passer perfekt med modul\u00e6r monolith</li> </ol> <p>Hver bounded context f\u00e5r sine egne commands/queries.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/CQRS%20i%20vores%20projekt%20med%20vertical%20slice/#konklusion","title":"Konklusion","text":"<p>CQRS og Vertical Slice Architecture fungerer som to sider af samme m\u00f8nt i projektet. Vertical Slice styrer strukturen, CQRS styrer logikken. Resultatet er rene use cases, l\u00f8s kobling, h\u00f8j testbarhed og en langt mere vedligeholdelig modul\u00e6r monolith.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./","title":"Repository Pattern, Interfaces og Infrastructure som Plugin-model","text":"<p>Dette indl\u00e6g forklarer tre t\u00e6t forbundne dele af dit projekts arkitektur:</p> <ul> <li>Repository Pattern (DDD-versionen)</li> <li>Interface-abstraktion (Application \u2192 Infrastructure)</li> <li>Infrastructure som \u201cplugin-lag\u201d</li> </ul> <p>De tre ting h\u00e6nger ul\u00f8seligt sammen og er fundamentale i vores Clean Architecture + DDD-ops\u00e6tning.</p> <p>De skaber:</p> <ul> <li>l\u00f8s kobling</li> <li>testbarhed</li> <li>ren dom\u00e6nelogik</li> <li>udskiftelig database</li> <li>modul\u00e6r arkitektur</li> <li>klar afh\u00e6ngighedsretning</li> <li>integration med CQRS og Vertical Slice</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#1-repository-pattern-i-ddd","title":"1) Repository Pattern i DDD","text":""},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#i-ddd-betyder-repository","title":"I DDD betyder Repository:","text":"<p>\u201cEn samling af aggregates, som du kan hente og gemme, som var det en samling i hukommelsen.\u201d</p> <p>Et repository repr\u00e6senterer dom\u00e6nets syn p\u00e5 persistence \u2014 ikke databasens.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#i-vores-projekt-betyder-det","title":"I vores projekt betyder det:","text":""},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#interface-i-application-laget","title":"Interface i Application-laget","text":"<p>(Hvorfor? Fordi Application bestemmer, hvad der skal kunne persisteres.)</p> <p>Eksempler:</p> <ul> <li><code>IContentRepository</code></li> <li><code>IReviewRepository</code></li> <li><code>IMembershipRepository</code></li> <li><code>IUserRepository</code></li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#implementation-i-infrastructure","title":"Implementation i Infrastructure","text":"<p>(Hvorfor? Fordi Infrastructure bestemmer hvordan det persisteres.)</p> <p>Eksempler:</p> <ul> <li><code>EfContentRepository</code></li> <li><code>EfReviewRepository</code></li> <li><code>EfMembershipRepository</code></li> <li><code>EfUserRepository</code></li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#2-hvorfor-repository-pattern-er-ndvendigt-i-vores-arkitektur","title":"2) Hvorfor Repository Pattern er n\u00f8dvendigt i vores arkitektur","text":""},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#1-domain-skal-ikke-vide-noget-om-ef-core","title":"1. Domain skal ikke vide noget om EF Core","text":"<p>Entities m\u00e5 ikke kalde DB.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#2-application-skal-ikke-bruge-teknologier-direkte","title":"2. Application skal ikke bruge teknologier direkte","text":"<p>Det m\u00e5 kun kommunikere via interfaces.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#3-infrastructure-skal-vre-udskifteligt","title":"3. Infrastructure skal v\u00e6re udskifteligt","text":"<p>EF Core kan erstattes af Dapper, SQL, Cosmos DB eller en fil \u2014 uden at \u00e6ndre Application.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#4-domain-kan-testes-uden-database","title":"4. Domain kan testes uden database","text":"<p>Vi kan mocke alle repos i tests.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#5-vertical-slice-handler-pipelinen-bliver-ren","title":"5. Vertical Slice handler-pipelinen bliver ren","text":"<p>Hver handler:</p> <ol> <li>Modtager command/query</li> <li>Kalder interface</li> <li>Manipulerer domain</li> <li>Kalder interface for at gemme</li> </ol> <p>Alt er rent og let at l\u00e6se og teste.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#3-hvad-et-repository-ikke-er-i-ddd","title":"3) Hvad et Repository ikke er i DDD","text":"<p>Mange laver fejl her.</p> <p>Et repository er ikke:</p> <ul> <li>en generel CRUD-service</li> <li>en databasetilgangsklasse</li> <li>et sted med forretningslogik</li> <li>en \u201chelper-klasse\u201d</li> </ul> <p>Et repository er en abstraktion af et dom\u00e6ne-aggregat.</p> <p>Eksempel:</p> <p>\u201cContent-aggregatet best\u00e5r af Content + Comments + Rules. Repositoriet h\u00e5ndterer dette samlede objekt.\u201d</p> <p>Det betyder:</p> <ul> <li>kun aggregate roots eksponeres</li> <li>konsistensregler bevares</li> <li>domain forbliver i kontrol</li> <li>EF Core modeller holder sig i Infrastructure</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#4-interface-abstraktion-application-bestemmer-hvad-infrastructure-bestemmer-hvordan","title":"4) Interface-abstraktion: Application bestemmer hvad, Infrastructure bestemmer hvordan","text":"<p>Den vigtigste regel i Clean Architecture:</p> <p>\u201cAfh\u00e6ngigheder g\u00e5r indad.\u201d</p> <p>Det betyder:</p> <ul> <li>Application m\u00e5 ikke afh\u00e6nge af EF, AI-klienter, email osv.</li> <li>Domain m\u00e5 ikke kende noget udenfor sig selv</li> <li>Infrastructure m\u00e5 gerne afh\u00e6nge af Domain/Application</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#derfor-ligger-interfaces-i-application","title":"Derfor ligger interfaces i Application.","text":"<p>Flow:</p> <p><code>Application     \u2193 Interface (IContentRepository)    \u2193 Infrastructure    \u2193 EfContentRepository implementerer interfacet</code></p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#5-infrastructure-som-plugin-lag","title":"5) Infrastructure som plugin-lag","text":"<p>Dette er essensen af Clean Architecture:</p> <p>Infrastructure skal kunne skiftes ud uden at \u00e6ndre dom\u00e6net eller use cases.</p> <p>I dette projekt betyder det, at alle disse ting kan udskiftes: - database (Postgres \u2192 SQL \u2192 InMemory) - AI-service (Python \u2192 andre modeller) - Email service - Logging service - Notifikationsservice - Identity (kun adapter, domain er ikke afh\u00e6ngig)</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#6-hvordan-repository-interfaces-og-plugin-model-bruges-i-vores-projekt","title":"6) Hvordan Repository, Interfaces og Plugin-model bruges i vores projekt","text":""},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#i-domain","title":"I Domain:","text":"<p>Ingen database \u2014 kun Entities, Value Objects og Events.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#i-application","title":"I Application:","text":"<ul> <li>Commands/Queries</li> <li>Use Case Handlers</li> <li>Interfaces</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#i-infrastructure","title":"I Infrastructure:","text":"<ul> <li>konkrete repos \u2192 <code>EfContentRepository</code></li> <li>databasekode (EF Core)</li> <li>AI-adapter</li> <li>Emailservice</li> <li>Logging</li> <li>Identity-adapter</li> </ul>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#i-web-vertical-slices","title":"I Web (Vertical Slices):","text":"<p>En handler kalder kun interfaces. UI har ingen ide om hvordan data ender i DB.</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#7-hvorfor-denne-model-er-bedre-end-alternativer-i-vores-projekt","title":"7) Hvorfor denne model er bedre end alternativer (i vores projekt)","text":""},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#alternativ-1-direkte-ef-core-brug-i-application","title":"\u25b6 Alternativ 1: Direkte EF Core brug i Application","text":"<p>\u2192 hurtigere at bygge, men umuligt at teste \u2192 bryder Clean Architecture \u2192 domain bliver framework-afh\u00e6ngigt</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#alternativ-2-et-stort-dataservice-eller-contentservice","title":"\u25b6 Alternativ 2: Et stort \u201cDataService\u201d eller \u201cContentService\u201d","text":"<p>\u2192 service-gr\u00f8d \u2192 sv\u00e6rt at forst\u00e5, teste og udvide \u2192 alle use cases blandet sammen</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#alternativ-3-infrastructure-i-domain","title":"\u25b6 Alternativ 3: Infrastructure i Domain","text":"<p>\u2192 ren anti-pattern \u2192 domain er ikke l\u00e6ngere dom\u00e6ne \u2192 alt bliver koblet sammen</p>"},{"location":"Software-arkitektur/Software%20arkitektur%20forst%C3%A5else%20og%20analyse/Repository%20pattern%20i%20vores%20projekt./#alternativ-4-microservices-repos-polyglot-persistence","title":"\u25b6 Alternativ 4: Microservices repos / polyglot persistence","text":"<p>\u2192 alt for tungt for dit projekt \u2192 kr\u00e6ver event-bus, saga, orchestrator \u2192 3\u20134 gange kompleksiteten</p> <p>Valget vi tog er langt det mest balancerede ift. arkitektur &amp; kompleksitet.</p>"}]}